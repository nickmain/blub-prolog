# Generated by Haxe 4.1.3
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import sys as python_lib_Sys
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import re as python_lib_Re
import subprocess as python_lib_Subprocess
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
try:
    import tty as python_lib_Tty
except:
    pass
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timedelta as python_lib_datetime_Timedelta
from datetime import tzinfo as python_lib_datetime_Tzinfo
from datetime import timezone as python_lib_datetime_Timezone
from io import IOBase as python_lib_io_IOBase
from io import BufferedIOBase as python_lib_io_BufferedIOBase
from io import RawIOBase as python_lib_io_RawIOBase
from io import FileIO as python_lib_io_FileIO
from io import TextIOBase as python_lib_io_TextIOBase
from io import StringIO as python_lib_io_StringIO
from time import struct_time as python_lib_time_StructTime
import urllib.parse as python_lib_urllib_Parse


def _hx_resources__():
    import inspect
    import sys
    if not hasattr(sys.modules[__name__], '__file__'):
        _file = 'app.py'
    else:
        _file = __file__
    return {"ConstraintHandlingRules.prolog": open('%s.%s'%(_file,'ConstraintHandlingRules.prolog'),'rb').read(),"DefiniteClauseGrammar.prolog": open('%s.%s'%(_file,'DefiniteClauseGrammar.prolog'),'rb').read()}


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



_hx_classes = {}


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
_hx_classes["Enum"] = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["getTime", "getHours", "getMinutes", "getSeconds", "getFullYear", "getMonth", "getDate", "getDay", "getUTCHours", "getUTCMinutes", "getUTCSeconds", "getUTCFullYear", "getUTCMonth", "getUTCDate", "getUTCDay", "getTimezoneOffset", "toString"]
    _hx_statics = ["now", "fromTime", "makeLocal", "UTC", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def getTime(self):
        return (self.date.timestamp() * 1000)

    def getHours(self):
        return self.date.hour

    def getMinutes(self):
        return self.date.minute

    def getSeconds(self):
        return self.date.second

    def getFullYear(self):
        return self.date.year

    def getMonth(self):
        return (self.date.month - 1)

    def getDate(self):
        return self.date.day

    def getDay(self):
        return HxOverrides.mod(self.date.isoweekday(), 7)

    def getUTCHours(self):
        return self.dateUTC.hour

    def getUTCMinutes(self):
        return self.dateUTC.minute

    def getUTCSeconds(self):
        return self.dateUTC.second

    def getUTCFullYear(self):
        return self.dateUTC.year

    def getUTCMonth(self):
        return (self.dateUTC.month - 1)

    def getUTCDate(self):
        return self.dateUTC.day

    def getUTCDay(self):
        return HxOverrides.mod(self.dateUTC.isoweekday(), 7)

    def getTimezoneOffset(self):
        x = (self.date.utcoffset() / python_lib_datetime_Timedelta(0,60))
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        return -tmp

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def UTC(year,month,day,hour,_hx_min,sec):
        return (python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0,python_lib_datetime_Timezone.utc).timestamp() * 1000)

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date.fromTime((((Std.parseInt((k[0] if 0 < len(k) else None)) * 3600000.) + ((Std.parseInt((k[1] if 1 < len(k) else None)) * 60000.))) + ((Std.parseInt((k[2] if 2 < len(k) else None)) * 1000.))))
        elif (_g == 10):
            k = s.split("-")
            return Date(Std.parseInt((k[0] if 0 < len(k) else None)),(Std.parseInt((k[1] if 1 < len(k) else None)) - 1),Std.parseInt((k[2] if 2 < len(k) else None)),0,0,0)
        elif (_g == 19):
            k = s.split(" ")
            _this = (k[0] if 0 < len(k) else None)
            y = _this.split("-")
            _this = (k[1] if 1 < len(k) else None)
            t = _this.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise haxe_Exception.thrown(("Invalid date format : " + ("null" if s is None else s)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
_hx_classes["Date"] = Date


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["match", "matched", "matchedLeft", "matchedRight", "matchedPos", "matchSub", "split", "replace", "map"]
    _hx_statics = ["escape"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def match(self,s):
        self.matchObj = python_lib_Re.search(self.pattern,s)
        return (self.matchObj is not None)

    def matched(self,n):
        return self.matchObj.group(n)

    def matchedLeft(self):
        return HxString.substr(self.matchObj.string,0,self.matchObj.start())

    def matchedRight(self):
        return HxString.substr(self.matchObj.string,self.matchObj.end(),None)

    def matchedPos(self):
        return _hx_AnonObject({'pos': self.matchObj.start(), 'len': (self.matchObj.end() - self.matchObj.start())})

    def matchSub(self,s,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x = HxString.substr(s,lastEnd,None)
            ret.append(x)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]

    def replace(self,s,by):
        _this = by.split("$$")
        by = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this])
            _this = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def escape(s):
        return python_lib_Re.escape(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
_hx_classes["EReg"] = EReg


class _EnumValue_EnumValue_Impl_:
    _hx_class_name = "_EnumValue.EnumValue_Impl_"
    __slots__ = ()
    _hx_statics = ["match"]

    @staticmethod
    def match(this1,pattern):
        return False
_hx_classes["_EnumValue.EnumValue_Impl_"] = _EnumValue_EnumValue_Impl_


class IntIterator:
    _hx_class_name = "IntIterator"
    __slots__ = ("min", "max")
    _hx_fields = ["min", "max"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_min,_hx_max):
        self.min = _hx_min
        self.max = _hx_max

    def hasNext(self):
        return (self.min < self.max)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.min
                _hx_local_0.min = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_local_2()
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.min = None
        _hx_o.max = None
_hx_classes["IntIterator"] = IntIterator


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["hasField", "field", "setField", "getProperty", "setProperty", "callMethod", "fields", "isFunction", "compare", "isClosure", "compareMethods", "isObject", "isEnumValue", "deleteField", "copy", "makeVarArgs"]

    @staticmethod
    def hasField(o,field):
        return python_Boot.hasField(o,field)

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def getProperty(o,field):
        if (o is None):
            return None
        if (field in python_Boot.keywords):
            field = ("_hx_" + field)
        elif ((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95))):
            field = ("_hx_" + field)
        if isinstance(o,_hx_AnonObject):
            return Reflect.field(o,field)
        tmp = Reflect.field(o,("get_" + ("null" if field is None else field)))
        if ((tmp is not None) and callable(tmp)):
            return tmp()
        else:
            return Reflect.field(o,field)

    @staticmethod
    def setProperty(o,field,value):
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if isinstance(o,_hx_AnonObject):
            setattr(o,field1,value)
        elif hasattr(o,("set_" + ("null" if field1 is None else field1))):
            getattr(o,("set_" + ("null" if field1 is None else field1)))(value)
        else:
            setattr(o,field1,value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def fields(o):
        return python_Boot.fields(o)

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def isClosure(v):
        return isinstance(v,python_internal_MethodClosure)

    @staticmethod
    def compareMethods(f1,f2):
        if HxOverrides.eq(f1,f2):
            return True
        if (isinstance(f1,python_internal_MethodClosure) and isinstance(f2,python_internal_MethodClosure)):
            m1 = f1
            m2 = f2
            if HxOverrides.eq(m1.obj,m2.obj):
                return (m1.func == m2.func)
            else:
                return False
        if ((not Reflect.isFunction(f1)) or (not Reflect.isFunction(f2))):
            return False
        return False

    @staticmethod
    def isObject(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 4):
            return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def deleteField(o,field):
        if (field in python_Boot.keywords):
            field = ("_hx_" + field)
        elif ((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95))):
            field = ("_hx_" + field)
        if (not python_Boot.hasField(o,field)):
            return False
        o.__delattr__(field)
        return True

    @staticmethod
    def copy(o):
        if (o is None):
            return None
        o2 = _hx_AnonObject({})
        _g = 0
        _g1 = python_Boot.fields(o)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(o,f)
            setattr(o2,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        return o2

    @staticmethod
    def makeVarArgs(f):
        def _hx_local_0(*v):
            this1 = v
            return f((list(this1) if ((not Std.isOfType(this1,list))) else this1))
        return _hx_local_0
_hx_classes["Reflect"] = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["downcast", "instance", "isMetaType", "is", "isOfType", "string", "int", "parseInt", "shortenPossibleNumber", "parseFloat", "random"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except BaseException as _g:
            None
            return None

    @staticmethod
    def instance(value,c):
        return Std.downcast(value,c)

    @staticmethod
    def isMetaType(v,t):
        return (v == t)

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def int(x):
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN

    @staticmethod
    def random(x):
        if (x <= 0):
            return 0
        else:
            return int((python_lib_Random.random() * x))
_hx_classes["Std"] = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length", "add", "add1", "addChar", "addSub", "toString"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    def add(self,x):
        s = Std.string(x)
        self.b.write(s)

    def add1(self,s):
        self.b.write(s)

    def addChar(self,c):
        s = "".join(map(chr,[c]))
        self.b.write(s)

    def addSub(self,s,pos,_hx_len = None):
        s1 = (HxString.substr(s,pos,None) if ((_hx_len is None)) else HxString.substr(s,pos,_hx_len))
        self.b.write(s1)

    def toString(self):
        return self.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
_hx_classes["StringBuf"] = StringBuf


class haxe_SysTools:
    _hx_class_name = "haxe.SysTools"
    __slots__ = ()
    _hx_statics = ["winMetaCharacters", "quoteUnixArg", "quoteWinArg"]

    @staticmethod
    def quoteUnixArg(argument):
        if (argument == ""):
            return "''"
        _this = EReg("[^a-zA-Z0-9_@%+=:,./-]","")
        _this.matchObj = python_lib_Re.search(_this.pattern,argument)
        if (_this.matchObj is None):
            return argument
        return (("'" + HxOverrides.stringOrNull(StringTools.replace(argument,"'","'\"'\"'"))) + "'")

    @staticmethod
    def quoteWinArg(argument,escapeMetaCharacters):
        _this = EReg("^[^ \t\\\\\"]+$","")
        _this.matchObj = python_lib_Re.search(_this.pattern,argument)
        if (_this.matchObj is None):
            result_b = python_lib_io_StringIO()
            needquote = None
            startIndex = None
            if (((argument.find(" ") if ((startIndex is None)) else HxString.indexOfImpl(argument," ",startIndex))) == -1):
                startIndex = None
                needquote = (((argument.find("\t") if ((startIndex is None)) else HxString.indexOfImpl(argument,"\t",startIndex))) != -1)
            else:
                needquote = True
            needquote1 = (needquote or ((argument == "")))
            if needquote1:
                result_b.write("\"")
            bs_buf = StringBuf()
            _g = 0
            _g1 = len(argument)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _g2 = HxString.charCodeAt(argument,i)
                if (_g2 is None):
                    c = _g2
                    if (bs_buf.get_length() > 0):
                        result_b.write(Std.string(bs_buf.b.getvalue()))
                        bs_buf = StringBuf()
                    result_b.write("".join(map(chr,[c])))
                else:
                    _g3 = _g2
                    if (_g3 == 34):
                        bs = bs_buf.b.getvalue()
                        result_b.write(Std.string(bs))
                        result_b.write(Std.string(bs))
                        bs_buf = StringBuf()
                        result_b.write("\\\"")
                    elif (_g3 == 92):
                        bs_buf.b.write("\\")
                    else:
                        c1 = _g2
                        if (bs_buf.get_length() > 0):
                            result_b.write(Std.string(bs_buf.b.getvalue()))
                            bs_buf = StringBuf()
                        result_b.write("".join(map(chr,[c1])))
            result_b.write(Std.string(bs_buf.b.getvalue()))
            if needquote1:
                result_b.write(Std.string(bs_buf.b.getvalue()))
                result_b.write("\"")
            argument = result_b.getvalue()
        if escapeMetaCharacters:
            result_b = python_lib_io_StringIO()
            _g = 0
            _g1 = len(argument)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = HxString.charCodeAt(argument,i)
                if (python_internal_ArrayImpl.indexOf(haxe_SysTools.winMetaCharacters,c,None) >= 0):
                    result_b.write("".join(map(chr,[94])))
                result_b.write("".join(map(chr,[c])))
            return result_b.getvalue()
        else:
            return argument
_hx_classes["haxe.SysTools"] = haxe_SysTools


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["urlEncode", "urlDecode", "htmlEscape", "htmlUnescape", "contains", "startsWith", "endsWith", "isSpace", "ltrim", "rtrim", "trim", "lpad", "rpad", "replace", "hex", "fastCodeAt", "iterator", "keyValueIterator", "isEof", "quoteUnixArg", "winMetaCharacters", "quoteWinArg"]

    @staticmethod
    def urlEncode(s):
        return python_lib_urllib_Parse.quote(s,"")

    @staticmethod
    def urlDecode(s):
        return python_lib_urllib_Parse.unquote(s)

    @staticmethod
    def htmlEscape(s,quotes = None):
        buf_b = python_lib_io_StringIO()
        _g_offset = 0
        _g_s = s
        while (_g_offset < len(_g_s)):
            s = _g_s
            index = _g_offset
            _g_offset = (_g_offset + 1)
            code = (-1 if ((index >= len(s))) else ord(s[index]))
            code1 = code
            if (code1 == 34):
                if quotes:
                    buf_b.write("&quot;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 38):
                buf_b.write("&amp;")
            elif (code1 == 39):
                if quotes:
                    buf_b.write("&#039;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 60):
                buf_b.write("&lt;")
            elif (code1 == 62):
                buf_b.write("&gt;")
            else:
                buf_b.write("".join(map(chr,[code])))
        return buf_b.getvalue()

    @staticmethod
    def htmlUnescape(s):
        _this = s.split("&gt;")
        _this1 = ">".join([python_Boot.toString1(x1,'') for x1 in _this])
        _this = _this1.split("&lt;")
        _this1 = "<".join([python_Boot.toString1(x1,'') for x1 in _this])
        _this = _this1.split("&quot;")
        _this1 = "\"".join([python_Boot.toString1(x1,'') for x1 in _this])
        _this = _this1.split("&#039;")
        _this1 = "'".join([python_Boot.toString1(x1,'') for x1 in _this])
        _this = _this1.split("&amp;")
        return "&".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def contains(s,value):
        startIndex = None
        return (((s.find(value) if ((startIndex is None)) else HxString.indexOfImpl(s,value,startIndex))) != -1)

    @staticmethod
    def startsWith(s,start):
        return s.startswith(start)

    @staticmethod
    def endsWith(s,end):
        return s.endswith(end)

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def rpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        s1 = Std.string(s)
        buf.b.write(s1)
        while (buf.get_length() < l):
            s = Std.string(c)
            buf.b.write(s)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s

    @staticmethod
    def fastCodeAt(s,index):
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    @staticmethod
    def iterator(s):
        return haxe_iterators_StringIterator(s)

    @staticmethod
    def keyValueIterator(s):
        return haxe_iterators_StringKeyValueIterator(s)

    @staticmethod
    def isEof(c):
        return (c == -1)

    @staticmethod
    def quoteUnixArg(argument):
        if (argument == ""):
            return "''"
        else:
            _this = EReg("[^a-zA-Z0-9_@%+=:,./-]","")
            _this.matchObj = python_lib_Re.search(_this.pattern,argument)
            if (_this.matchObj is None):
                return argument
            else:
                return (("'" + HxOverrides.stringOrNull(StringTools.replace(argument,"'","'\"'\"'"))) + "'")

    @staticmethod
    def quoteWinArg(argument,escapeMetaCharacters):
        argument1 = argument
        _this = EReg("^[^ \t\\\\\"]+$","")
        _this.matchObj = python_lib_Re.search(_this.pattern,argument1)
        if (_this.matchObj is None):
            result_b = python_lib_io_StringIO()
            needquote = None
            startIndex = None
            if (((argument1.find(" ") if ((startIndex is None)) else HxString.indexOfImpl(argument1," ",startIndex))) == -1):
                startIndex = None
                needquote = (((argument1.find("\t") if ((startIndex is None)) else HxString.indexOfImpl(argument1,"\t",startIndex))) != -1)
            else:
                needquote = True
            needquote1 = (needquote or ((argument1 == "")))
            if needquote1:
                result_b.write("\"")
            bs_buf = StringBuf()
            _g = 0
            _g1 = len(argument1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _g2 = HxString.charCodeAt(argument1,i)
                if (_g2 is None):
                    c = _g2
                    if (bs_buf.get_length() > 0):
                        result_b.write(Std.string(bs_buf.b.getvalue()))
                        bs_buf = StringBuf()
                    result_b.write("".join(map(chr,[c])))
                else:
                    _g3 = _g2
                    if (_g3 == 34):
                        bs = bs_buf.b.getvalue()
                        result_b.write(Std.string(bs))
                        result_b.write(Std.string(bs))
                        bs_buf = StringBuf()
                        result_b.write("\\\"")
                    elif (_g3 == 92):
                        bs_buf.b.write("\\")
                    else:
                        c1 = _g2
                        if (bs_buf.get_length() > 0):
                            result_b.write(Std.string(bs_buf.b.getvalue()))
                            bs_buf = StringBuf()
                        result_b.write("".join(map(chr,[c1])))
            result_b.write(Std.string(bs_buf.b.getvalue()))
            if needquote1:
                result_b.write(Std.string(bs_buf.b.getvalue()))
                result_b.write("\"")
            argument1 = result_b.getvalue()
        if escapeMetaCharacters:
            result_b = python_lib_io_StringIO()
            _g = 0
            _g1 = len(argument1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = HxString.charCodeAt(argument1,i)
                if (python_internal_ArrayImpl.indexOf(haxe_SysTools.winMetaCharacters,c,None) >= 0):
                    result_b.write("".join(map(chr,[94])))
                result_b.write("".join(map(chr,[c])))
            return result_b.getvalue()
        else:
            return argument1
_hx_classes["StringTools"] = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "stat", "rename", "fullPath", "absolutePath", "isDirectory", "createDirectory", "deleteFile", "deleteDirectory", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def stat(path):
        s = python_lib_Os.stat(path)
        return _hx_AnonObject({'gid': s.st_gid, 'uid': s.st_uid, 'atime': Date.fromTime((1000 * s.st_atime)), 'mtime': Date.fromTime((1000 * s.st_mtime)), 'ctime': Date.fromTime((1000 * s.st_ctime)), 'size': s.st_size, 'dev': s.st_dev, 'ino': s.st_ino, 'nlink': s.st_nlink, 'rdev': getattr(s,"st_rdev",0), 'mode': s.st_mode})

    @staticmethod
    def rename(path,newPath):
        python_lib_Os.rename(path,newPath)

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def absolutePath(relPath):
        if haxe_io_Path.isAbsolute(relPath):
            return relPath
        return haxe_io_Path.join([Sys.getCwd(), relPath])

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        python_lib_Os.remove(path)

    @staticmethod
    def deleteDirectory(path):
        python_lib_Os.rmdir(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)
_hx_classes["sys.FileSystem"] = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "set", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString", "clear"]
_hx_classes["haxe.IMap"] = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString", "clear"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def exists(self,key):
        return (key in self.h)

    def remove(self,key):
        has = (key in self.h)
        if has:
            del self.h[key]
        return has

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def copy(self):
        copied = haxe_ds_StringMap()
        key = self.keys()
        while key.hasNext():
            key1 = key.next()
            value = self.h.get(key1,None)
            copied.h[key1] = value
        return copied

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("}")
        return s_b.getvalue()

    def clear(self):
        self.h.clear()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
_hx_classes["haxe.ds.StringMap"] = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
_hx_classes["python.HaxeIterator"] = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "time", "exit", "print", "println", "args", "getEnv", "putEnv", "environment", "sleep", "setTimeLocale", "getCwd", "setCwd", "systemName", "command", "cpuTime", "executablePath", "_programPath", "programPath", "getChar", "stdin", "stdout", "stderr"]

    @staticmethod
    def time():
        return python_lib_Time.time()

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def print(v):
        python_Lib.printString(Std.string(v))

    @staticmethod
    def println(v):
        _hx_str = Std.string(v)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def putEnv(s,v):
        python_lib_Os.putenv(s,v)
        Sys.environ.h[s] = v

    @staticmethod
    def environment():
        return Sys.environ

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def setTimeLocale(loc):
        return False

    @staticmethod
    def getCwd():
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def cpuTime():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def executablePath():
        return python_internal_ArrayImpl._get(python_lib_Sys.argv, 0)

    @staticmethod
    def programPath():
        return Sys._programPath

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except BaseException as _g1:
                    None
                    e = haxe_Exception.caught(_g1).unwrap()
                    restore()
                    raise haxe_Exception.thrown(e)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except BaseException as _g1:
                    None
                    e = haxe_Exception.caught(_g1).unwrap()
                    restore()
                    raise haxe_Exception.thrown(e)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getwch(),0)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        else:
            x = _g
            raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        if echo:
            python_Lib.printString(Std.string("".join(map(chr,[ch]))))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)

    @staticmethod
    def stderr():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stderr)
_hx_classes["Sys"] = Sys


class TimingTests:
    _hx_class_name = "TimingTests"
    __slots__ = ("db", "query")
    _hx_fields = ["db", "query"]
    _hx_methods = ["run"]
    _hx_statics = ["log", "clear", "stressTestQueens", "stressTestOKeefeQueens", "stressTestZebra", "stressTest", "main", "queens_theory", "okeefe_queens_theory", "zebra_theory"]

    def __init__(self,theory):
        self.query = None
        self.db = blub_prolog_Database()
        self.db.loadString(theory,True)

    def run(self,predName):
        qterm = blub_prolog_terms_Structure(self.db.context.getAtom(predName),[blub_prolog_terms_Variable("Result")])
        self.query = blub_prolog_Query(self.db,qterm)
        solutions = []
        result = self.query
        while result.hasNext():
            result1 = result.next()
            if blub_prolog_ResultUtil.isSuccess(result1):
                x = blub_prolog_ResultUtil.getBindings(result1).h.get("Result",None)
                solutions.append(x)
        return solutions

    @staticmethod
    def log(v):
        haxe_Log.trace(v,_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 32, 'className': "TimingTests", 'methodName': "log"}))

    @staticmethod
    def clear():
        pass

    @staticmethod
    def stressTestQueens(count):
        haxe_Log.trace((("Running 8 Queens * " + Std.string(count)) + " ..."),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 47, 'className': "TimingTests", 'methodName': "stressTestQueens"}))
        solutions = TimingTests.stressTest(TimingTests.queens_theory,"run_queens",count)
        if (count == 1):
            haxe_Log.trace(("solution count = " + Std.string(len(solutions))),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 50, 'className': "TimingTests", 'methodName': "stressTestQueens"}))
            _g = 0
            while (_g < len(solutions)):
                solution = (solutions[_g] if _g >= 0 and _g < len(solutions) else None)
                _g = (_g + 1)
                haxe_Log.trace(solution.toString(),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 52, 'className': "TimingTests", 'methodName': "stressTestQueens"}))

    @staticmethod
    def stressTestOKeefeQueens(count):
        haxe_Log.trace((("Running O'Keefe 8 Queens * " + Std.string(count)) + " ..."),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 58, 'className': "TimingTests", 'methodName': "stressTestOKeefeQueens"}))
        solutions = TimingTests.stressTest(TimingTests.okeefe_queens_theory,"run_queens",count)
        if (count == 1):
            haxe_Log.trace(("solution count = " + Std.string(len(solutions))),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 61, 'className': "TimingTests", 'methodName': "stressTestOKeefeQueens"}))
            _g = 0
            while (_g < len(solutions)):
                solution = (solutions[_g] if _g >= 0 and _g < len(solutions) else None)
                _g = (_g + 1)
                haxe_Log.trace(solution.toString(),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 63, 'className': "TimingTests", 'methodName': "stressTestOKeefeQueens"}))

    @staticmethod
    def stressTestZebra(count):
        haxe_Log.trace((("Running Zebra * " + Std.string(count)) + " ..."),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 69, 'className': "TimingTests", 'methodName': "stressTestZebra"}))
        TimingTests.stressTest(TimingTests.zebra_theory,"zebra",count)

    @staticmethod
    def stressTest(theory,predName,count):
        test = TimingTests(theory)
        time = 0.0
        solutions = []
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            timestamp = python_lib_Timeit.default_timer()
            solutions = test.run(predName)
            time = (time + ((python_lib_Timeit.default_timer() - timestamp)))
        haxe_Log.trace(("Average time = " + Std.string(((time / count)))),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 85, 'className': "TimingTests", 'methodName': "stressTest"}))
        return solutions

    @staticmethod
    def main():
        def _hx_local_2():
            haxe_Log.trace("Starting....",_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 118, 'className': "TimingTests", 'methodName': "main"}))
            zebra = TimingTests(TimingTests.zebra_theory)
            timestamp = python_lib_Timeit.default_timer()
            solutions = zebra.run("zebra")
            haxe_Log.trace((("Zebra in " + Std.string(((python_lib_Timeit.default_timer() - timestamp)))) + " seconds"),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 122, 'className': "TimingTests", 'methodName': "main"}))
            haxe_Log.trace(("solution count = " + Std.string(len(solutions))),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 123, 'className': "TimingTests", 'methodName': "main"}))
            _g = 0
            while (_g < len(solutions)):
                solution = (solutions[_g] if _g >= 0 and _g < len(solutions) else None)
                _g = (_g + 1)
                haxe_Log.trace(solution.toString(),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 125, 'className': "TimingTests", 'methodName': "main"}))
            TimingTests.stressTestOKeefeQueens(10)
            queens = TimingTests(TimingTests.queens_theory)
            timestamp = python_lib_Timeit.default_timer()
            solutions = queens.run("run_queens")
            haxe_Log.trace((("8 queens in " + Std.string(((python_lib_Timeit.default_timer() - timestamp)))) + " seconds"),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 134, 'className': "TimingTests", 'methodName': "main"}))
            haxe_Log.trace(("solution count = " + Std.string(len(solutions))),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 135, 'className': "TimingTests", 'methodName': "main"}))
            _g = 0
            while (_g < len(solutions)):
                solution = (solutions[_g] if _g >= 0 and _g < len(solutions) else None)
                _g = (_g + 1)
                haxe_Log.trace(solution.toString(),_hx_AnonObject({'fileName': "src/TimingTests.hx", 'lineNumber': 140, 'className': "TimingTests", 'methodName': "main"}))
        haxe_Timer.delay(_hx_local_2,500)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.db = None
        _hx_o.query = None
_hx_classes["TimingTests"] = TimingTests

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
_hx_classes["ValueType"] = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getEnum", "getSuperClass", "getClassName", "getEnumName", "resolveClass", "resolveEnum", "createInstance", "createEmptyInstance", "createEnum", "createEnumIndex", "getInstanceFields", "getClassFields", "getEnumConstructs", "typeof", "asEnumImpl", "enumEq", "enumConstructor", "enumParameters", "enumIndex", "allEnums"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getEnum(o):
        if (o is None):
            return None
        return o.__class__

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None

    @staticmethod
    def getEnumName(e):
        return e._hx_class_name

    @staticmethod
    def resolveClass(name):
        if (name == "Array"):
            return list
        if (name == "Math"):
            return Math
        if (name == "String"):
            return str
        cl = _hx_classes.get(name,None)
        tmp = None
        if (cl is not None):
            o = cl
            tmp = (not (((o is not None) and ((HxOverrides.eq(o,str) or python_lib_Inspect.isclass(o))))))
        else:
            tmp = True
        if tmp:
            return None
        return cl

    @staticmethod
    def resolveEnum(name):
        if (name == "Bool"):
            return Bool
        o = Type.resolveClass(name)
        if hasattr(o,"_hx_constructs"):
            return o
        else:
            return None

    @staticmethod
    def createInstance(cl,args):
        return cl(*args)

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def createEnum(e,constr,params = None):
        f = Reflect.field(e,constr)
        if (f is None):
            raise haxe_Exception.thrown(("No such constructor " + ("null" if constr is None else constr)))
        if Reflect.isFunction(f):
            if (params is None):
                raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " need parameters"))
            return Reflect.callMethod(e,f,params)
        if ((params is not None) and ((len(params) != 0))):
            raise haxe_Exception.thrown((("Constructor " + ("null" if constr is None else constr)) + " does not need parameters"))
        return f

    @staticmethod
    def createEnumIndex(e,index,params = None):
        c = python_internal_ArrayImpl._get(e._hx_constructs, index)
        if (c is None):
            raise haxe_Exception.thrown((Std.string(index) + " is not a valid enum constructor index"))
        return Type.createEnum(e,c,params)

    @staticmethod
    def getInstanceFields(c):
        return python_Boot.getInstanceFields(c)

    @staticmethod
    def getClassFields(c):
        return python_Boot.getClassFields(c)

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def asEnumImpl(x):
        return x

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except BaseException as _g:
            None
            return False
        return True

    @staticmethod
    def enumConstructor(e):
        return e.tag

    @staticmethod
    def enumParameters(e):
        return list(e.params)

    @staticmethod
    def enumIndex(e):
        return e.index

    @staticmethod
    def allEnums(e):
        ctors = Type.getEnumConstructs(e)
        ret = []
        _g = 0
        while (_g < len(ctors)):
            ctor = (ctors[_g] if _g >= 0 and _g < len(ctors) else None)
            _g = (_g + 1)
            v = Reflect.field(e,ctor)
            if Std.isOfType(v,e):
                ret.append(v)
        return ret
_hx_classes["Type"] = Type


class haxe_ds__Map_Map_Impl_:
    _hx_class_name = "haxe.ds._Map.Map_Impl_"
    __slots__ = ()
    _hx_statics = ["set", "get", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString", "clear", "arrayWrite", "toStringMap", "toIntMap", "toEnumValueMapMap", "toObjectMap", "fromStringMap", "fromIntMap", "fromObjectMap"]

    @staticmethod
    def set(this1,key,value):
        this1.set(key,value)

    @staticmethod
    def get(this1,key):
        return this1.get(key)

    @staticmethod
    def exists(this1,key):
        return this1.exists(key)

    @staticmethod
    def remove(this1,key):
        return this1.remove(key)

    @staticmethod
    def keys(this1):
        return this1.keys()

    @staticmethod
    def iterator(this1):
        return this1.iterator()

    @staticmethod
    def keyValueIterator(this1):
        return this1.keyValueIterator()

    @staticmethod
    def copy(this1):
        return this1.copy()

    @staticmethod
    def toString(this1):
        return this1.toString()

    @staticmethod
    def clear(this1):
        this1.clear()

    @staticmethod
    def arrayWrite(this1,k,v):
        this1.set(k,v)
        return v

    @staticmethod
    def toStringMap(t):
        return haxe_ds_StringMap()

    @staticmethod
    def toIntMap(t):
        return haxe_ds_IntMap()

    @staticmethod
    def toEnumValueMapMap(t):
        return haxe_ds_EnumValueMap()

    @staticmethod
    def toObjectMap(t):
        return haxe_ds_ObjectMap()

    @staticmethod
    def fromStringMap(_hx_map):
        return _hx_map

    @staticmethod
    def fromIntMap(_hx_map):
        return _hx_map

    @staticmethod
    def fromObjectMap(_hx_map):
        return _hx_map
_hx_classes["haxe.ds._Map.Map_Impl_"] = haxe_ds__Map_Map_Impl_


class blub_prolog_AtomContext:
    _hx_class_name = "blub.prolog.AtomContext"
    __slots__ = ("atoms",)
    _hx_fields = ["atoms"]
    _hx_methods = ["getAtom", "lookupAtom", "createAtom"]
    _hx_statics = ["GLOBALS"]

    def __init__(self):
        self.atoms = haxe_ds_StringMap()

    def getAtom(self,text):
        atom = self.lookupAtom(text)
        if (atom is None):
            atom = self.createAtom(text)
            self.atoms.h[text] = atom
        return atom

    def lookupAtom(self,text,checkGlobals = None):
        if (checkGlobals is None):
            checkGlobals = True
        atom = self.atoms.h.get(text,None)
        if (((atom is None) and checkGlobals) and ((self != blub_prolog_AtomContext.GLOBALS))):
            return blub_prolog_AtomContext.GLOBALS.lookupAtom(text,False)
        return atom

    def createAtom(self,text):
        return blub_prolog_terms_Atom.unregisteredAtom(text)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.atoms = None
_hx_classes["blub.prolog.AtomContext"] = blub_prolog_AtomContext


class blub_prolog_Clause:
    _hx_class_name = "blub.prolog.Clause"
    __slots__ = ("predicate", "listeners", "code", "term", "variableContext", "head", "body")
    _hx_fields = ["predicate", "listeners", "code", "term", "variableContext", "head", "body"]
    _hx_methods = ["possibleMatch", "headArg", "retract", "isRetracted", "compile", "setCode"]

    def __init__(self,predicate,clause):
        self.code = None
        self.predicate = predicate
        self.term = clause
        self.listeners = blub_prolog_Listeners()
        def _hx_local_3():
            def _hx_local_1():
                _hx_local_0 = clause
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_Structure) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            return (_hx_local_1()).get_variableContext() if Std.isOfType(clause,blub_prolog_terms_Structure) else blub_prolog_terms_VariableContext.EMPTY
        self.variableContext = _hx_local_3()
        self.head = clause.getHead()
        self.body = clause.getBody()

    def possibleMatch(self,args):
        headStruct = self.head.asStructure()
        arity = headStruct.getArity()
        _g = 0
        _g1 = arity
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (not headStruct.argAt(i).couldMatch((args[i] if i >= 0 and i < len(args) else None))):
                return False
        return True

    def headArg(self,index):
        if Std.isOfType(self.head,blub_prolog_terms_Structure):
            def _hx_local_2():
                def _hx_local_1():
                    _hx_local_0 = self.head
                    if (Std.isOfType(_hx_local_0,blub_prolog_terms_Structure) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                return (_hx_local_1()).argAt(index)
            return _hx_local_2()
        return None

    def retract(self):
        self.predicate.retractClause(self)

    def isRetracted(self):
        lis = self.listeners.iterator()
        while lis.hasNext():
            lis1 = lis.next()
            lis1.clauseRetracted(self)

    def compile(self):
        self.code = blub_prolog_compiler_ClauseCompiler(self.predicate.database).compile(self)

    def setCode(self,code):
        self.code = code

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.predicate = None
        _hx_o.listeners = None
        _hx_o.code = None
        _hx_o.term = None
        _hx_o.variableContext = None
        _hx_o.head = None
        _hx_o.body = None
_hx_classes["blub.prolog.Clause"] = blub_prolog_Clause


class blub_prolog_Database:
    _hx_class_name = "blub.prolog.Database"
    __slots__ = ("operators", "context", "listeners", "preprocessor", "predicates", "lazyPredicates", "compileQueue", "globals")
    _hx_fields = ["operators", "context", "listeners", "preprocessor", "predicates", "lazyPredicates", "compileQueue", "globals"]
    _hx_methods = ["setGlobal", "getGlobal", "addPredicate", "addPredicateSrc", "lookup", "compile", "assertA", "assertZ", "assert", "abolish", "loadString", "loadTerm", "declareDynamic", "processDirective", "listing", "query"]

    def __init__(self,context = None,operators = None):
        self.globals = None
        self.compileQueue = None
        self.lazyPredicates = None
        self.preprocessor = None
        self.context = (context if ((context is not None)) else blub_prolog_AtomContext())
        self.predicates = haxe_ds_StringMap()
        self.listeners = blub_prolog_Listeners()
        if (operators is None):
            operators = blub_prolog_stopgap_parse_Operators()
            operators.addStandardOps()
        self.operators = operators
        blub_prolog_builtins_Builtins.register(self)
        self.globals = haxe_ds_StringMap()

    def setGlobal(self,key,value):
        atom = blub_prolog_terms_Atom.unregisteredAtom(key)
        atom.object = value
        self.globals.h[key] = atom

    def getGlobal(self,key):
        atom = self.globals.h.get(key,None)
        if ((atom is None) or ((atom.asAtom() is None))):
            return None
        return atom.asAtom().object

    def addPredicate(self,indicator,isDynamic = None):
        if (isDynamic is None):
            isDynamic = False
        pred = blub_prolog_Predicate(self,indicator,isDynamic)
        this1 = self.predicates
        key = indicator.toString()
        this1.h[key] = pred
        lis = self.listeners.iterator()
        while lis.hasNext():
            lis1 = lis.next()
            lis1.predicateAdded(pred)
        return pred

    def addPredicateSrc(self,functor,src,filename = None):
        if (filename is None):
            filename = "lazy-load"
        parser = blub_prolog_stopgap_parse_Parser(self.context,self.operators,src,filename)
        pred = None
        while True:
            t = parser.nextTerm()
            if (t is None):
                break
            if Std.isOfType(t,blub_prolog_terms_ClauseTerm):
                def _hx_local_1():
                    _hx_local_0 = t
                    if (Std.isOfType(_hx_local_0,blub_prolog_terms_ClauseTerm) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                clause = _hx_local_1()
                if (pred is None):
                    head = clause.getHead()
                    pred = self.addPredicate(head.getIndicator(),False)
                pred.appendClause(clause)
                continue
            else:
                raise haxe_Exception.thrown(blub_prolog_PrologError(("Invalid top-level clause: " + Std.string(t))))
        if ((self.compileQueue is not None) and ((pred is not None))):
            self.compileQueue.add(pred)
        return pred

    def lookup(self,indicator):
        this1 = self.predicates
        key = indicator.toString()
        pred = this1.h.get(key,None)
        if ((pred is None) and ((self.compileQueue is not None))):
            if (self.lazyPredicates is None):
                self.lazyPredicates = blub_prolog_builtins_lazy_LazyLoadPredicates(self)
            if self.lazyPredicates.load(indicator):
                this1 = self.predicates
                key = indicator.toString()
                pred = this1.h.get(key,None)
        return pred

    def compile(self):
        self.compileQueue = haxe_ds_List()
        pred = self.predicates.iterator()
        while pred.hasNext():
            pred1 = pred.next()
            self.compileQueue.add(pred1)
        while (not self.compileQueue.isEmpty()):
            pred = self.compileQueue.pop()
            pred.compile()
        self.compileQueue = None

    def assertA(self,term,isQuery = None):
        if (isQuery is None):
            isQuery = False
        self._hx_assert(term,True,isQuery)

    def assertZ(self,term,isQuery = None):
        if (isQuery is None):
            isQuery = False
        self._hx_assert(term,False,isQuery)

    def _hx_assert(self,clause,atFront,isQuery):
        head = clause.getHead()
        indic = head.getIndicator()
        pred = self.lookup(indic)
        if (pred is None):
            pred = self.addPredicate(indic,isQuery)
        elif (isQuery and (not pred.isDynamic)):
            raise haxe_Exception.thrown(blub_prolog_PrologError(("Cannot assert clauses to a non-dynamic predicate: " + Std.string(indic))))
        c = (pred.prependClause(clause) if atFront else pred.appendClause(clause))
        if isQuery:
            c.compile()

    def abolish(self,indicator):
        this1 = self.predicates
        key = indicator.toString()
        pred = this1.h.get(key,None)
        if (pred is not None):
            self.predicates.remove(indicator.toString())
            pred.isAbolished()
            lis = self.listeners.iterator()
            while lis.hasNext():
                lis1 = lis.next()
                lis1.predicateAbolished(pred)

    def loadString(self,source,compileAll = None,filename = None,preprocessor = None):
        if (compileAll is None):
            compileAll = True
        if (filename is None):
            filename = "<unknown>"
        parser = blub_prolog_stopgap_parse_Parser(self.context,self.operators,source,filename)
        if (preprocessor is None):
            preprocessor = self.preprocessor
        if (preprocessor is None):
            self.preprocessor = blub_prolog_Preprocessor.getAStandardPreprocessor()
            preprocessor = self.preprocessor
        while True:
            t = parser.nextTerm()
            if (t is None):
                break
            stru = t.asStructure()
            if ((((stru is not None) and ((stru.getNameText() == ":-"))) and ((stru.getArity() == 1))) and ((stru.argAt(0).asStructure() is not None))):
                directive = stru.argAt(0).asStructure()
                if ((directive.getNameText() == "op") and ((directive.getArity() == 3))):
                    self.processDirective(stru.argAt(0).asStructure())
                    continue
            terms = preprocessor.process(self,t)
            _g = 0
            while (_g < len(terms)):
                t1 = (terms[_g] if _g >= 0 and _g < len(terms) else None)
                _g = (_g + 1)
                self.loadTerm(t1)
        if compileAll:
            self.compile()

    def loadTerm(self,t):
        stru = t.asStructure()
        if ((((stru is not None) and ((stru.getNameText() == ":-"))) and ((stru.getArity() == 1))) and ((stru.argAt(0).asStructure() is not None))):
            self.processDirective(stru.argAt(0).asStructure())
            return
        if Std.isOfType(t,blub_prolog_terms_ClauseTerm):
            ct = t
            self.assertZ(ct)
            return
        raise haxe_Exception.thrown(blub_prolog_PrologError(("Invalid top-level clause: " + Std.string(t))))

    def declareDynamic(self,indicator):
        pred = self.lookup(indicator)
        if (pred is None):
            pred = self.addPredicate(indicator,True)
        else:
            raise haxe_Exception.thrown(blub_prolog_PrologError(("cannot declare existing predicate to be dynamic: " + Std.string(indicator))))

    def processDirective(self,directive):
        text = directive.getNameText()
        if (text == "op"):
            op = directive
            if (op.getArity() != 3):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("op/3 directive requires 3 args: " + Std.string(op))))
            def _hx_local_1():
                _hx_local_0 = op.argAt(0)
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_NumberTerm) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            priority = _hx_local_1()
            if (priority is None):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("op/3 directive requires numeric priority as first arg: " + Std.string(op))))
            if ((priority.value < 0) or ((priority.value > 1200))):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("op/3 directive requires numeric priority from 0 to 1200: " + Std.string(op))))
            x = priority.value
            tmp = None
            try:
                tmp = int(x)
            except BaseException as _g:
                None
                tmp = None
            if (tmp != priority.value):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("op/3 directive requires integer priority: " + Std.string(op))))
            if (not Std.isOfType(op.argAt(1),blub_prolog_terms_Atom)):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("op/3 directive requires spec as 2nd arg: " + Std.string(op))))
            if (not Std.isOfType(op.argAt(2),blub_prolog_terms_Atom)):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("op/3 directive requires operator as 3rd arg: " + Std.string(op))))
            tmp = self.operators
            def _hx_local_3():
                _hx_local_2 = op.argAt(2)
                if (Std.isOfType(_hx_local_2,blub_prolog_terms_Atom) or ((_hx_local_2 is None))):
                    _hx_local_2
                else:
                    raise "Class cast error"
                return _hx_local_2
            tmp1 = (_hx_local_3()).text
            def _hx_local_5():
                _hx_local_4 = op.argAt(1)
                if (Std.isOfType(_hx_local_4,blub_prolog_terms_Atom) or ((_hx_local_4 is None))):
                    _hx_local_4
                else:
                    raise "Class cast error"
                return _hx_local_4
            tmp2 = blub_prolog_stopgap_parse_Operator.opSpec((_hx_local_5()).text)
            x = priority.value
            tmp3 = None
            try:
                tmp3 = int(x)
            except BaseException as _g:
                None
                tmp3 = None
            tmp.newOp(tmp1,tmp2,tmp3,self.context)
            return
        elif (text == "dynamic"):
            preds = directive.argAt(0).asStructure()
            if (preds is None):
                raise haxe_Exception.thrown(blub_prolog_PrologError(("dynamic/1 directive requires one or more predicate specs: " + Std.string(directive))))
            specs = preds.commaList()
            _g = 0
            while (_g < len(specs)):
                spec = (specs[_g] if _g >= 0 and _g < len(specs) else None)
                _g = (_g + 1)
                indic = blub_prolog_PredicateIndicator.fromTerm(spec)
                self.declareDynamic(indic)

    def listing(self,logger):
        pred = self.predicates.iterator()
        while pred.hasNext():
            pred1 = pred.next()
            if (not pred1.isBuiltin):
                pred1.listing(logger)

    def query(self,term):
        t = blub_prolog_terms_TermParse.parse(term,self.context,self.operators)
        if (not Std.isOfType(t,blub_prolog_terms_ClauseTerm)):
            raise haxe_Exception.thrown(blub_prolog_PrologError(("Query is not a valid atom or structure: " + ("null" if term is None else term))))
        def _hx_local_2():
            def _hx_local_1():
                _hx_local_0 = t
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_ClauseTerm) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            return blub_prolog_Query(self,_hx_local_1())
        return _hx_local_2()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.operators = None
        _hx_o.context = None
        _hx_o.listeners = None
        _hx_o.preprocessor = None
        _hx_o.predicates = None
        _hx_o.lazyPredicates = None
        _hx_o.compileQueue = None
        _hx_o.globals = None
_hx_classes["blub.prolog.Database"] = blub_prolog_Database


class blub_prolog_Listeners:
    _hx_class_name = "blub.prolog.Listeners"
    __slots__ = ("listeners",)
    _hx_fields = ["listeners"]
    _hx_methods = ["add", "remove", "iterator"]

    def __init__(self):
        self.listeners = list()

    def add(self,listener):
        _this = self.listeners
        _this.append(listener)

    def remove(self,listener):
        python_internal_ArrayImpl.remove(self.listeners,listener)

    def iterator(self):
        return haxe_iterators_ArrayIterator(self.listeners)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.listeners = None
_hx_classes["blub.prolog.Listeners"] = blub_prolog_Listeners


class blub_prolog_PredicateListener:
    _hx_class_name = "blub.prolog.PredicateListener"
    __slots__ = ()
    _hx_methods = ["predicateAdded", "predicateAbolished"]
_hx_classes["blub.prolog.PredicateListener"] = blub_prolog_PredicateListener


class blub_prolog_AssertionListener:
    _hx_class_name = "blub.prolog.AssertionListener"
    __slots__ = ()
    _hx_methods = ["clauseAsserted"]
_hx_classes["blub.prolog.AssertionListener"] = blub_prolog_AssertionListener


class blub_prolog_RetractionListener:
    _hx_class_name = "blub.prolog.RetractionListener"
    __slots__ = ()
    _hx_methods = ["clauseRetracted"]
_hx_classes["blub.prolog.RetractionListener"] = blub_prolog_RetractionListener


class blub_prolog_Marshal:
    _hx_class_name = "blub.prolog.Marshal"
    __slots__ = ()
    _hx_statics = ["object_atom_id", "newAtom", "valueToTerm", "termToValue"]

    @staticmethod
    def newAtom():
        def _hx_local_2():
            _hx_local_0 = blub_prolog_Marshal
            _hx_local_1 = _hx_local_0.object_atom_id
            _hx_local_0.object_atom_id = (_hx_local_1 + 1)
            return _hx_local_1
        tmp = ("object#" + Std.string(_hx_local_2()))
        return blub_prolog_terms_Atom.unregisteredAtom(tmp)

    @staticmethod
    def valueToTerm(value):
        if (value is None):
            return blub_prolog_AtomContext.GLOBALS.getAtom("null")
        if Std.isOfType(value,blub_prolog_terms_Term):
            def _hx_local_1():
                _hx_local_0 = value
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_Term) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            t = _hx_local_1()
            vt = t.asValueTerm()
            if (vt is not None):
                return vt.dereference()
        if Std.isOfType(value,Bool):
            b = value
            if b:
                return blub_prolog_AtomContext.GLOBALS.getAtom("true")
            else:
                return blub_prolog_AtomContext.GLOBALS.getAtom("false")
        if Std.isOfType(value,Float):
            return blub_prolog_terms_NumberTerm(value)
        if Std.isOfType(value,list):
            array = value
            terms = list()
            _g = 0
            while (_g < len(array)):
                el = (array[_g] if _g >= 0 and _g < len(array) else None)
                _g = (_g + 1)
                x = blub_prolog_Marshal.valueToTerm(el)
                terms.append(x)
            return blub_prolog_terms_Structure.makeList(terms)
        if Std.isOfType(value,haxe_ds_StringMap):
            hashAtom = blub_prolog_Marshal.newAtom()
            hash = value
            hashAtom.object = blub_prolog_builtins_objects_HashObjectWrapper(hashAtom,hash)
            return hashAtom
        atom = (blub_prolog_terms_Atom.unregisteredAtom(value) if (Std.isOfType(value,str)) else blub_prolog_Marshal.newAtom())
        atom.object = None
        return atom

    @staticmethod
    def termToValue(term):
        if (term is None):
            return None
        atom = term.asAtom()
        if (atom is not None):
            if (atom.object is not None):
                object = atom.object
                if Std.isOfType(object,blub_prolog_builtins_objects_ObjectWrapper):
                    wrapper = object
                    return wrapper.getObject()
                return object
            _g = atom.text
            _hx_local_0 = len(_g)
            if (_hx_local_0 == 5):
                if (_g == "false"):
                    return False
                else:
                    return atom.text
            elif (_hx_local_0 == 4):
                if (_g == "null"):
                    return None
                elif (_g == "true"):
                    return True
                else:
                    return atom.text
            else:
                return atom.text
        num = term.asNumber()
        if (num is not None):
            return num.value
        struc = term.asStructure()
        if (struc is not None):
            if ((struc.getArity() == 1) and ((struc.getNameText() == "term"))):
                return struc.argAt(0)
            array = struc.toArray()
            if (array is None):
                return struc.toString()
            resultArray = list()
            _g = 0
            while (_g < len(array)):
                t = (array[_g] if _g >= 0 and _g < len(array) else None)
                _g = (_g + 1)
                x = blub_prolog_Marshal.termToValue(t.asValueTerm())
                resultArray.append(x)
            return resultArray
        term = term.dereference()
        if (term.asReference() is not None):
            return None
        return blub_prolog_Marshal.termToValue(term)
_hx_classes["blub.prolog.Marshal"] = blub_prolog_Marshal


class blub_prolog_PredicateIndicator:
    _hx_class_name = "blub.prolog.PredicateIndicator"
    __slots__ = ("name", "arity", "term", "_string", "_term")
    _hx_fields = ["name", "arity", "_string", "_term"]
    _hx_methods = ["toString", "get_term"]
    _hx_statics = ["SLASH", "fromString", "fromTerm"]

    def __init__(self,name,arity):
        self._term = None
        self._string = None
        self.term = None
        self.name = name
        self.arity = arity

    def toString(self):
        if (self._string is None):
            self._string = ((HxOverrides.stringOrNull(self.name.text) + "/") + Std.string(self.arity))
        return self._string

    def get_term(self):
        if (self._term is None):
            self._term = blub_prolog_terms_Structure(blub_prolog_PredicateIndicator.SLASH,[self.name, blub_prolog_terms_NumberTerm(self.arity)])
        return self._term

    @staticmethod
    def fromString(text,context = None):
        startIndex = None
        slash = None
        if (startIndex is None):
            slash = text.rfind("/", 0, len(text))
        else:
            i = text.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = text.find("/", startLeft, len(text))
            slash = (check if (((check > i) and ((check <= startIndex)))) else i)
        atom = text
        arity = 0
        if (slash >= 0):
            atom = HxString.substr(text,0,slash)
            arity = Std.parseInt(HxString.substr(text,(slash + 1),None))
        return blub_prolog_PredicateIndicator(((context if ((context is not None)) else blub_prolog_AtomContext.GLOBALS)).getAtom(atom),arity)

    @staticmethod
    def fromTerm(term,clauseContext = None):
        structure = term.asStructure()
        if (((((structure is None) or ((structure.getArity() != 2))) or (not structure.getName().equals(blub_prolog_PredicateIndicator.SLASH))) or ((structure.argAt(0).asAtom() is None))) or ((structure.argAt(1).asNumber() is None))):
            raise haxe_Exception.thrown(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_predicate_indicator,term,clauseContext))
        tmp = structure.argAt(0).asAtom()
        x = structure.argAt(1).asNumber().value
        tmp1 = None
        try:
            tmp1 = int(x)
        except BaseException as _g:
            None
            tmp1 = None
        return blub_prolog_PredicateIndicator(tmp,tmp1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.arity = None
        _hx_o._string = None
        _hx_o._term = None
_hx_classes["blub.prolog.PredicateIndicator"] = blub_prolog_PredicateIndicator


class blub_prolog_Predicate:
    _hx_class_name = "blub.prolog.Predicate"
    __slots__ = ("database", "isDynamic", "isBuiltin", "indicator", "listeners", "builtin", "code", "clauseList")
    _hx_fields = ["database", "isDynamic", "isBuiltin", "indicator", "listeners", "builtin", "code", "clauseList"]
    _hx_methods = ["findMatchingClauses", "appendClause", "prependClause", "retractClause", "clauseAt", "clauseCount", "clauses", "compile", "toString", "setBuiltin", "abolish", "isAbolished", "listing"]

    def __init__(self,database,indicator,isDynamic):
        self.code = None
        self.builtin = None
        self.database = database
        self.indicator = indicator
        self.isDynamic = isDynamic
        self.isBuiltin = False
        self.listeners = blub_prolog_Listeners()
        self.clauseList = list()

    def findMatchingClauses(self,args):
        if (self.indicator.arity == 0):
            return self.clauseList
        result = list()
        _g = 0
        _g1 = self.clauseList
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.possibleMatch(args):
                result.append(c)
        return result

    def appendClause(self,clause):
        if self.isBuiltin:
            raise haxe_Exception.thrown(("cannot add clauses to a built-in predicate: " + HxOverrides.stringOrNull(self.indicator.toString())))
        c = blub_prolog_Clause(self,clause)
        _this = self.clauseList
        _this.append(c)
        lis = self.listeners.iterator()
        while lis.hasNext():
            lis1 = lis.next()
            lis1.clauseAsserted(c,False)
        return c

    def prependClause(self,clause):
        if self.isBuiltin:
            raise haxe_Exception.thrown(("cannot add clauses to a built-in predicate: " + HxOverrides.stringOrNull(self.indicator.toString())))
        c = blub_prolog_Clause(self,clause)
        self.clauseList.insert(0, c)
        lis = self.listeners.iterator()
        while lis.hasNext():
            lis1 = lis.next()
            lis1.clauseAsserted(c,True)
        return c

    def retractClause(self,clause):
        python_internal_ArrayImpl.remove(self.clauseList,clause)
        clause.isRetracted()

    def clauseAt(self,index):
        return (self.clauseList[index] if index >= 0 and index < len(self.clauseList) else None)

    def clauseCount(self):
        return len(self.clauseList)

    def clauses(self):
        return haxe_iterators_ArrayIterator(self.clauseList)

    def compile(self):
        if self.isBuiltin:
            return
        _g = 0
        _g1 = self.clauseList
        while (_g < len(_g1)):
            clause = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            clause.compile()
        self.code = blub_prolog_compiler_PredicateCompiler(self.database).compile(self)

    def toString(self):
        return self.indicator.toString()

    def setBuiltin(self,builtin):
        self.builtin = builtin
        self.isBuiltin = True

    def abolish(self):
        self.database.abolish(self.indicator)

    def isAbolished(self):
        _g = 0
        _g1 = self.clauseList
        while (_g < len(_g1)):
            clause = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            clause.isRetracted()

    def listing(self,logger):
        _g = 0
        _g1 = self.clauseList
        while (_g < len(_g1)):
            clause = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            logger(clause.term.toString())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.database = None
        _hx_o.isDynamic = None
        _hx_o.isBuiltin = None
        _hx_o.indicator = None
        _hx_o.listeners = None
        _hx_o.builtin = None
        _hx_o.code = None
        _hx_o.clauseList = None
_hx_classes["blub.prolog.Predicate"] = blub_prolog_Predicate


class blub_prolog_Preprocessor:
    _hx_class_name = "blub.prolog.Preprocessor"
    __slots__ = ("macroDatabase", "preprocessorPredicates")
    _hx_fields = ["macroDatabase", "preprocessorPredicates"]
    _hx_methods = ["loadStandardTheories", "getPreprocessorNames", "process", "callPreprocessor"]
    _hx_statics = ["THEORIES", "nullPreprocessor", "getAStandardPreprocessor", "getNullPreprocessor"]

    def __init__(self,macroDatabase):
        self.preprocessorPredicates = None
        self.macroDatabase = macroDatabase

    def loadStandardTheories(self):
        _g = 0
        _g1 = blub_prolog_Preprocessor.THEORIES
        while (_g < len(_g1)):
            theory = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            source = haxe_Resource.getString(theory)
            self.macroDatabase.loadString(source,True,theory,blub_prolog_Preprocessor.getNullPreprocessor())

    def getPreprocessorNames(self):
        if (self.preprocessorPredicates is None):
            preprocAtom = self.macroDatabase.context.getAtom("preprocessor")
            self.preprocessorPredicates = []
            if (self.macroDatabase.lookup(blub_prolog_PredicateIndicator(preprocAtom,1)) is None):
                return self.preprocessorPredicates
            nameVar = "Name"
            query = blub_prolog_Query(self.macroDatabase,blub_prolog_terms_Structure.make(preprocAtom,blub_prolog_terms_Variable(nameVar)))
            bindings = query.allBindings()
            if (bindings is not None):
                _g = 0
                while (_g < len(bindings)):
                    binding = (bindings[_g] if _g >= 0 and _g < len(bindings) else None)
                    _g = (_g + 1)
                    name = binding.h.get(nameVar,None).asAtom()
                    if (name is not None):
                        _this = self.preprocessorPredicates
                        x = name.text
                        _this.append(x)
        return self.preprocessorPredicates

    def process(self,db,clause):
        if (self.macroDatabase is None):
            return [clause]
        procNames = self.getPreprocessorNames()
        if (len(procNames) == 0):
            return [clause]
        dbWrapper = blub_prolog_Marshal.valueToTerm(db)
        if (clause.asStructure() is not None):
            clause = clause.asStructure().varsToReferences()
        termQ = [clause]
        _g = 0
        while (_g < len(procNames)):
            procName = (procNames[_g] if _g >= 0 and _g < len(procNames) else None)
            _g = (_g + 1)
            outQ = []
            _g1 = 0
            while (_g1 < len(termQ)):
                c = (termQ[_g1] if _g1 >= 0 and _g1 < len(termQ) else None)
                _g1 = (_g1 + 1)
                clausesOut = self.callPreprocessor(procName,dbWrapper,c)
                _g2 = 0
                while (_g2 < len(clausesOut)):
                    out = (clausesOut[_g2] if _g2 >= 0 and _g2 < len(clausesOut) else None)
                    _g2 = (_g2 + 1)
                    outQ.append(out)
            termQ = outQ
        results = []
        _g = 0
        while (_g < len(termQ)):
            t = (termQ[_g] if _g >= 0 and _g < len(termQ) else None)
            _g = (_g + 1)
            stru = t.asStructure()
            if (stru is not None):
                x = stru.variablize()
                results.append(x)
            else:
                results.append(t)
        return results

    def callPreprocessor(self,name,dbWrapper,clause):
        varOut = blub_prolog_terms_Variable()
        queryTerm = blub_prolog_terms_Structure(self.macroDatabase.context.getAtom(name),[dbWrapper, clause, varOut])
        query = blub_prolog_Query(self.macroDatabase,queryTerm)
        if (not query.get_engine().findSolution()):
            return [clause]
        result = python_internal_ArrayImpl._get(query.environment, varOut.index).dereference()
        if (result.asReference() is not None):
            return []
        _hx_list = result.asStructure()
        if (_hx_list is None):
            return [result]
        return _hx_list.commaList()
    nullPreprocessor = None

    @staticmethod
    def getAStandardPreprocessor():
        standardPreprocessor = blub_prolog_Preprocessor(blub_prolog_Database(blub_prolog_AtomContext.GLOBALS))
        standardPreprocessor.loadStandardTheories()
        return standardPreprocessor

    @staticmethod
    def getNullPreprocessor():
        if (blub_prolog_Preprocessor.nullPreprocessor is None):
            blub_prolog_Preprocessor.nullPreprocessor = blub_prolog_Preprocessor(None)
        return blub_prolog_Preprocessor.nullPreprocessor

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.macroDatabase = None
        _hx_o.preprocessorPredicates = None
_hx_classes["blub.prolog.Preprocessor"] = blub_prolog_Preprocessor


class blub_prolog_PrologError:
    _hx_class_name = "blub.prolog.PrologError"
    __slots__ = ("message",)
    _hx_fields = ["message"]
    _hx_methods = ["toString"]

    def __init__(self,msg):
        self.message = msg

    def toString(self):
        return self.message

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.message = None
_hx_classes["blub.prolog.PrologError"] = blub_prolog_PrologError


class blub_prolog_PrologException(blub_prolog_PrologError):
    _hx_class_name = "blub.prolog.PrologException"
    __slots__ = ("context", "errorTerm")
    _hx_fields = ["context", "errorTerm"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_PrologError


    def __init__(self,errorTerm,context):
        self.errorTerm = None
        self.context = None
        super().__init__(errorTerm.toString())
        self.errorTerm = errorTerm
        self.context = context

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.context = None
        _hx_o.errorTerm = None
_hx_classes["blub.prolog.PrologException"] = blub_prolog_PrologException


class blub_prolog_RuntimeError(blub_prolog_PrologException):
    _hx_class_name = "blub.prolog.RuntimeError"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["ERROR", "CONTEXT", "NONE", "INSTANTIATION_ERROR", "TYPE_ERROR", "EXISTENCE_ERROR", "DOMAIN_ERROR", "PERMISSION_ERROR", "REPRESENTATION_ERROR", "EVALUATION_ERROR", "RESOURCE_ERROR", "SYNTAX_ERROR", "SYSTEM_ERROR", "EXIST_PROCEDURE", "EXIST_SRC_SINK", "EXIST_STREAM", "instantiationError", "existenceError", "typeError", "domainError"]
    _hx_interfaces = []
    _hx_super = blub_prolog_PrologException


    def __init__(self,term,context):
        super().__init__(blub_prolog_terms_Structure(blub_prolog_RuntimeError.ERROR,[term, blub_prolog_terms_Structure(blub_prolog_RuntimeError.CONTEXT,[(context.head if ((context is not None)) else blub_prolog_RuntimeError.NONE)])]),context)

    @staticmethod
    def instantiationError(context):
        return blub_prolog_RuntimeError(blub_prolog_RuntimeError.INSTANTIATION_ERROR,context)

    @staticmethod
    def existenceError(_hx_type,culprit,context):
        tmp = None
        tmp1 = _hx_type.index
        if (tmp1 == 0):
            tmp = blub_prolog_RuntimeError.EXIST_PROCEDURE
        elif (tmp1 == 1):
            tmp = blub_prolog_RuntimeError.EXIST_SRC_SINK
        elif (tmp1 == 2):
            tmp = blub_prolog_RuntimeError.EXIST_STREAM
        else:
            pass
        return blub_prolog_RuntimeError(blub_prolog_terms_Structure(blub_prolog_RuntimeError.EXISTENCE_ERROR,[tmp, culprit]),context)

    @staticmethod
    def typeError(validType,culprit,context):
        return blub_prolog_RuntimeError(blub_prolog_terms_Structure(blub_prolog_RuntimeError.TYPE_ERROR,[validType, culprit]),context)

    @staticmethod
    def domainError(msg,culprit,context):
        return blub_prolog_RuntimeError(blub_prolog_terms_Structure(blub_prolog_RuntimeError.DOMAIN_ERROR,[blub_prolog_terms_Atom.unregisteredAtom(msg), culprit]),context)
_hx_classes["blub.prolog.RuntimeError"] = blub_prolog_RuntimeError

class blub_prolog_ExistenceError(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.ExistenceError"
    _hx_constructs = ["ee_procedure", "ee_source_sink", "ee_stream"]
blub_prolog_ExistenceError.ee_procedure = blub_prolog_ExistenceError("ee_procedure", 0, ())
blub_prolog_ExistenceError.ee_source_sink = blub_prolog_ExistenceError("ee_source_sink", 1, ())
blub_prolog_ExistenceError.ee_stream = blub_prolog_ExistenceError("ee_stream", 2, ())
_hx_classes["blub.prolog.ExistenceError"] = blub_prolog_ExistenceError


class blub_prolog_TypeError(blub_prolog_RuntimeError):
    _hx_class_name = "blub.prolog.TypeError"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = ["VALID_TYPE_atom", "VALID_TYPE_atomic", "VALID_TYPE_byte", "VALID_TYPE_callable", "VALID_TYPE_character", "VALID_TYPE_evaluable", "VALID_TYPE_in_byte", "VALID_TYPE_in_character", "VALID_TYPE_integer", "VALID_TYPE_list", "VALID_TYPE_number", "VALID_TYPE_predicate_indicator", "VALID_TYPE_variable", "VALID_TYPE_compound"]
    _hx_interfaces = []
    _hx_super = blub_prolog_RuntimeError


    def __init__(self,term,context):
        super().__init__(term,context)
_hx_classes["blub.prolog.TypeError"] = blub_prolog_TypeError


class blub_prolog_Query:
    _hx_class_name = "blub.prolog.Query"
    __slots__ = ("autocommit", "committed", "hadResults", "database", "term", "nextResult", "_code", "code", "environment", "variableContext", "_engine", "engine")
    _hx_fields = ["autocommit", "committed", "hadResults", "database", "term", "nextResult", "_code", "environment", "variableContext", "_engine"]
    _hx_methods = ["setCode", "get_code", "get_engine", "iterator", "putBack", "hasNext", "next", "complete", "allResults", "commit", "allSolutions", "allBindings", "nextSolution", "grabCurrentSolution", "makeBindings", "_commit"]
    _hx_statics = ["timestamp"]

    def __init__(self,database,term,autocommit = None):
        if (autocommit is None):
            autocommit = True
        self.engine = None
        self._engine = None
        self.environment = None
        self.code = None
        self._code = None
        self.nextResult = None
        self.hadResults = None
        self.committed = None
        self.database = database
        self.term = term
        self.autocommit = autocommit
        def _hx_local_3():
            def _hx_local_1():
                _hx_local_0 = term
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_Structure) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            return (_hx_local_1()).get_variableContext() if Std.isOfType(term,blub_prolog_terms_Structure) else blub_prolog_terms_VariableContext.EMPTY
        self.variableContext = _hx_local_3()

    def setCode(self,code):
        self._code = code
        self._engine = None

    def get_code(self):
        if (self._code is None):
            self._code = blub_prolog_compiler_QueryCompiler(self.database).compile(self.term)
        return self._code

    def get_engine(self):
        if (self._engine is None):
            self._engine = blub_prolog_engine_QueryEngine(self.database,self.get_code())
            _this = self._engine
            size = self.variableContext.get_count()
            _this.environment = list()
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this1 = _this.environment
                x = blub_prolog_terms_Reference()
                _this1.append(x)
            self.environment = self._engine.environment
        return self._engine

    def iterator(self):
        return self

    def putBack(self,solution):
        self.nextResult = solution

    def hasNext(self):
        if (self.nextResult is not None):
            return True
        self.nextResult = self.nextSolution()
        if (self.nextResult is not None):
            return True
        return False

    def next(self):
        if (self.nextResult is not None):
            result = self.nextResult
            self.nextResult = None
            return result
        return self.nextSolution()

    def complete(self):
        while (self.nextSolution() is not None):
            pass

    def allResults(self):
        res = list()
        result = None
        while True:
            result = self.nextSolution()
            if (not ((result is not None))):
                break
            res.append(result)
        return res

    def commit(self):
        self.complete()
        self._commit()

    def allSolutions(self):
        res = list()
        result = None
        while True:
            result = self.nextSolution()
            if (not ((result is not None))):
                break
            if (not blub_prolog_ResultUtil.isSuccess(result)):
                break
            res.append(result)
        return res

    def allBindings(self):
        res = list()
        result = None
        while True:
            result = self.nextSolution()
            if (not ((result is not None))):
                break
            if (not blub_prolog_ResultUtil.isSuccess(result)):
                return None
            binds = blub_prolog_ResultUtil.getBindings(result)
            if (binds is None):
                return res
            res.append(binds)
        return res

    def nextSolution(self):
        if (self.nextResult is not None):
            r = self.nextResult
            self.nextResult = None
            return r
        result = None
        if (not self.get_engine().findSolution()):
            if self.autocommit:
                self._commit()
            if self.hadResults:
                return None
            result = blub_prolog_Result.failure
        else:
            result = self.grabCurrentSolution()
        self.hadResults = True
        return result

    def grabCurrentSolution(self):
        if (self.variableContext.get_count() == 0):
            return blub_prolog_Result.success
        else:
            binds = self.makeBindings()
            return blub_prolog_Result.bindings(binds)

    def makeBindings(self):
        if (self.variableContext.get_count() == 0):
            return None
        binds = haxe_ds_StringMap()
        refVars = haxe_ds_ObjectMap()
        v = self.variableContext.variables()
        while v.hasNext():
            v1 = v.next()
            value = python_internal_ArrayImpl._get(self.environment, v1.index).dereference()
            ref = value.asReference()
            if (ref is not None):
                v2 = refVars.h.get(ref,None)
                if (v2 is None):
                    v2 = blub_prolog_terms_Variable()
                    refVars.set(ref,v2)
                value = v2
            s = value.asStructure()
            if ((s is not None) and s.hasReferences()):
                value = s.variablize(refVars)
            key = v1.get_name()
            binds.h[key] = value
        return binds

    def _commit(self):
        if self.committed:
            return
        if (self._engine.transaction is not None):
            self._engine.transaction.commit()
        self.committed = True

    @staticmethod
    def timestamp():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.autocommit = None
        _hx_o.committed = None
        _hx_o.hadResults = None
        _hx_o.database = None
        _hx_o.term = None
        _hx_o.nextResult = None
        _hx_o._code = None
        _hx_o.environment = None
        _hx_o.variableContext = None
        _hx_o._engine = None
_hx_classes["blub.prolog.Query"] = blub_prolog_Query

class blub_prolog_Result(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.Result"
    _hx_constructs = ["failure", "success", "bindings"]

    @staticmethod
    def bindings(binds):
        return blub_prolog_Result("bindings", 2, (binds,))
blub_prolog_Result.failure = blub_prolog_Result("failure", 0, ())
blub_prolog_Result.success = blub_prolog_Result("success", 1, ())
_hx_classes["blub.prolog.Result"] = blub_prolog_Result


class blub_prolog_ResultUtil:
    _hx_class_name = "blub.prolog.ResultUtil"
    __slots__ = ()
    _hx_statics = ["toString", "bindingsToString", "getBindings", "isSuccess", "equals", "equalsBindings", "compareBindings"]

    @staticmethod
    def toString(result):
        tmp = result.index
        if (tmp == 0):
            return "false"
        elif (tmp == 1):
            return "true"
        elif (tmp == 2):
            b = result.params[0]
            return blub_prolog_ResultUtil.bindingsToString(b)
        else:
            pass

    @staticmethod
    def bindingsToString(bindings):
        if (bindings is None):
            return "{null}"
        s = "{ "
        first = True
        key = bindings.keys()
        while key.hasNext():
            key1 = key.next()
            if first:
                first = False
            else:
                s = (("null" if s is None else s) + ", ")
            t = bindings.h.get(key1,None)
            s = (("null" if s is None else s) + HxOverrides.stringOrNull((((("null" if key1 is None else key1) + "=") + HxOverrides.stringOrNull(((t.toString() if ((t is not None)) else "<null>")))))))
        s = (("null" if s is None else s) + " }")
        return s

    @staticmethod
    def getBindings(result):
        tmp = result.index
        if (tmp == 0):
            return None
        elif (tmp == 1):
            return None
        elif (tmp == 2):
            b = result.params[0]
            return b
        else:
            pass

    @staticmethod
    def isSuccess(result):
        tmp = result.index
        if (tmp == 0):
            return False
        elif (tmp == 1):
            return True
        elif (tmp == 2):
            _g = result.params[0]
            return True
        else:
            pass

    @staticmethod
    def equals(r1,r2):
        binds1 = None
        binds2 = None
        tmp = r1.index
        if (tmp == 0):
            if (r2.index == 0):
                return True
            else:
                return False
        elif (tmp == 1):
            if (r2.index == 1):
                return True
            else:
                return False
        elif (tmp == 2):
            b1 = r1.params[0]
            if (r2.index == 2):
                b2 = r2.params[0]
                binds1 = b1
                binds2 = b2
            else:
                return False
        else:
            pass
        return blub_prolog_ResultUtil.compareBindings(binds1,binds2)

    @staticmethod
    def equalsBindings(result,binds):
        tmp = result.index
        if (tmp == 0):
            return False
        elif (tmp == 1):
            return False
        elif (tmp == 2):
            b1 = result.params[0]
            return blub_prolog_ResultUtil.compareBindings(b1,binds)
        else:
            pass

    @staticmethod
    def compareBindings(binds1,binds2):
        key = binds2.keys()
        while key.hasNext():
            key1 = key.next()
            val = binds2.h.get(key1,None)
            if (val is None):
                return False
            bind = binds1.h.get(key1,None)
            if ((bind is None) or (not bind.equals(val))):
                return False
        key = binds1.keys()
        while key.hasNext():
            key1 = key.next()
            bind = binds1.h.get(key1,None)
            val = binds2.h.get(key1,None)
            if (val is None):
                return False
            if (not bind.equals(val)):
                return False
        return True
_hx_classes["blub.prolog.ResultUtil"] = blub_prolog_ResultUtil


class blub_prolog_async_AsyncQuery(blub_prolog_Query):
    _hx_class_name = "blub.prolog.async.AsyncQuery"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_Query


    def __init__(self,database,term,autocommit = None):
        if (autocommit is None):
            autocommit = True
        super().__init__(database,term,autocommit)

    def execute(self,resultCallback = None):
        _gthis = self
        if (resultCallback is None):
            self.get_engine().executeAsync()
            return
        def _hx_local_0(eng,_hx_type):
            tmp = _hx_type.index
            if (tmp == 0):
                if (not _gthis.get_engine().solutionFound):
                    resultCallback.asyncFail(_gthis)
                else:
                    resultCallback.asyncSolution(_gthis,_gthis.makeBindings())
            elif (tmp == 1):
                resultCallback.asyncDone(_gthis)
            elif (tmp == 2):
                resultCallback.asyncHalt(_gthis)
            elif (tmp == 3):
                resultCallback.asyncOperation(_gthis)
            else:
                pass
        self.get_engine().executeAsync(_hx_local_0)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.async.AsyncQuery"] = blub_prolog_async_AsyncQuery


class blub_prolog_async_AsyncResults:
    _hx_class_name = "blub.prolog.async.AsyncResults"
    __slots__ = ()
    _hx_methods = ["asyncSolution", "asyncFail", "asyncDone", "asyncOperation", "asyncHalt"]
_hx_classes["blub.prolog.async.AsyncResults"] = blub_prolog_async_AsyncResults


class blub_prolog_async_AsyncResultsImpl:
    _hx_class_name = "blub.prolog.async.AsyncResultsImpl"
    __slots__ = ()
    _hx_methods = ["asyncSolution", "asyncFail", "asyncDone", "asyncOperation", "asyncHalt", "doneOrHalted"]
    _hx_interfaces = [blub_prolog_async_AsyncResults]

    def __init__(self):
        pass

    def asyncSolution(self,query,bindings):
        pass

    def asyncFail(self,query):
        pass

    def asyncDone(self,query):
        self.doneOrHalted(query)

    def asyncOperation(self,query):
        pass

    def asyncHalt(self,query):
        self.doneOrHalted(query)

    def doneOrHalted(self,query):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.async.AsyncResultsImpl"] = blub_prolog_async_AsyncResultsImpl


class blub_prolog_builtins_BuiltinPredicate:
    _hx_class_name = "blub.prolog.builtins.BuiltinPredicate"
    __slots__ = ("name", "arity")
    _hx_fields = ["name", "arity"]
    _hx_methods = ["register", "compile", "execute"]

    def __init__(self,name,arity):
        self.arity = arity
        self.name = name

    def register(self,database):
        nameAtom = database.context.getAtom(self.name)
        pred = database.addPredicate(blub_prolog_PredicateIndicator(nameAtom,self.arity),False)
        pred.setBuiltin(self)

    def compile(self,compiler,pred,term):
        stru = term.asStructure()
        args = (stru.getArgs() if ((stru is not None)) else None)
        compiler.add(blub_prolog_compiler_Instruction.call_builtin(pred.indicator.toString(),args))

    def execute(self,engine,args):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.arity = None
_hx_classes["blub.prolog.builtins.BuiltinPredicate"] = blub_prolog_builtins_BuiltinPredicate


class blub_prolog_builtins_Abolish(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Abolish"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("abolish",1)

    def execute(self,engine,args):
        env = engine.environment
        term = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        stru = term.asStructure()
        indicator = blub_prolog_PredicateIndicator.fromTerm(term,engine.context)
        predicate = engine.database.lookup(indicator)
        if (predicate is None):
            return
        engine.makeTransaction().abolish(predicate)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Abolish"] = blub_prolog_builtins_Abolish


class blub_prolog_builtins_Arg(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Arg"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute", "executeChoices", "executeIndex"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("arg",3)

    def execute(self,engine,args):
        env = engine.environment
        arg = (args[0] if 0 < len(args) else None).toValue(env)
        term = (args[1] if 1 < len(args) else None).toValue(env)
        value = (args[2] if 2 < len(args) else None).toValue(env)
        atom = term.asAtom()
        if (atom is not None):
            engine.fail()
            return
        stru = term.asStructure()
        if (stru is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_compound,term,engine.context))
            return
        argNum = arg.asNumber()
        if (argNum is not None):
            self.executeIndex(engine,argNum,stru,value)
            return
        argRef = arg.asReference()
        if (argRef is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_variable,arg,engine.context))
            return
        self.executeChoices(engine,argRef,stru,value)

    def executeChoices(self,engine,argRef,stru,value):
        arity = stru.getArity()
        _g = 0
        _g1 = arity
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            arg = stru.argAt(i).asValueTerm()
            binds = engine.bindings
            if arg.unify(value,engine):
                argRef.unify(blub_prolog_terms_NumberTerm((i + 1)),engine)
                if (i < ((arity - 1))):
                    cp = blub_prolog_builtins_ArgChoicePoint(engine,(i + 1),argRef,stru,value)
                    cp.bindings = binds
                return
        engine.fail()

    def executeIndex(self,engine,argNum,stru,value):
        x = argNum.value
        index = None
        try:
            index = int(x)
        except BaseException as _g:
            None
            index = None
        if (index < 0):
            engine.raiseException(blub_prolog_RuntimeError.domainError("not_less_than_zero",argNum,engine.context))
            return
        if ((index == 0) or ((index > stru.getArity()))):
            engine.fail()
            return
        arg = stru.argAt((index - 1)).asValueTerm()
        engine.unify(arg,value)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Arg"] = blub_prolog_builtins_Arg


class blub_prolog_engine_parts_ChoicePoint:
    _hx_class_name = "blub.prolog.engine.parts.ChoicePoint"
    __slots__ = ("bindings", "frame", "prev", "engine", "_id")
    _hx_fields = ["bindings", "frame", "prev", "engine", "_id"]
    _hx_methods = ["nextChoice", "undoBindings", "popThisChoicePoint", "halt", "toString", "getId"]
    _hx_statics = ["ID"]

    def __init__(self,eng,frame = None):
        self._id = None
        self.engine = None
        self.frame = (frame if ((frame is not None)) else blub_prolog_engine_parts_CodeFrame(eng))
        self.bindings = eng.bindings
        self.prev = eng.choiceStack
        eng.choiceStack = self
        self.engine = eng

    def nextChoice(self):
        self.frame.restore()
        self.popThisChoicePoint()
        return True

    def undoBindings(self):
        _this = self.engine
        prevBind = self.bindings
        bind = _this.bindings
        while ((bind is not None) and ((bind != prevBind))):
            bind.ref.unbind(bind.old)
            bind = bind.next
        _this.bindings = prevBind

    def popThisChoicePoint(self):
        self.engine.choiceStack = self.prev

    def halt(self):
        pass

    def toString(self):
        return ("Choicepoint: " + Std.string(self.frame))

    def getId(self):
        if (self._id < 1):
            def _hx_local_2():
                _hx_local_0 = blub_prolog_engine_parts_ChoicePoint
                _hx_local_1 = _hx_local_0.ID
                _hx_local_0.ID = (_hx_local_1 + 1)
                return _hx_local_1
            self._id = _hx_local_2()
        return self._id

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bindings = None
        _hx_o.frame = None
        _hx_o.prev = None
        _hx_o.engine = None
        _hx_o._id = None
_hx_classes["blub.prolog.engine.parts.ChoicePoint"] = blub_prolog_engine_parts_ChoicePoint


class blub_prolog_builtins_ArgChoicePoint(blub_prolog_engine_parts_ChoicePoint):
    _hx_class_name = "blub.prolog.builtins.ArgChoicePoint"
    __slots__ = ("index", "argRef", "stru", "value")
    _hx_fields = ["index", "argRef", "stru", "value"]
    _hx_methods = ["nextChoice", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_engine_parts_ChoicePoint


    def __init__(self,eng,index,argRef,stru,value):
        self.value = None
        self.stru = None
        self.argRef = None
        self.index = None
        super().__init__(eng,eng.codeStack)
        self.index = index
        self.argRef = argRef
        self.stru = stru
        self.value = value

    def nextChoice(self):
        self.frame.restore()
        arity = self.stru.getArity()
        _g = self.index
        _g1 = arity
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            arg = self.stru.argAt(i).asValueTerm()
            if arg.unify(self.value,self.engine):
                self.argRef.unify(blub_prolog_terms_NumberTerm((i + 1)),self.engine)
                if (i == ((arity - 1))):
                    self.popThisChoicePoint()
                else:
                    self.index = (i + 1)
                return True
        self.popThisChoicePoint()
        return False

    def toString(self):
        return ("arg/3: " + Std.string(self.frame))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.argRef = None
        _hx_o.stru = None
        _hx_o.value = None
_hx_classes["blub.prolog.builtins.ArgChoicePoint"] = blub_prolog_builtins_ArgChoicePoint


class blub_prolog_builtins_AssertA(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.AssertA"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("asserta",1)

    def execute(self,engine,args):
        env = engine.environment
        term = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        if (not Std.isOfType(term,blub_prolog_terms_ClauseTerm)):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,term,engine.context))
            return
        clauseTerm = term
        stru = clauseTerm.asStructure()
        if (stru is not None):
            clauseTerm = stru.variablize()
        engine.makeTransaction().preAssert(clauseTerm)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.AssertA"] = blub_prolog_builtins_AssertA


class blub_prolog_builtins_AssertZ(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.AssertZ"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("assertz",1)

    def execute(self,engine,args):
        env = engine.environment
        term = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        if (not Std.isOfType(term,blub_prolog_terms_ClauseTerm)):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,term,engine.context))
            return
        clauseTerm = term
        stru = clauseTerm.asStructure()
        if (stru is not None):
            clauseTerm = stru.variablize()
        engine.makeTransaction().postAssert(clauseTerm)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.AssertZ"] = blub_prolog_builtins_AssertZ


class blub_prolog_builtins_AtomCodes(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.AtomCodes"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("atom_codes",2)

    def execute(self,engine,args):
        env = engine.environment
        atomArg = (args[0] if 0 < len(args) else None).toValue(env)
        stringArg = (args[1] if 1 < len(args) else None).toValue(env)
        atom = atomArg.asAtom()
        if (atom is not None):
            text = atom.text
            _hx_len = len(text)
            codes = list()
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                x = blub_prolog_terms_NumberTerm(HxString.charCodeAt(text,i))
                codes.append(x)
            engine.unify(blub_prolog_terms_Structure.makeList(codes),stringArg)
            return
        atomRef = atomArg.asReference()
        if (atomRef is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_atom,atomArg,engine.context))
            return
        codeList = stringArg.asStructure()
        if (codeList is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_list,stringArg,engine.context))
            return
        codes = codeList.toArray()
        if (codes is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_list,codeList,engine.context))
            return
        buf_b = python_lib_io_StringIO()
        _g = 0
        while (_g < len(codes)):
            t = (codes[_g] if _g >= 0 and _g < len(codes) else None)
            _g = (_g + 1)
            code = t.asNumber()
            if (code is None):
                engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_number,t,engine.context))
                return
            x = code.value
            c = None
            try:
                c = int(x)
            except BaseException as _g1:
                None
                c = None
            buf_b.write("".join(map(chr,[c])))
        engine.unify(blub_prolog_terms_Atom.unregisteredAtom(buf_b.getvalue()),atomRef)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.AtomCodes"] = blub_prolog_builtins_AtomCodes


class blub_prolog_builtins_BinaryArithmeticPred(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.BinaryArithmeticPred"
    __slots__ = ("fn",)
    _hx_fields = ["fn"]
    _hx_methods = ["execute"]
    _hx_statics = ["get"]
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self,functor,fn):
        self.fn = None
        super().__init__(functor,2)
        self.fn = fn

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env)
        b = (args[1] if 1 < len(args) else None).toValue(env)
        numA = a.asNumber()
        numB = b.asNumber()
        valA = (engine.get_arithmetic().evaluate(a) if ((numA is None)) else numA.value)
        valB = (engine.get_arithmetic().evaluate(b) if ((numB is None)) else numB.value)
        if (not self.fn(valA,valB)):
            engine.fail()

    @staticmethod
    def get():
        def _hx_local_6():
            def _hx_local_0(a,b):
                return (a == b)
            def _hx_local_1(a,b):
                return (a != b)
            def _hx_local_2(a,b):
                return (a > b)
            def _hx_local_3(a,b):
                return (a < b)
            def _hx_local_4(a,b):
                return (a >= b)
            def _hx_local_5(a,b):
                return (a <= b)
            return [blub_prolog_builtins_BinaryArithmeticPred("=:=",_hx_local_0), blub_prolog_builtins_BinaryArithmeticPred("=\\=",_hx_local_1), blub_prolog_builtins_BinaryArithmeticPred(">",_hx_local_2), blub_prolog_builtins_BinaryArithmeticPred("<",_hx_local_3), blub_prolog_builtins_BinaryArithmeticPred(">=",_hx_local_4), blub_prolog_builtins_BinaryArithmeticPred("=<",_hx_local_5)]
        return _hx_local_6()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fn = None
_hx_classes["blub.prolog.builtins.BinaryArithmeticPred"] = blub_prolog_builtins_BinaryArithmeticPred


class blub_prolog_builtins_Breakpoint(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Breakpoint"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("break",0)

    def execute(self,engine,args):
        engine.breakpoint()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Breakpoint"] = blub_prolog_builtins_Breakpoint


class blub_prolog_builtins_True(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.True"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("true",0)

    def execute(self,engine,args):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.True"] = blub_prolog_builtins_True


class blub_prolog_builtins_Fail(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Fail"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("fail",0)

    def execute(self,engine,args):
        engine.fail()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Fail"] = blub_prolog_builtins_Fail


class blub_prolog_builtins_Repeat(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Repeat"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("repeat",0)

    def execute(self,engine,args):
        blub_prolog_engine_parts_RepeatingChoicePoint(engine)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Repeat"] = blub_prolog_builtins_Repeat


class blub_prolog_builtins_Is(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Is"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("is",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env)
        b = (args[1] if 1 < len(args) else None).toValue(env)
        num = b.asNumber()
        if (num is None):
            num = blub_prolog_terms_NumberTerm(engine.get_arithmetic().evaluate(b))
        engine.unify(a,num)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Is"] = blub_prolog_builtins_Is


class blub_prolog_builtins_Unify(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Unify"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("=",2)

    def execute(self,engine,args):
        env = engine.environment
        engine.unify((args[0] if 0 < len(args) else None).toValue(env),(args[1] if 1 < len(args) else None).toValue(env))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Unify"] = blub_prolog_builtins_Unify


class blub_prolog_builtins_Identical(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Identical"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("==",2)

    def execute(self,engine,args):
        env = engine.environment
        if (not (args[0] if 0 < len(args) else None).toValue(env).equals((args[1] if 1 < len(args) else None).toValue(env))):
            engine.fail()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Identical"] = blub_prolog_builtins_Identical


class blub_prolog_builtins_NotIdentical(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.NotIdentical"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("\\==",2)

    def execute(self,engine,args):
        env = engine.environment
        if (args[0] if 0 < len(args) else None).toValue(env).equals((args[1] if 1 < len(args) else None).toValue(env)):
            engine.fail()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.NotIdentical"] = blub_prolog_builtins_NotIdentical


class blub_prolog_builtins_Cut(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Cut"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("!",0)

    def execute(self,engine,args):
        engine.cut()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Cut"] = blub_prolog_builtins_Cut


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "get_length", "fromCharCode", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def get_length(s):
        return len(s)

    @staticmethod
    def fromCharCode(code):
        return "".join(map(chr,[code]))

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
_hx_classes["HxString"] = HxString


class blub_prolog_builtins_Call(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Call"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = ["INDICATOR"]
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("call",1)

    def execute(self,engine,args):
        goal = (args[0] if 0 < len(args) else None).toValue(engine.environment).dereference()
        try:
            instruction = blub_prolog_builtins_CallCompiler(engine).compileCall(goal)
            engine.codeStack = blub_prolog_engine_parts_CodeFrame(engine)
            cp = blub_prolog_engine_parts_CutPoint(engine)
            engine.cutBarrier = _hx_AnonObject({'prev': engine.cutBarrier, 'choice': cp})
            engine.codePointer = instruction
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,blub_prolog_builtins_NotCallable):
                ex = _g1
                engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,ex.culprit,engine.context))
            else:
                raise _g

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Call"] = blub_prolog_builtins_Call


class blub_prolog_builtins_Once(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Once"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("once",1)

    def compile(self,compiler,pred,term):
        call = compiler.database.lookup(blub_prolog_builtins_Call.INDICATOR)
        compiler.add(blub_prolog_compiler_Instruction.cut_point)
        compiler.add(blub_prolog_compiler_Instruction.call_builtin("call/1",term.asStructure().getArgs()))
        compiler.add(blub_prolog_compiler_Instruction.cut)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Once"] = blub_prolog_builtins_Once


class blub_prolog_builtins_NotUnifiable(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.NotUnifiable"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("\\=",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env)
        b = (args[1] if 1 < len(args) else None).toValue(env)
        if a.unify(b,engine):
            engine.fail()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.NotUnifiable"] = blub_prolog_builtins_NotUnifiable


class blub_prolog_builtins_NotProvable(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.NotProvable"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("\\+",1)

    def compile(self,compiler,pred,term):
        atoms = compiler.database.context
        trueAtom = atoms.getAtom("true")
        failAtom = atoms.getAtom("fail")
        cutAtom = atoms.getAtom("!")
        conjunc2 = blub_prolog_terms_Structure(atoms.getAtom(","))
        conjunc2.addArg(cutAtom)
        conjunc2.addArg(failAtom)
        conjunc1 = blub_prolog_terms_Structure(atoms.getAtom(","))
        conjunc1.addArg(term.asStructure().argAt(0))
        conjunc1.addArg(conjunc2)
        disjunc = blub_prolog_terms_Structure(atoms.getAtom(";"))
        disjunc.addArg(conjunc1)
        disjunc.addArg(trueAtom)
        compiler.compileNestedTerm(disjunc,True)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.NotProvable"] = blub_prolog_builtins_NotProvable


class blub_prolog_builtins_IfThen(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.IfThen"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("->",2)

    def compile(self,compiler,pred,term):
        ifThen = term.asStructure()
        ifTerm = compiler.clauseTerm(ifThen.argAt(0))
        thenTerm = compiler.clauseTerm(ifThen.argAt(1))
        compiler.add(blub_prolog_compiler_Instruction.cut_point)
        compiler.compileTerm(ifTerm)
        compiler.add(blub_prolog_compiler_Instruction.cut)
        compiler.compileTerm(thenTerm)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.IfThen"] = blub_prolog_builtins_IfThen


class blub_prolog_builtins_IfThenElse(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.IfThenElse"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("#if_then_else",3)

    def compile(self,compiler,pred,term):
        ifThen = term.asStructure()
        ifTerm = ifThen.argAt(0)
        thenTerm = ifThen.argAt(1)
        elseTerm = ifThen.argAt(2)
        atoms = compiler.database.context
        cutAtom = atoms.getAtom("!")
        conjunc2 = blub_prolog_terms_Structure(atoms.getAtom(","))
        conjunc2.addArg(cutAtom)
        conjunc2.addArg(thenTerm)
        conjunc1 = blub_prolog_terms_Structure(atoms.getAtom(","))
        conjunc1.addArg(ifTerm)
        conjunc1.addArg(conjunc2)
        disjunc = blub_prolog_terms_Structure(atoms.getAtom(";"))
        disjunc.addArg(conjunc1)
        disjunc.addArg(elseTerm)
        compiler.compileNestedTerm(disjunc,True)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.IfThenElse"] = blub_prolog_builtins_IfThenElse


class blub_prolog_builtins_Retract(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Retract"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("retract",1)

    def execute(self,engine,args):
        env = engine.environment
        term = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        if (not Std.isOfType(term,blub_prolog_terms_ClauseTerm)):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,term,engine.context))
            return
        ct = term
        functor = ct.getIndicator()
        predicate = engine.database.lookup(functor)
        if (predicate is None):
            return
        clause = predicate.clauses()
        while clause.hasNext():
            clause1 = clause.next()
            cterm = clause1.term
            env = clause1.variableContext.createEnvironment()
            vterm = cterm.toValue(env)
            if vterm.unify(term,None):
                engine.makeTransaction().retract(clause1)
                return

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Retract"] = blub_prolog_builtins_Retract


class blub_prolog_builtins_Timestamp(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Timestamp"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("timestamp",1)

    def execute(self,engine,args):
        engine.unify((args[0] if 0 < len(args) else None).toValue(engine.environment),blub_prolog_terms_NumberTerm(python_lib_Timeit.default_timer()))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Timestamp"] = blub_prolog_builtins_Timestamp


class blub_prolog_builtins_Gensym(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Gensym"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = ["count"]
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("gensym",2)

    def execute(self,engine,args):
        env = engine.environment
        base = (args[0] if 0 < len(args) else None).toValue(env)
        baseAtom = base.asAtom()
        if (baseAtom is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_atom,base,engine.context))
        tmp = (args[1] if 1 < len(args) else None).toValue(env)
        def _hx_local_2():
            _hx_local_0 = blub_prolog_builtins_Gensym
            _hx_local_1 = _hx_local_0.count
            _hx_local_0.count = (_hx_local_1 + 1)
            return _hx_local_1
        tmp1 = (HxOverrides.stringOrNull(baseAtom.text) + Std.string(_hx_local_2()))
        engine.unify(tmp,blub_prolog_terms_Atom.unregisteredAtom(tmp1))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Gensym"] = blub_prolog_builtins_Gensym


class blub_prolog_builtins_Univ(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Univ"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("=..",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env)
        b = (args[1] if 1 < len(args) else None).toValue(env)
        refA = a.asReference()
        refB = b.asReference()
        if ((refA is not None) and ((refB is not None))):
            engine.raiseException(blub_prolog_RuntimeError.instantiationError(engine.context))
            return
        if (refA is not None):
            struB = b.asStructure()
            if ((struB is None) or ((struB.getName() != blub_prolog_terms_Structure.CONS_LIST))):
                engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_list,b,engine.context))
                return
            args = []
            s = struB
            while (s is not None):
                tail = s.argAt(1)
                if (tail == blub_prolog_terms_Structure.EMPTY_LIST):
                    break
                tailStru = tail.asStructure()
                if ((tailStru is None) or ((tailStru.getName() != blub_prolog_terms_Structure.CONS_LIST))):
                    engine.raiseException(blub_prolog_RuntimeError.instantiationError(engine.context))
                    return
                x = tailStru.argAt(0)
                args.append(x)
                s = tailStru
            if (len(args) == 0):
                engine.unify(refA,struB.argAt(0))
                return
            name = struB.argAt(0).asAtom()
            if (name is None):
                engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_atom,struB.argAt(0),engine.context))
                return
            newStru = blub_prolog_terms_Structure(name,args)
            engine.unify(refA,newStru)
            return
        lhsList = None
        lhsAtom = a.asAtom()
        if (lhsAtom is not None):
            lhsList = blub_prolog_terms_Structure.makeList([lhsAtom])
        else:
            lhsStru = a.asStructure()
            if (lhsStru is None):
                engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_compound,a,engine.context))
                return
            elems = list()
            x = lhsStru.getName()
            elems.append(x)
            _g = 0
            _g1 = lhsStru.getArgs()
            while (_g < len(_g1)):
                arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                elems.append(arg)
            lhsList = blub_prolog_terms_Structure.makeList(elems)
        engine.unify(lhsList,b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Univ"] = blub_prolog_builtins_Univ


class blub_prolog_builtins_Write(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Write"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("write",1)

    def execute(self,engine,args):
        env = engine.environment
        haxe_Log.trace((args[0] if 0 < len(args) else None).toValue(env).dereference().toString(),_hx_AnonObject({'fileName': "src/blub/prolog/builtins/Write.hx", 'lineNumber': 20, 'className': "blub.prolog.builtins.Write", 'methodName': "execute"}))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Write"] = blub_prolog_builtins_Write


class blub_prolog_builtins_Clear(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Clear"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("clear",0)

    def execute(self,engine,args):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Clear"] = blub_prolog_builtins_Clear


class blub_prolog_builtins_Stop(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Stop"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("stop",0)

    def execute(self,engine,args):
        engine.halt()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Stop"] = blub_prolog_builtins_Stop


class blub_prolog_builtins_Functor(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Functor"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("functor",3)

    def execute(self,engine,args):
        env = engine.environment
        term = (args[0] if 0 < len(args) else None).toValue(env)
        name = (args[1] if 1 < len(args) else None).toValue(env)
        arity = (args[2] if 2 < len(args) else None).toValue(env)
        termVar = term.asReference()
        if (termVar is not None):
            nameAtom = name.asAtom()
            arityNum = arity.asNumber()
            if (((nameAtom is None) or ((arityNum is None))) or ((arityNum.value < 0))):
                engine.raiseException(blub_prolog_RuntimeError.instantiationError(engine.context))
                return
            newTerm = None
            x = arityNum.value
            arityVal = None
            try:
                arityVal = int(x)
            except BaseException as _g:
                None
                arityVal = None
            if (arityVal == 0):
                newTerm = nameAtom
            else:
                newStru = blub_prolog_terms_Structure(nameAtom)
                _g = 0
                _g1 = arityVal
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    newStru.addArg(blub_prolog_terms_Reference())
                newTerm = newStru
            engine.unify(term,newTerm)
            return
        termAtom = term.asAtom()
        if (termAtom is not None):
            if (not engine.unify(name,termAtom)):
                return
            engine.unify(arity,blub_prolog_terms_NumberTerm(0))
            return
        termStru = term.asStructure()
        if (termStru is not None):
            if (not engine.unify(name,termStru.getName())):
                return
            engine.unify(arity,blub_prolog_terms_NumberTerm(termStru.getArity()))
            return
        engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_compound,term,engine.context))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Functor"] = blub_prolog_builtins_Functor


class blub_prolog_builtins_ListSlice(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.ListSlice"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("list_slice",3)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env)
        b = (args[1] if 1 < len(args) else None).toValue(env)
        c = (args[2] if 2 < len(args) else None).toValue(env)
        listA = a.asStructure()
        listB = b.asStructure()
        listC = c.asReference()
        if (listA is None):
            emptyA = a.asAtom()
            if ((emptyA is not None) and ((emptyA == blub_prolog_terms_Structure.EMPTY_LIST))):
                engine.unify(blub_prolog_terms_Structure.EMPTY_LIST,c)
                return
        if (listB is None):
            emptyB = b.asAtom()
            if ((emptyB is not None) and ((emptyB == blub_prolog_terms_Structure.EMPTY_LIST))):
                engine.unify(a,c)
                return
        if (((listA is None) or ((listB is None))) or ((listC is None))):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom("list_slice/3 requires (In,In,Out)"),engine.context))
            return
        elems = list()
        s = listA.listStructureIterator()
        while s.hasNext():
            s1 = s.next()
            if (s1 == listB):
                break
            x = s1.argAt(0)
            elems.append(x)
        engine.unify(blub_prolog_terms_Structure.makeList(elems),listC)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.ListSlice"] = blub_prolog_builtins_ListSlice


class blub_prolog_builtins_Stack(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Stack"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("stack",2)

    def execute(self,engine,args):
        env = engine.environment
        h = (args[0] if 0 < len(args) else None).toValue(env)
        t = (args[1] if 1 < len(args) else None).toValue(env)
        headRef = h.asReference()
        tailRef = t.asReference()
        if ((headRef is None) or ((tailRef is None))):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_variable,(h if ((headRef is None)) else t),engine.context))
            return
        head = blub_prolog_builtins__Stack_StackHead()
        tail = blub_prolog_builtins__Stack_StackTail(head)
        engine.unify(headRef,head)
        engine.unify(tailRef,tail)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Stack"] = blub_prolog_builtins_Stack


class blub_prolog_builtins_Member(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Member"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("member",2)

    def execute(self,engine,args):
        env = engine.environment
        elem = (args[0] if 0 < len(args) else None).toValue(env)
        _hx_list = (args[1] if 1 < len(args) else None).toValue(env)
        cp = blub_prolog_builtins_MemberChoicePoint(engine,blub_prolog_engine_parts_CodeFrame(engine),elem,_hx_list)
        engine.processBuiltinChoices()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Member"] = blub_prolog_builtins_Member


class blub_prolog_builtins_Listing(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.Listing"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("listing",0)

    def execute(self,engine,args):
        def _hx_local_0(s):
            haxe_Log.trace(s,_hx_AnonObject({'fileName': "src/blub/prolog/builtins/Listing.hx", 'lineNumber': 15, 'className': "blub.prolog.builtins.Listing", 'methodName': "execute"}))
        engine.database.listing(_hx_local_0)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.Listing"] = blub_prolog_builtins_Listing


class blub_prolog_builtins_ThrowUp(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.ThrowUp"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("throw_up",1)

    def execute(self,engine,args):
        env = engine.environment
        raise haxe_Exception.thrown(blub_prolog_PrologException((args[0] if 0 < len(args) else None).toValue(env).dereference(),engine.context))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.ThrowUp"] = blub_prolog_builtins_ThrowUp


class blub_prolog_builtins_TermTypes(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.TermTypes"
    __slots__ = ("fn",)
    _hx_fields = ["fn"]
    _hx_methods = ["execute"]
    _hx_statics = ["get"]
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self,functor,fn):
        self.fn = None
        super().__init__(functor,1)
        self.fn = fn

    def execute(self,engine,args):
        env = engine.environment
        term = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        if (not self.fn(term)):
            engine.fail()

    @staticmethod
    def get():
        def _hx_local_11():
            def _hx_local_0(t):
                return (t.asReference() is not None)
            def _hx_local_1(t):
                return (t.asReference() is None)
            def _hx_local_2(t):
                return (t.asNumber() is not None)
            def _hx_local_3(t):
                return (t.asAtom() is not None)
            def _hx_local_4(t):
                if (t.asAtom() is None):
                    return (t.asNumber() is not None)
                else:
                    return True
            def _hx_local_5(t):
                return (t.asStructure() is not None)
            def _hx_local_6(t):
                if (t.asAtom() is None):
                    return (t.asStructure() is not None)
                else:
                    return True
            def _hx_local_7(t):
                return t.isGround()
            def _hx_local_8(t):
                num = t.asNumber()
                if (num is None):
                    return False
                return Std.isOfType(num.value,Int)
            def _hx_local_9(t):
                empty = t.asAtom()
                if (empty is not None):
                    return empty.isList()
                _hx_str = t.asStructure()
                if (_hx_str is None):
                    return False
                return _hx_str.isList()
            def _hx_local_10(t):
                num = t.asNumber()
                if (num is None):
                    return False
                return (not Std.isOfType(num.value,Int))
            return [blub_prolog_builtins_TermTypes("var",_hx_local_0), blub_prolog_builtins_TermTypes("nonvar",_hx_local_1), blub_prolog_builtins_TermTypes("number",_hx_local_2), blub_prolog_builtins_TermTypes("atom",_hx_local_3), blub_prolog_builtins_TermTypes("atomic",_hx_local_4), blub_prolog_builtins_TermTypes("compound",_hx_local_5), blub_prolog_builtins_TermTypes("callable",_hx_local_6), blub_prolog_builtins_TermTypes("ground",_hx_local_7), blub_prolog_builtins_TermTypes("integer",_hx_local_8), blub_prolog_builtins_TermTypes("is_list",_hx_local_9), blub_prolog_builtins_TermTypes("float",_hx_local_10)]
        return _hx_local_11()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fn = None
_hx_classes["blub.prolog.builtins.TermTypes"] = blub_prolog_builtins_TermTypes


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "arrayJoin", "safeJoin", "isPyBool", "isPyInt", "isPyFloat", "isClass", "isAnonObject", "_add_dynamic", "toString", "toString1", "isMetaType", "fields", "isString", "isArray", "simpleField", "createClosure", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "unsafeFastCodeAt", "handleKeywords", "prefixLength", "unhandleKeywords", "implementsInterface"]

    @staticmethod
    def arrayJoin(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def safeJoin(x,sep):
        return sep.join([x1 for x1 in x])

    @staticmethod
    def isPyBool(o):
        return isinstance(o,bool)

    @staticmethod
    def isPyInt(o):
        if isinstance(o,int):
            return (not isinstance(o,bool))
        else:
            return False

    @staticmethod
    def isPyFloat(o):
        return isinstance(o,float)

    @staticmethod
    def isClass(o):
        if (o is not None):
            if not HxOverrides.eq(o,str):
                return python_lib_Inspect.isclass(o)
            else:
                return True
        else:
            return False

    @staticmethod
    def isAnonObject(o):
        return isinstance(o,_hx_AnonObject)

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,str) and isinstance(b,str)):
            return (a + b)
        if (isinstance(a,str) or isinstance(b,str)):
            return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
        return (a + b)

    @staticmethod
    def toString(o):
        return python_Boot.toString1(o,"")

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def isMetaType(v,t):
        return (v == t)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def isString(o):
        return isinstance(o,str)

    @staticmethod
    def isArray(o):
        return isinstance(o,list)

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def createClosure(obj,func):
        return python_internal_MethodClosure(obj,func)

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unsafeFastCodeAt(s,index):
        return ord(s[index])

    @staticmethod
    def handleKeywords(name):
        if (name in python_Boot.keywords):
            return ("_hx_" + name)
        elif ((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95))):
            return ("_hx_" + name)
        else:
            return name

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name

    @staticmethod
    def implementsInterface(value,cls):
        loop = None
        def _hx_local_1(intf):
            f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
            if (f is not None):
                _g = 0
                while (_g < len(f)):
                    i = (f[_g] if _g >= 0 and _g < len(f) else None)
                    _g = (_g + 1)
                    if (i == cls):
                        return True
                    else:
                        l = loop(i)
                        if l:
                            return True
                return False
            else:
                return False
        loop = _hx_local_1
        currentClass = value.__class__
        result = False
        while (currentClass is not None):
            if loop(currentClass):
                result = True
                break
            currentClass = python_Boot.getSuperClass(currentClass)
        return result
_hx_classes["python.Boot"] = python_Boot


class blub_prolog_builtins_Globals:
    _hx_class_name = "blub.prolog.builtins.Globals"
    __slots__ = ()
    _hx_statics = ["get"]

    @staticmethod
    def get():
        return [blub_prolog_builtins_GetGlobal(), blub_prolog_builtins_SetGlobal()]
_hx_classes["blub.prolog.builtins.Globals"] = blub_prolog_builtins_Globals


class blub_prolog_builtins_GetGlobal(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.GetGlobal"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("from_global",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        b = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        key = b.asAtom()
        if (b is None):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom("RHS of from_global must be atom key"),engine.context))
            return
        this1 = engine.database.globals
        key = b.asAtom().text
        value = this1.h.get(key,None)
        if (value is None):
            value = blub_prolog_AtomContext.GLOBALS.getAtom("null")
        engine.unify(a,value)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.GetGlobal"] = blub_prolog_builtins_GetGlobal


class blub_prolog_builtins_SetGlobal(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.SetGlobal"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("to_global",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        b = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        key = b.asAtom()
        if (b is None):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom("RHS of to_global must be atom key"),engine.context))
            return
        engine.database.globals.h[key.text] = a

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.SetGlobal"] = blub_prolog_builtins_SetGlobal


class blub_prolog_builtins_RebindVar(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.RebindVar"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute", "bind"]
    _hx_statics = ["get"]
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self,name):
        super().__init__(name,2)

    def execute(self,engine,args):
        env = engine.environment
        ref = (args[0] if 0 < len(args) else None).toValue(env)
        val = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        targetRef = ref.asUnchasedReference()
        if (targetRef is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_variable,ref,engine.context))
            return
        self.bind(targetRef,val,engine)

    def bind(self,targetRef,value,engine):
        targetRef.rebindLast(value)

    @staticmethod
    def get():
        return [blub_prolog_builtins_NonBacktrackingRebindVar(), blub_prolog_builtins_BacktrackingRebindVar(), blub_prolog_builtins_NonBacktrackingArithmeticRebind(), blub_prolog_builtins_BacktrackingArithmeticRebind()]

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.RebindVar"] = blub_prolog_builtins_RebindVar


class blub_prolog_builtins_NonBacktrackingRebindVar(blub_prolog_builtins_RebindVar):
    _hx_class_name = "blub.prolog.builtins.NonBacktrackingRebindVar"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_RebindVar


    def __init__(self):
        super().__init__("<=")
_hx_classes["blub.prolog.builtins.NonBacktrackingRebindVar"] = blub_prolog_builtins_NonBacktrackingRebindVar


class blub_prolog_builtins_BacktrackingRebindVar(blub_prolog_builtins_RebindVar):
    _hx_class_name = "blub.prolog.builtins.BacktrackingRebindVar"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["bind"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_RebindVar


    def __init__(self):
        super().__init__("<=&")

    def bind(self,targetRef,value,engine):
        targetRef.rebindLast(value,engine)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.BacktrackingRebindVar"] = blub_prolog_builtins_BacktrackingRebindVar


class blub_prolog_builtins_ArithmeticRebind(blub_prolog_builtins_RebindVar):
    _hx_class_name = "blub.prolog.builtins.ArithmeticRebind"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["bind", "bindNum"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_RebindVar


    def __init__(self,name):
        super().__init__(name)

    def bind(self,targetRef,value,engine):
        num = value.asNumber()
        if (num is None):
            num = blub_prolog_terms_NumberTerm(engine.get_arithmetic().evaluate(value))
        self.bindNum(targetRef,num,engine)

    def bindNum(self,targetRef,value,engine):
        targetRef.rebindLast(value)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.ArithmeticRebind"] = blub_prolog_builtins_ArithmeticRebind


class blub_prolog_builtins_NonBacktrackingArithmeticRebind(blub_prolog_builtins_ArithmeticRebind):
    _hx_class_name = "blub.prolog.builtins.NonBacktrackingArithmeticRebind"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_ArithmeticRebind


    def __init__(self):
        super().__init__("<#")
_hx_classes["blub.prolog.builtins.NonBacktrackingArithmeticRebind"] = blub_prolog_builtins_NonBacktrackingArithmeticRebind


class blub_prolog_builtins_BacktrackingArithmeticRebind(blub_prolog_builtins_ArithmeticRebind):
    _hx_class_name = "blub.prolog.builtins.BacktrackingArithmeticRebind"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["bindNum"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_ArithmeticRebind


    def __init__(self):
        super().__init__("<#&")

    def bindNum(self,targetRef,value,engine):
        targetRef.rebindLast(value,engine)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.BacktrackingArithmeticRebind"] = blub_prolog_builtins_BacktrackingArithmeticRebind


class blub_prolog_builtins_objects_ObjectBuiltins:
    _hx_class_name = "blub.prolog.builtins.objects.ObjectBuiltins"
    __slots__ = ()
    _hx_statics = ["get"]

    @staticmethod
    def get():
        return [blub_prolog_builtins_objects_DotAccessor(), blub_prolog_builtins_objects_ArrowAssigner()]
_hx_classes["blub.prolog.builtins.objects.ObjectBuiltins"] = blub_prolog_builtins_objects_ObjectBuiltins


class blub_prolog_builtins_objects_DotAccessor(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.objects.DotAccessor"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = ["evalDot", "eval", "makeArgs"]
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__(".",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        b = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        blub_prolog_builtins_objects_DotAccessor.evalDot(engine,a,b)

    @staticmethod
    def evalDot(engine,termA,termB):
        stru = termA.asStructure()
        if (((stru is not None) and ((stru.getName().text == "."))) and ((stru.getArity() == 2))):
            termA = blub_prolog_Marshal.valueToTerm(blub_prolog_builtins_objects_DotAccessor.evalDot(engine,stru.argAt(0),stru.argAt(1)))
        atom = termA.asAtom()
        if (atom is None):
            raise haxe_Exception.thrown(((((("is not an atom: " + Std.string(termA)) + " in ") + Std.string(termA)) + ".") + Std.string(termB)))
        if (atom.object is None):
            atom.object = blub_prolog_builtins_objects_HashObjectWrapper(atom)
        if (not Std.isOfType(atom.object,blub_prolog_builtins_objects_ObjectWrapper)):
            raise haxe_Exception.thrown(((((("is not an atom wrapping a native object: " + Std.string(termA)) + " in ") + Std.string(termA)) + ".") + Std.string(termB)))
        wrapper = atom.object
        nameAtom = termB.asAtom()
        if (nameAtom is not None):
            name = nameAtom.text
            return wrapper.getProperty(name)
        method = termB.asStructure()
        if (method is not None):
            args = blub_prolog_builtins_objects_DotAccessor.makeArgs(engine,method.getArgs())
            return wrapper.callMethod(method.getName().text,args)
        raise haxe_Exception.thrown(((((("is not a field name or method call: " + Std.string(termB)) + " in ") + Std.string(termA)) + ".") + Std.string(termB)))

    @staticmethod
    def eval(engine,expr):
        stru = expr.asStructure()
        if (stru is not None):
            if ((stru.getArity() == 1) and ((stru.getNameText() == "term"))):
                return stru.argAt(0)
            if blub_prolog_engine_ArithmeticEvaluator.isArithmetic(stru):
                return engine.get_arithmetic().evalFunc(stru)
            if ((stru.getName().text == ".") and ((stru.getArity() == 2))):
                return blub_prolog_builtins_objects_DotAccessor.evalDot(engine,stru.argAt(0),stru.argAt(1))
            else:
                className = stru.getName().text
                clazz = Type.resolveClass(className)
                if (clazz is None):
                    raise haxe_Exception.thrown(("Could not find class " + ("null" if className is None else className)))
                args = blub_prolog_builtins_objects_DotAccessor.makeArgs(engine,stru.getArgs())
                return clazz(*args)
        return blub_prolog_Marshal.termToValue(expr)

    @staticmethod
    def makeArgs(engine,terms):
        args = list()
        if (len(terms) == 1):
            arg1 = (terms[0] if 0 < len(terms) else None).asAtom()
            if ((arg1 is not None) and ((arg1.text == "void"))):
                return args
        _g = 0
        while (_g < len(terms)):
            t = (terms[_g] if _g >= 0 and _g < len(terms) else None)
            _g = (_g + 1)
            x = blub_prolog_builtins_objects_DotAccessor.eval(engine,t.asValueTerm())
            args.append(x)
        return args

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.objects.DotAccessor"] = blub_prolog_builtins_objects_DotAccessor


class blub_prolog_builtins_objects_ArrowAssigner(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.objects.ArrowAssigner"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("<-",2)

    def execute(self,engine,args):
        env = engine.environment
        a = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        b = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        value = None
        try:
            value = blub_prolog_builtins_objects_DotAccessor.eval(engine,b)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom(Std.string(e)),engine.context))
            return
        if (a.asReference() is not None):
            valTerm = blub_prolog_Marshal.valueToTerm(value)
            engine.unify(a,valTerm)
            return
        target = a.asStructure()
        if (((target is None) or ((target.getName().text != "."))) or ((target.getArity() != 2))):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom(("target of <- must be a var or dot-accessor: " + HxOverrides.stringOrNull(a.toString()))),engine.context))
            return
        atom = None
        lhsRef = target.argAt(0).asReference()
        if (lhsRef is not None):
            atom = blub_prolog_Marshal.newAtom()
            engine.unify(lhsRef,atom)
        else:
            atom = target.argAt(0).asAtom()
        if (atom is None):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom(((("is not an atom: " + Std.string(target.argAt(0))) + " in ") + HxOverrides.stringOrNull(target.toString()))),engine.context))
            return
        if (atom.object is None):
            atom.object = blub_prolog_builtins_objects_HashObjectWrapper(atom)
        if (not Std.isOfType(atom.object,blub_prolog_builtins_objects_ObjectWrapper)):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom(((("is not an atom wrapping a native object: " + Std.string(atom)) + " in ") + HxOverrides.stringOrNull(target.toString()))),engine.context))
            return
        nameAtom = target.argAt(1).asAtom()
        if (nameAtom is None):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom(((("is not an atom representing a field name: " + Std.string(target.argAt(1))) + " in ") + HxOverrides.stringOrNull(target.toString()))),engine.context))
            return
        name = nameAtom.text
        wrapper = atom.object
        wrapper.setProperty(name,value)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.objects.ArrowAssigner"] = blub_prolog_builtins_objects_ArrowAssigner


class blub_prolog_builtins_async_AsyncBuiltins:
    _hx_class_name = "blub.prolog.builtins.async.AsyncBuiltins"
    __slots__ = ()
    _hx_statics = ["get"]

    @staticmethod
    def get():
        send = blub_prolog_builtins_async_messages_Send()
        receive = blub_prolog_builtins_async_messages_Receive(send.channels)
        return [blub_prolog_builtins_async_Sleep(), send, receive, blub_prolog_builtins_async_Spawn(), blub_prolog_builtins_async_Spawns(), blub_prolog_builtins_async_Stop()]
_hx_classes["blub.prolog.builtins.async.AsyncBuiltins"] = blub_prolog_builtins_async_AsyncBuiltins


class blub_prolog_builtins_async_messages_Send(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.async.messages.Send"
    __slots__ = ("channels",)
    _hx_fields = ["channels"]
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        self.channels = None
        super().__init__("send",2)
        self.channels = haxe_ds_StringMap()

    def execute(self,engine,args):
        env = engine.environment
        channel = (args[0] if 0 < len(args) else None).toValue(env).asAtom()
        msg = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        if (channel is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_atom,channel,engine.context))
        if msg.isGround():
            msgChannel = self.channels.h.get(channel.text,None)
            if (msgChannel is None):
                return
            msgChannel.send(msg)
            return
        engine.raiseException(blub_prolog_RuntimeError.instantiationError(engine.context))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.channels = None
_hx_classes["blub.prolog.builtins.async.messages.Send"] = blub_prolog_builtins_async_messages_Send


class blub_prolog_builtins_async_messages_Receive(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.async.messages.Receive"
    __slots__ = ("channels",)
    _hx_fields = ["channels"]
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self,channels):
        self.channels = None
        super().__init__("receive",2)
        self.channels = channels

    def execute(self,engine,args):
        env = engine.environment
        channel = (args[0] if 0 < len(args) else None).toValue(env).asAtom()
        msg = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        if (channel is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_atom,channel,engine.context))
        msgChannel = self.channels.h.get(channel.text,None)
        if (msgChannel is None):
            msgChannel = blub_prolog_builtins_async_messages_MessageChannel(channel.text,self.channels)
        listener = msgChannel.listen(engine,msg)
        def _hx_local_0():
            msgChannel.unlisten(listener)
        engine.beginAsync(blub_prolog_builtins_async_AsyncOperationImpl((((("receive(" + HxOverrides.stringOrNull(channel.text)) + ",") + Std.string(msg.toString)) + ")"),_hx_local_0))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.channels = None
_hx_classes["blub.prolog.builtins.async.messages.Receive"] = blub_prolog_builtins_async_messages_Receive


class blub_prolog_builtins_async_Sleep(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.async.Sleep"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("sleep",1)

    def execute(self,engine,args):
        env = engine.environment
        time = (args[0] if 0 < len(args) else None).toValue(env).asNumber()
        if (time is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_number,time,engine.context))
        x = time.value
        millis = None
        try:
            millis = int(x)
        except BaseException as _g:
            None
            millis = None
        engine.beginAsync(blub_prolog_builtins_async_AsyncOperationImpl((("sleep(" + Std.string(millis)) + ")"),None))
        def _hx_local_0():
            engine.continueAsync()
        haxe_Timer.delay(_hx_local_0,millis)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.async.Sleep"] = blub_prolog_builtins_async_Sleep


class blub_prolog_builtins_async_Spawn(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.async.Spawn"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("spawn",1)

    def execute(self,engine,args):
        env = engine.environment
        queryArg = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        stru = queryArg.asStructure()
        if (stru is not None):
            if (stru.getName().text == "{}"):
                queryArg = stru.argAt(0).asValueTerm()
                stru = queryArg.asStructure()
                if (stru is not None):
                    queryArg = stru.variablize()
            else:
                queryArg = stru.variablize()
        if (not Std.isOfType(queryArg,blub_prolog_terms_ClauseTerm)):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,queryArg,engine.context))
        query = blub_prolog_async_AsyncQuery(engine.database,queryArg)
        query.execute()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.async.Spawn"] = blub_prolog_builtins_async_Spawn


class blub_prolog_builtins_async_Spawns(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.async.Spawns"
    __slots__ = ("count",)
    _hx_fields = ["count"]
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        self.count = None
        super().__init__("spawns",2)
        self.count = 0

    def execute(self,engine,args):
        env = engine.environment
        ref = (args[0] if 0 < len(args) else None).toValue(env).asReference()
        queryArg = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        if (ref is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_variable,(args[0] if 0 < len(args) else None),engine.context))
        stru = queryArg.asStructure()
        if (stru is not None):
            if (stru.getName().text == "{}"):
                queryArg = stru.argAt(0).asValueTerm()
                stru = queryArg.asStructure()
                if (stru is not None):
                    queryArg = stru.variablize()
            else:
                queryArg = stru.variablize()
        if (not Std.isOfType(queryArg,blub_prolog_terms_ClauseTerm)):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,queryArg,engine.context))
        query = blub_prolog_async_AsyncQuery(engine.database,queryArg)
        query.execute()
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.count
            _hx_local_0.count = (_hx_local_1 + 1)
            return _hx_local_1
        atom = ("spawned-query#" + Std.string(_hx_local_2()))
        atom1 = blub_prolog_terms_Atom.unregisteredAtom(atom)
        atom1.object = query.get_engine()
        engine.unify(ref,atom1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.count = None
_hx_classes["blub.prolog.builtins.async.Spawns"] = blub_prolog_builtins_async_Spawns


class blub_prolog_builtins_async_Stop(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.async.Stop"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("stop",1)

    def execute(self,engine,args):
        env = engine.environment
        atom = (args[0] if 0 < len(args) else None).toValue(env).asAtom()
        if (atom is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_atom,(args[0] if 0 < len(args) else None),engine.context))
        if ((atom.object is None) or (not Std.isOfType(atom.object,blub_prolog_engine_QueryEngine))):
            engine.raiseException(blub_prolog_PrologException(blub_prolog_terms_Atom.unregisteredAtom(("atom must contain a spawned query: " + Std.string(atom))),engine.context))
            return
        eng2 = atom.object
        eng2.halt()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.async.Stop"] = blub_prolog_builtins_async_Stop


class blub_prolog_builtins_meta_MetaBuiltins:
    _hx_class_name = "blub.prolog.builtins.meta.MetaBuiltins"
    __slots__ = ()
    _hx_statics = ["get"]

    @staticmethod
    def get():
        return [blub_prolog_builtins_meta_MetaAbort(), blub_prolog_builtins_meta_MetaQuery(), blub_prolog_builtins_meta_MetaSolution()]
_hx_classes["blub.prolog.builtins.meta.MetaBuiltins"] = blub_prolog_builtins_meta_MetaBuiltins


class blub_prolog_builtins_meta_MetaAbort(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.meta.MetaAbort"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("abort",1)

    def execute(self,engine,args):
        env = engine.environment
        atom = (args[0] if 0 < len(args) else None).toValue(env).dereference().asAtom()
        if ((atom is None) or ((atom.object is None))):
            return
        if (not Std.isOfType(atom.object,blub_prolog_builtins_meta_TemplateQuery)):
            return
        query = atom.object
        query.halt()
        atom.object = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.meta.MetaAbort"] = blub_prolog_builtins_meta_MetaAbort


class blub_prolog_builtins_meta_MetaQuery(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.meta.MetaQuery"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("query",3)

    def execute(self,engine,args):
        env = engine.environment
        queryTerm = (args[0] if 0 < len(args) else None).toValue(env).dereference()
        template = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        queryVar = (args[2] if 2 < len(args) else None).toValue(env).dereference()
        if (queryVar.asReference() is None):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_variable,queryVar,engine.context))
            return
        if (not Std.isOfType(queryTerm,blub_prolog_terms_ClauseTerm)):
            engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_callable,queryTerm,engine.context))
            return
        queryClause = queryTerm
        query = blub_prolog_builtins_meta_TemplateQuery(engine,queryClause,template)
        atom = blub_prolog_terms_Atom.unregisteredAtom("query:")
        atom.object = query
        engine.unify(queryVar,atom)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.meta.MetaQuery"] = blub_prolog_builtins_meta_MetaQuery


class blub_prolog_builtins_meta_MetaSolution(blub_prolog_builtins_BuiltinPredicate):
    _hx_class_name = "blub.prolog.builtins.meta.MetaSolution"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["execute"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_BuiltinPredicate


    def __init__(self):
        super().__init__("solution",2)

    def execute(self,engine,args):
        env = engine.environment
        queryAtom = (args[0] if 0 < len(args) else None).toValue(env).dereference().asAtom()
        soln = (args[1] if 1 < len(args) else None).toValue(env).dereference()
        if (((queryAtom is None) or ((queryAtom.object is None))) or (not Std.isOfType(queryAtom.object,blub_prolog_builtins_meta_TemplateQuery))):
            engine.fail()
            return
        query = queryAtom.object
        if (not query.nextSolution(engine,soln)):
            engine.fail()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.meta.MetaSolution"] = blub_prolog_builtins_meta_MetaSolution


class blub_prolog_builtins_Builtins:
    _hx_class_name = "blub.prolog.builtins.Builtins"
    __slots__ = ()
    _hx_statics = ["register", "builtins"]

    @staticmethod
    def register(database):
        _g = 0
        _g1 = blub_prolog_builtins_Builtins.builtins
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.register(database)
_hx_classes["blub.prolog.builtins.Builtins"] = blub_prolog_builtins_Builtins


class blub_prolog_builtins_NotCallable:
    _hx_class_name = "blub.prolog.builtins.NotCallable"
    __slots__ = ("culprit",)
    _hx_fields = ["culprit"]

    def __init__(self,culprit):
        self.culprit = culprit

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.culprit = None
_hx_classes["blub.prolog.builtins.NotCallable"] = blub_prolog_builtins_NotCallable


class blub_prolog_compiler_CompilerBase:
    _hx_class_name = "blub.prolog.compiler.CompilerBase"
    __slots__ = ("database", "instructions")
    _hx_fields = ["database", "instructions"]
    _hx_methods = ["assemble", "clauseTerm", "compileTerm", "compileNestedTerm", "compileConjunction", "compileDisjunction", "compileOther", "add", "logOp"]
    _hx_statics = ["ADD_LOGGING"]

    def __init__(self,database):
        self.database = database
        self.instructions = list()

    def assemble(self):
        asm = blub_prolog_compiler_Assembler(self.database)
        asm.translateList(self.instructions)
        return asm.operations

    def clauseTerm(self,term):
        if (not Std.isOfType(term,blub_prolog_terms_ClauseTerm)):
            raise haxe_Exception.thrown(blub_prolog_PrologError(("Bad clause term: " + Std.string(term))))
        return term

    def compileTerm(self,term,tail = None):
        if (tail is None):
            tail = False
        stru = term.asStructure()
        args = None
        if (stru is not None):
            _g = term.getIndicator().toString()
            if (_g == ",/2"):
                self.compileConjunction(stru,tail)
                return
            elif (_g == ";/2"):
                self.compileDisjunction(stru,tail)
                return
            else:
                pass
            args = stru.getArgs()
        pred = self.database.lookup(term.getIndicator())
        if (pred is not None):
            if pred.isBuiltin:
                pred.builtin.compile(self,pred,term)
                if tail:
                    self.add(blub_prolog_compiler_Instruction.succeed)
                return
        if tail:
            self.add(blub_prolog_compiler_Instruction.tail_call(term.getIndicator().toString(),args))
        else:
            self.add(blub_prolog_compiler_Instruction.call_pred(term.getIndicator().toString(),args))

    def compileNestedTerm(self,term,cutBarrier = None):
        if (cutBarrier is None):
            cutBarrier = False
        nestedCode = self.compileOther(self.clauseTerm(term),True)
        if cutBarrier:
            nestedCode.insert(0, blub_prolog_compiler_Instruction.cut_point)
        self.add(blub_prolog_compiler_Instruction.call_nested(nestedCode))

    def compileConjunction(self,stru,tail = None):
        if (tail is None):
            tail = False
        t1 = self.clauseTerm(stru.argAt(0))
        t2 = self.clauseTerm(stru.argAt(1))
        t1s = t1.asStructure()
        if ((t1s is not None) and t1s.isDisjunction()):
            self.compileNestedTerm(t1)
        else:
            self.compileTerm(t1,False)
        self.compileTerm(t2,tail)

    def compileDisjunction(self,stru,tail = None):
        if (tail is None):
            tail = False
        t1 = self.clauseTerm(stru.argAt(0))
        t2 = self.clauseTerm(stru.argAt(1))
        alternative = self.compileOther(t2,tail)
        self.add(blub_prolog_compiler_Instruction.choice_point(alternative))
        self.compileTerm(t1,tail)

    def compileOther(self,term,tail = None):
        if (tail is None):
            tail = False
        altCompiler = blub_prolog_compiler_CompilerBase(self.database)
        altCompiler.compileTerm(term,tail)
        return altCompiler.instructions

    def add(self,instruction):
        _this = self.instructions
        _this.append(instruction)

    def logOp(self,msg):
        if blub_prolog_compiler_CompilerBase.ADD_LOGGING:
            self.add(blub_prolog_compiler_Instruction.log(msg))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.database = None
        _hx_o.instructions = None
_hx_classes["blub.prolog.compiler.CompilerBase"] = blub_prolog_compiler_CompilerBase


class blub_prolog_builtins_CallCompiler(blub_prolog_compiler_CompilerBase):
    _hx_class_name = "blub.prolog.builtins.CallCompiler"
    __slots__ = ("eng",)
    _hx_fields = ["eng"]
    _hx_methods = ["compileCall", "clauseTerm"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_compiler_CompilerBase


    def __init__(self,engine):
        self.eng = None
        super().__init__(engine.database)
        self.eng = engine

    def compileCall(self,term):
        clause = self.clauseTerm(term)
        stru = clause.asStructure()
        self.compileTerm(clause,True)
        return self.assemble()

    def clauseTerm(self,term):
        if (not Std.isOfType(term,blub_prolog_terms_ClauseTerm)):
            raise haxe_Exception.thrown(blub_prolog_builtins_NotCallable(term))
        return term

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.eng = None
_hx_classes["blub.prolog.builtins.CallCompiler"] = blub_prolog_builtins_CallCompiler


class blub_prolog_builtins_MemberChoicePoint(blub_prolog_engine_parts_ChoicePoint):
    _hx_class_name = "blub.prolog.builtins.MemberChoicePoint"
    __slots__ = ("clause", "arg1", "arg2")
    _hx_fields = ["clause", "arg1", "arg2"]
    _hx_methods = ["clause1", "clause2", "nextChoice", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_engine_parts_ChoicePoint


    def __init__(self,eng,frame,arg1,arg2):
        self.arg2 = None
        self.arg1 = None
        self.clause = None
        super().__init__(eng,frame)
        self.arg1 = arg1
        self.arg2 = arg2
        self.clause = 0

    def clause1(self):
        param2 = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST)
        param2.addArg(self.arg1)
        param2.addArg(blub_prolog_terms_Reference())
        result = param2.unify(self.arg2,self.engine)
        return result

    def clause2(self):
        refB = blub_prolog_terms_Reference()
        param2 = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST)
        param2.addArg(blub_prolog_terms_Reference())
        param2.addArg(refB)
        result = param2.unify(self.arg2,self.engine)
        if result:
            blub_prolog_builtins_MemberChoicePoint(self.engine,self.frame,self.arg1,refB)

    def nextChoice(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.clause
        _hx_local_0.clause = (_hx_local_1 + 1)
        _hx_local_1
        _g = self.clause
        if (_g == 1):
            if self.clause1():
                self.frame.restore()
                return True
            else:
                return False
        elif (_g == 2):
            self.clause2()
            return False
        else:
            self.popThisChoicePoint()
            return False

    def toString(self):
        return (((((("member/2 [" + Std.string(((self.clause + 1)))) + "] (") + Std.string(self.arg1)) + ",") + Std.string(self.arg2)) + ")")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.clause = None
        _hx_o.arg1 = None
        _hx_o.arg2 = None
_hx_classes["blub.prolog.builtins.MemberChoicePoint"] = blub_prolog_builtins_MemberChoicePoint


class blub_prolog_terms_Term:
    _hx_class_name = "blub.prolog.terms.Term"
    __slots__ = ()
    _hx_methods = ["toString", "equals", "isGround", "hasReferences", "hasVariables", "toValue", "asReference", "asUnchasedReference", "asAtom", "asStructure", "asNumber", "asValueTerm", "commaSeparated", "couldMatch", "match"]
_hx_classes["blub.prolog.terms.Term"] = blub_prolog_terms_Term


class blub_prolog_terms_ValueTerm:
    _hx_class_name = "blub.prolog.terms.ValueTerm"
    __slots__ = ()
    _hx_methods = ["unify", "dereference", "gatherReferences"]
    _hx_interfaces = [blub_prolog_terms_Term]
_hx_classes["blub.prolog.terms.ValueTerm"] = blub_prolog_terms_ValueTerm


class blub_prolog_terms_Reference:
    _hx_class_name = "blub.prolog.terms.Reference"
    __slots__ = ("name", "reference", "_name")
    _hx_fields = ["reference", "_name"]
    _hx_methods = ["asAtom_nochase", "asStructure_nochase", "asNumber_nochase", "asReference_nochase", "asValueTerm", "asAtom", "asStructure", "asNumber", "asReference", "asUnchasedReference", "commaSeparated", "gatherReferences", "isGround", "hasReferences", "hasVariables", "toValue", "toString", "match", "equals", "get_name", "couldMatch", "unify", "bind", "unbind", "rebindLast", "rebind", "chaseReferences", "dereference", "dereferenceReferences"]
    _hx_statics = ["nameGen"]
    _hx_interfaces = [blub_prolog_terms_ValueTerm]

    def __init__(self,name = None):
        self.name = None
        self.reference = None
        self._name = name

    def asAtom_nochase(self):
        if (self.reference is None):
            return None
        else:
            return self.reference.asAtom()

    def asStructure_nochase(self):
        if (self.reference is None):
            return None
        else:
            return self.reference.asStructure()

    def asNumber_nochase(self):
        if (self.reference is None):
            return None
        else:
            return self.reference.asNumber()

    def asReference_nochase(self):
        if (self.reference is None):
            return self
        else:
            return None

    def asValueTerm(self):
        return self

    def asAtom(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        return ref.asAtom_nochase()

    def asStructure(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        return ref.asStructure_nochase()

    def asNumber(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        return ref.asNumber_nochase()

    def asReference(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        return ref.asReference_nochase()

    def asUnchasedReference(self):
        return self

    def commaSeparated(self):
        if (self.reference is not None):
            return self.reference.commaSeparated()
        else:
            return [self]

    def gatherReferences(self,refs = None):
        if (self.reference is None):
            if (refs is None):
                return [self]
            refs.append(self)
            return refs
        return self.reference.gatherReferences(refs)

    def isGround(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        ref1 = ref
        val = ref1.reference
        if (val is not None):
            return val.isGround()
        return False

    def hasReferences(self):
        return True

    def hasVariables(self):
        return False

    def toValue(self,env):
        return self

    def toString(self):
        val = self.dereference()
        if (val == self):
            return ("_" + HxOverrides.stringOrNull(self.get_name()))
        else:
            return ((HxOverrides.stringOrNull(self.get_name()) + "=") + HxOverrides.stringOrNull(val.toString()))

    def match(self,other,env,trail):
        val = self.dereference()
        if (val == self):
            if (trail is not None):
                trail.newBinding(self,self.reference)
            self.bind(other)
            return True
        else:
            return val.equals(other)

    def equals(self,other):
        if (self == other):
            return True
        otherVal = other.asValueTerm()
        if (otherVal is None):
            return False
        otherVal = otherVal.dereference()
        thisVal = self.dereference()
        otherRef = otherVal.asReference()
        thisRef = thisVal.asReference()
        if ((otherRef is not None) and ((thisRef is not None))):
            return (otherRef == thisRef)
        if ((otherRef is not None) or ((thisRef is not None))):
            return False
        return thisVal.equals(otherVal)

    def get_name(self):
        if (self._name is None):
            def _hx_local_2():
                _hx_local_0 = blub_prolog_terms_Reference
                _hx_local_1 = _hx_local_0.nameGen
                _hx_local_0.nameGen = (_hx_local_1 + 1)
                return _hx_local_1
            self._name = ("V_" + Std.string(_hx_local_2()))
        return self._name

    def couldMatch(self,arg):
        return False

    def unify(self,other,trail):
        here = self.dereferenceReferences()
        hereRef = here.asReference()
        thereRef = other.asReference()
        there = (thereRef.dereferenceReferences() if ((thereRef is not None)) else other)
        thereRef = there.asReference()
        if ((hereRef is None) and ((thereRef is None))):
            return here.unify(there,trail)
        ref = None
        value = None
        if (hereRef is not None):
            ref = hereRef
            value = there
        else:
            ref = thereRef
            value = here
        if (trail is not None):
            trail.newBinding(ref,ref.reference)
        ref = ref.bind(value)
        return True

    def bind(self,term,allowRebinding = None):
        if (allowRebinding is None):
            allowRebinding = False
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        target = ref
        if ((target.reference is not None) and (not allowRebinding)):
            raise haxe_Exception.thrown(("Cannot bind already bound var " + HxOverrides.stringOrNull(target.toString())))
        if (target == term):
            return target
        target.reference = term
        return target

    def unbind(self,oldValue):
        self.reference = oldValue

    def rebindLast(self,value,trail = None):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        ref1 = ref
        if (trail is not None):
            trail.newBinding(ref1,ref1.reference)
        ref1.rebind(value)

    def rebind(self,value):
        self.reference = value

    def chaseReferences(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        return ref

    def dereference(self):
        if (self.reference is None):
            return self
        return self.reference.dereference()

    def dereferenceReferences(self):
        ref = self
        val = self.reference
        while (val is not None):
            nextRef = val.asUnchasedReference()
            if (nextRef is not None):
                ref = nextRef
                val = ref.reference
            else:
                break
        ref1 = ref
        if (ref1.reference is None):
            return ref1
        return ref1.reference

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.reference = None
        _hx_o._name = None
_hx_classes["blub.prolog.terms.Reference"] = blub_prolog_terms_Reference


class blub_prolog_builtins__Stack_StackTail(blub_prolog_terms_Reference):
    _hx_class_name = "blub.prolog.builtins._Stack.StackTail"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["bind", "unbind"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_terms_Reference


    def __init__(self,head):
        self.head = None
        super().__init__()
        self.head = head

    def bind(self,term,allowRebinding = None):
        if (allowRebinding is None):
            allowRebinding = False
        ref = term.asReference()
        if (ref is not None):
            ref.reference = self
            return ref
        self.head.push(term)
        return self

    def unbind(self,oldValue):
        self.head.pop()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.head = None
_hx_classes["blub.prolog.builtins._Stack.StackTail"] = blub_prolog_builtins__Stack_StackTail


class blub_prolog_terms_ValueTermImpl:
    _hx_class_name = "blub.prolog.terms.ValueTermImpl"
    __slots__ = ()
    _hx_methods = ["toValue", "equals", "toString", "isGround", "hasReferences", "hasVariables", "asReference", "asUnchasedReference", "asAtom", "asStructure", "asNumber", "couldMatch", "commaSeparated", "unify", "match", "dereference", "asValueTerm", "gatherReferences"]
    _hx_interfaces = [blub_prolog_terms_ValueTerm]

    def __init__(self):
        pass

    def toValue(self,env):
        return self

    def equals(self,other):
        return (self == other)

    def toString(self):
        return "<ValueTermImpl>"

    def isGround(self):
        return True

    def hasReferences(self):
        return False

    def hasVariables(self):
        return False

    def asReference(self):
        return None

    def asUnchasedReference(self):
        return None

    def asAtom(self):
        return None

    def asStructure(self):
        return None

    def asNumber(self):
        return None

    def couldMatch(self,arg):
        return False

    def commaSeparated(self):
        return [self]

    def unify(self,other,trail):
        return False

    def match(self,other,env,trail):
        return False

    def dereference(self):
        return self

    def asValueTerm(self):
        return self

    def gatherReferences(self,refs = None):
        return []

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.terms.ValueTermImpl"] = blub_prolog_terms_ValueTermImpl


class blub_prolog_terms_ClauseTerm:
    _hx_class_name = "blub.prolog.terms.ClauseTerm"
    __slots__ = ()
    _hx_methods = ["getIndicator", "getHead", "getBody", "getNameText", "getFunctor", "getArgs"]
    _hx_interfaces = [blub_prolog_terms_ValueTerm]
_hx_classes["blub.prolog.terms.ClauseTerm"] = blub_prolog_terms_ClauseTerm


class blub_prolog_terms_ClauseTermImpl(blub_prolog_terms_ValueTermImpl):
    _hx_class_name = "blub.prolog.terms.ClauseTermImpl"
    __slots__ = ("payload",)
    _hx_fields = ["payload"]
    _hx_methods = ["getIndicator", "getHead", "getBody", "getFunctor", "getArgs", "getNameText", "equals", "toString", "isGround", "hasReferences", "hasVariables", "asAtom", "asStructure", "couldMatch", "unify", "dereference"]
    _hx_statics = []
    _hx_interfaces = [blub_prolog_terms_ClauseTerm]
    _hx_super = blub_prolog_terms_ValueTermImpl


    def __init__(self,payload):
        self.payload = None
        super().__init__()
        self.payload = payload

    def getIndicator(self):
        return self.payload.getIndicator()

    def getHead(self):
        return self.payload.getHead()

    def getBody(self):
        return self.payload.getBody()

    def getFunctor(self):
        return self.payload.getFunctor()

    def getArgs(self):
        return self.payload.getArgs()

    def getNameText(self):
        return self.payload.getNameText()

    def equals(self,other):
        return self.payload.equals(other)

    def toString(self):
        return self.payload.toString()

    def isGround(self):
        return self.payload.isGround()

    def hasReferences(self):
        return self.payload.hasReferences()

    def hasVariables(self):
        return self.payload.hasVariables()

    def asAtom(self):
        return self.payload.asAtom()

    def asStructure(self):
        return self.payload.asStructure()

    def couldMatch(self,arg):
        return self.payload.couldMatch(arg)

    def unify(self,other,trail):
        return self.payload.unify(other,trail)

    def dereference(self):
        return self.payload.dereference()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.payload = None
_hx_classes["blub.prolog.terms.ClauseTermImpl"] = blub_prolog_terms_ClauseTermImpl


class blub_prolog_builtins__Stack_StackHead(blub_prolog_terms_ClauseTermImpl):
    _hx_class_name = "blub.prolog.builtins._Stack.StackHead"
    __slots__ = ("elems",)
    _hx_fields = ["elems"]
    _hx_methods = ["push", "pop"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_terms_ClauseTermImpl


    def __init__(self):
        self.elems = None
        super().__init__(blub_prolog_terms_Structure.EMPTY_LIST)
        self.elems = haxe_ds_List()

    def push(self,term):
        s = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST)
        s.addArg(term)
        s.addArg(blub_prolog_terms_Structure.EMPTY_LIST)
        s.forceHasRefs()
        if self.elems.isEmpty():
            self.payload = s
        else:
            python_internal_ArrayImpl._set(self.elems.first().getArgs(), 1, s)
        self.elems.push(s)

    def pop(self):
        if self.elems.isEmpty():
            return
        self.elems.pop()
        if self.elems.isEmpty():
            self.payload = blub_prolog_terms_Structure.EMPTY_LIST
            return
        python_internal_ArrayImpl._set(self.elems.first().getArgs(), 1, blub_prolog_terms_Structure.EMPTY_LIST)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.elems = None
_hx_classes["blub.prolog.builtins._Stack.StackHead"] = blub_prolog_builtins__Stack_StackHead


class blub_prolog_builtins_async_AsyncOperation:
    _hx_class_name = "blub.prolog.builtins.async.AsyncOperation"
    __slots__ = ()
    _hx_methods = ["cancel", "getDescription"]
_hx_classes["blub.prolog.builtins.async.AsyncOperation"] = blub_prolog_builtins_async_AsyncOperation


class blub_prolog_builtins_async_AsyncOperationImpl:
    _hx_class_name = "blub.prolog.builtins.async.AsyncOperationImpl"
    __slots__ = ("description", "cancelFn")
    _hx_fields = ["description", "cancelFn"]
    _hx_methods = ["cancel", "getDescription"]
    _hx_interfaces = [blub_prolog_builtins_async_AsyncOperation]

    def __init__(self,description,cancelFn):
        self.description = description
        self.cancelFn = cancelFn

    def cancel(self):
        if (self.cancelFn is not None):
            self.cancelFn()

    def getDescription(self):
        return self.description

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.description = None
        _hx_o.cancelFn = None
_hx_classes["blub.prolog.builtins.async.AsyncOperationImpl"] = blub_prolog_builtins_async_AsyncOperationImpl


class blub_prolog_builtins_async_messages_MessageChannel:
    _hx_class_name = "blub.prolog.builtins.async.messages.MessageChannel"
    __slots__ = ("name", "channels")
    _hx_fields = ["name", "channels"]
    _hx_methods = ["listen", "unlisten", "send"]

    def __init__(self,name,channels):
        self.name = name
        self.channels = channels
        channels.h[name] = self

    def listen(self,engine,term):
        return None

    def unlisten(self,token):
        if (token is None):
            return

    def send(self,msg):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.channels = None
_hx_classes["blub.prolog.builtins.async.messages.MessageChannel"] = blub_prolog_builtins_async_messages_MessageChannel


class blub_prolog_builtins_async_messages_MessageListener:
    _hx_class_name = "blub.prolog.builtins.async.messages.MessageListener"
    __slots__ = ("engine", "term")
    _hx_fields = ["engine", "term"]
    _hx_methods = ["receive"]

    def __init__(self,engine,term):
        self.engine = engine
        self.term = term

    def receive(self,msg):
        bindings = self.engine.bindings
        if (not self.term.unify(msg,self.engine)):
            _this = self.engine
            bind = _this.bindings
            while ((bind is not None) and ((bind != bindings))):
                bind.ref.unbind(bind.old)
                bind = bind.next
            _this.bindings = bindings
            return False
        self.engine.continueAsync()
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.term = None
_hx_classes["blub.prolog.builtins.async.messages.MessageListener"] = blub_prolog_builtins_async_messages_MessageListener


class blub_prolog_builtins_lazy_LazyLoadPredicates:
    _hx_class_name = "blub.prolog.builtins.lazy.LazyLoadPredicates"
    __slots__ = ("database", "preds")
    _hx_fields = ["database", "preds"]
    _hx_methods = ["load", "init"]

    def __init__(self,database):
        self.preds = None
        self.database = database
        self.init()

    def load(self,indicator):
        functor = indicator.toString()
        src = self.preds.h.get(functor,None)
        if (src is None):
            return False
        self.database.addPredicateSrc(functor,src)
        return True

    def init(self):
        self.preds = haxe_ds_StringMap()
        self.preds.h["map/3"] = " map(Predicate,List,Result) :- Goal =.. [Predicate,In,Out], findall(Out,(member(In,List),Goal),Result)."
        self.preds.h["append/3"] = "append([], L, L). append([X|Ll], L2, [X|L3]) :- append(Ll, L2, L3)."
        self.preds.h["findall/3"] = "findall(Template,Goal,Results) :- query(Goal,Template,Q),findall_gather(Q,Results)."
        self.preds.h["findall_gather/2"] = "findall_gather(Q,R) :- solution( Q, S ) -> R = [S|T], findall_gather(Q,T) ; R=[]."

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.database = None
        _hx_o.preds = None
_hx_classes["blub.prolog.builtins.lazy.LazyLoadPredicates"] = blub_prolog_builtins_lazy_LazyLoadPredicates


class blub_prolog_builtins_meta_TemplateQuery:
    _hx_class_name = "blub.prolog.builtins.meta.TemplateQuery"
    __slots__ = ("query", "template")
    _hx_fields = ["query", "template"]
    _hx_methods = ["halt", "nextSolution"]

    def __init__(self,engine,queryTerm,template):
        stru = queryTerm.asStructure()
        if (stru is not None):
            queryTerm = stru.variablize()
        self.query = blub_prolog_Query(engine.database,queryTerm)
        self.template = template.asValueTerm()
        if (stru is not None):
            env = self.query.get_engine().environment
            deref = queryTerm.toValue(env)
            stru.unify(deref,engine)

    def halt(self):
        self.query.get_engine()

    def nextSolution(self,engine,soln):
        result = self.query.nextSolution()
        if (result is None):
            return False
        tmp = result.index
        if (tmp == 0):
            return False
        elif (tmp == 1):
            return True
        elif (tmp == 2):
            b = result.params[0]
            captured = self.template.dereference()
            if (not soln.unify(captured,engine)):
                self.query.putBack(result)
                return False
            return True
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.query = None
        _hx_o.template = None
_hx_classes["blub.prolog.builtins.meta.TemplateQuery"] = blub_prolog_builtins_meta_TemplateQuery


class blub_prolog_builtins_objects_ObjectWrapper:
    _hx_class_name = "blub.prolog.builtins.objects.ObjectWrapper"
    __slots__ = ()
    _hx_methods = ["getProperty", "setProperty", "callMethod", "getObject", "addPropListener", "removePropListener"]
_hx_classes["blub.prolog.builtins.objects.ObjectWrapper"] = blub_prolog_builtins_objects_ObjectWrapper


class blub_prolog_builtins_objects_ObjectWrapperImpl:
    _hx_class_name = "blub.prolog.builtins.objects.ObjectWrapperImpl"
    __slots__ = ("atom", "object")
    _hx_fields = ["atom", "object"]
    _hx_methods = ["getProperty", "setProperty_final", "setProperty", "set", "callMethod", "getObject", "addPropListener", "removePropListener"]
    _hx_statics = ["capitalize"]
    _hx_interfaces = [blub_prolog_builtins_objects_ObjectWrapper]

    def __init__(self,object,atom):
        self.object = object
        self.atom = atom

    def getProperty(self,name):
        return Reflect.field(self.object,name)

    def setProperty_final(self,name,value):
        setattr(self.object,(("_hx_" + name) if ((name in python_Boot.keywords)) else (("_hx_" + name) if (((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95)))) else name)),value)

    def setProperty(self,name,value):
        self.set(name,value)

    def set(self,name,value):
        setattr(self.object,(("_hx_" + name) if ((name in python_Boot.keywords)) else (("_hx_" + name) if (((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95)))) else name)),value)

    def callMethod(self,name,args = None):
        if (args is None):
            args = []
        return Reflect.callMethod(self.object,Reflect.field(self.object,name),args)

    def getObject(self):
        return self.object

    def addPropListener(self,listener):
        return None

    def removePropListener(self,token):
        if (token is None):
            return

    @staticmethod
    def capitalize(name):
        if (len(name) < 2):
            return name.upper()
        return (HxOverrides.stringOrNull(HxString.substr(name,0,1).upper()) + HxOverrides.stringOrNull(HxString.substr(name,1,None)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.atom = None
        _hx_o.object = None
_hx_classes["blub.prolog.builtins.objects.ObjectWrapperImpl"] = blub_prolog_builtins_objects_ObjectWrapperImpl


class blub_prolog_builtins_objects_HashObjectWrapper(blub_prolog_builtins_objects_ObjectWrapperImpl):
    _hx_class_name = "blub.prolog.builtins.objects.HashObjectWrapper"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["getProperty", "set", "callMethod"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_builtins_objects_ObjectWrapperImpl


    def __init__(self,atom,hash = None):
        super().__init__((hash if ((hash is not None)) else haxe_ds_StringMap()),atom)

    def getProperty(self,name):
        return self.object.h.get(name,None)

    def set(self,name,value):
        self.object.h[name] = value

    def callMethod(self,name,args = None):
        prop = self.getProperty(name)
        if ((prop is not None) and Reflect.isFunction(prop)):
            return Reflect.callMethod(self.object,prop,args)
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.builtins.objects.HashObjectWrapper"] = blub_prolog_builtins_objects_HashObjectWrapper


class blub_prolog_builtins_objects_NativeAccess:
    _hx_class_name = "blub.prolog.builtins.objects.NativeAccess"
    __slots__ = ()
    _hx_methods = ["get", "set"]
_hx_classes["blub.prolog.builtins.objects.NativeAccess"] = blub_prolog_builtins_objects_NativeAccess


class blub_prolog_builtins_objects_PropertyListener:
    _hx_class_name = "blub.prolog.builtins.objects.PropertyListener"
    __slots__ = ()
    _hx_methods = ["propertyChanged"]
_hx_classes["blub.prolog.builtins.objects.PropertyListener"] = blub_prolog_builtins_objects_PropertyListener


class blub_prolog_compiler_Assembler:
    _hx_class_name = "blub.prolog.compiler.Assembler"
    __slots__ = ("operations", "db", "end")
    _hx_fields = ["operations", "db", "end"]
    _hx_methods = ["translateList", "transOther", "translate", "add"]
    _hx_statics = ["dumpInstruction", "dumpAsm", "traceDump"]

    def __init__(self,database):
        self.end = None
        self.operations = None
        self.db = database

    def translateList(self,instructions):
        _g = 0
        while (_g < len(instructions)):
            i = (instructions[_g] if _g >= 0 and _g < len(instructions) else None)
            _g = (_g + 1)
            self.translate(i)

    def transOther(self,instructions):
        asm = blub_prolog_compiler_Assembler(self.db)
        asm.translateList(instructions)
        return asm.operations

    def translate(self,i):
        tmp = i.index
        if (tmp == 0):
            args = i.params[1]
            functor = i.params[0]
            self.add(i,blub_prolog_engine_Operations.call_builtin(self.db,blub_prolog_PredicateIndicator.fromString(functor,self.db.context),args))
        elif (tmp == 1):
            args = i.params[1]
            functor = i.params[0]
            self.add(i,blub_prolog_engine_Operations.call_pred(self.db,blub_prolog_PredicateIndicator.fromString(functor,self.db.context),args))
        elif (tmp == 2):
            args = i.params[1]
            functor = i.params[0]
            self.add(i,blub_prolog_engine_Operations.tail_call(self.db,blub_prolog_PredicateIndicator.fromString(functor,self.db.context),args))
        elif (tmp == 3):
            functor = i.params[0]
            self.add(i,blub_prolog_engine_Operations.call_clauses(self.db,blub_prolog_PredicateIndicator.fromString(functor,self.db.context)))
        elif (tmp == 4):
            eIdx = i.params[1]
            aIdx = i.params[0]
            self.add(i,blub_prolog_engine_Operations.arg_to_env(aIdx,eIdx))
        elif (tmp == 5):
            terms = i.params[0]
            self.add(i,blub_prolog_engine_Operations.set_args(terms))
        elif (tmp == 6):
            terms = i.params[0]
            self.add(i,blub_prolog_engine_Operations.set_arg_values(terms))
        elif (tmp == 7):
            head = i.params[0]
            self.add(i,blub_prolog_engine_Operations.unify_args(head))
        elif (tmp == 8):
            term = i.params[1]
            index = i.params[0]
            self.add(i,blub_prolog_engine_Operations.unify_arg(index,term))
        elif (tmp == 9):
            alt = i.params[0]
            self.add(i,blub_prolog_engine_Operations.choice_point(self.transOther(alt)))
        elif (tmp == 10):
            code = i.params[0]
            self.add(i,blub_prolog_engine_Operations.call_nested(self.transOther(code)))
        elif (tmp == 11):
            size = i.params[0]
            self.add(i,blub_prolog_engine_Operations.new_environment(size))
        elif (tmp == 12):
            self.add(i,blub_prolog_engine_Operations.push_code_frame)
        elif (tmp == 13):
            self.add(i,blub_prolog_engine_Operations.pop_code_frame)
        elif (tmp == 14):
            self.add(i,blub_prolog_engine_Operations.succeed)
        elif (tmp == 15):
            self.add(i,blub_prolog_engine_Operations.no_op)
        elif (tmp == 16):
            self.add(i,blub_prolog_engine_Operations.fail)
        elif (tmp == 17):
            self.add(i,blub_prolog_engine_Operations.cut)
        elif (tmp == 18):
            self.add(i,blub_prolog_engine_Operations.cut_point)
        elif (tmp == 19):
            msg = i.params[0]
            self.add(i,blub_prolog_engine_Operations.log(msg))
        elif (tmp == 20):
            fn = i.params[0]
            self.add(i,blub_prolog_engine_Operations.call_back(fn))
        elif (tmp == 21):
            self.add(i,blub_prolog_engine_Operations.dump)
        elif (tmp == 22):
            self.add(i,blub_prolog_engine_Operations.halt)
        elif (tmp == 23):
            msg = i.params[0]
            self.add(i,blub_prolog_engine_Operations.debug_trace(msg))
        elif (tmp == 24):
            count = i.params[0]
            self.add(i,blub_prolog_engine_Operations.halt_count(count))
        else:
            pass

    def add(self,i,op):
        asm = None
        if (self.end is None):
            self.end = _hx_AnonObject({'op': op, 'asm': asm, 'next': None})
            self.operations = self.end
        else:
            elem = _hx_AnonObject({'op': op, 'asm': asm, 'next': None})
            self.end.next = elem
            self.end = elem

    @staticmethod
    def dumpInstruction(i,out,indent = None):
        if (indent is None):
            indent = ""
        tmp = i.index
        if (tmp == 0):
            args = i.params[1]
            functor = i.params[0]
            out(((((("null" if indent is None else indent) + "call_builtin ") + ("null" if functor is None else functor)) + " ") + Std.string(args)))
        elif (tmp == 1):
            args = i.params[1]
            functor = i.params[0]
            out(((((("null" if indent is None else indent) + "call_pred ") + ("null" if functor is None else functor)) + " ") + Std.string(args)))
        elif (tmp == 2):
            args = i.params[1]
            functor = i.params[0]
            out(((((("null" if indent is None else indent) + "tail_call ") + ("null" if functor is None else functor)) + " ") + Std.string(args)))
        elif (tmp == 3):
            functor = i.params[0]
            out(((("null" if indent is None else indent) + "call_clauses ") + ("null" if functor is None else functor)))
        elif (tmp == 4):
            eIdx = i.params[1]
            aIdx = i.params[0]
            out(((((("null" if indent is None else indent) + "arg_to_env ") + Std.string(aIdx)) + " ") + Std.string(eIdx)))
        elif (tmp == 5):
            terms = i.params[0]
            out(((("null" if indent is None else indent) + "set_args ") + Std.string(terms)))
        elif (tmp == 6):
            terms = i.params[0]
            out(((("null" if indent is None else indent) + "set_arg_values ") + Std.string(terms)))
        elif (tmp == 7):
            head = i.params[0]
            out(((("null" if indent is None else indent) + "unify_args ") + Std.string(head)))
        elif (tmp == 8):
            term = i.params[1]
            index = i.params[0]
            out(((((("null" if indent is None else indent) + "unify_arg ") + Std.string(index)) + " ") + Std.string(term)))
        elif (tmp == 9):
            alt = i.params[0]
            out((("null" if indent is None else indent) + "choice_point {"))
            blub_prolog_compiler_Assembler.dumpAsm(alt,out,(("null" if indent is None else indent) + ".   "))
            out((("null" if indent is None else indent) + "}"))
        elif (tmp == 10):
            code = i.params[0]
            out((("null" if indent is None else indent) + "call_nested {"))
            blub_prolog_compiler_Assembler.dumpAsm(code,out,(("null" if indent is None else indent) + ".   "))
            out((("null" if indent is None else indent) + "}"))
        elif (tmp == 11):
            size = i.params[0]
            out(((("null" if indent is None else indent) + "new_environment ") + Std.string(size)))
        elif (tmp == 12):
            out((("null" if indent is None else indent) + "push_code_frame"))
        elif (tmp == 13):
            out((("null" if indent is None else indent) + "pop_code_frame"))
        elif (tmp == 14):
            out((("null" if indent is None else indent) + "succeed"))
        elif (tmp == 15):
            out((("null" if indent is None else indent) + "no_op"))
        elif (tmp == 16):
            out((("null" if indent is None else indent) + "fail"))
        elif (tmp == 17):
            out((("null" if indent is None else indent) + "cut"))
        elif (tmp == 18):
            out((("null" if indent is None else indent) + "cut_point"))
        elif (tmp == 19):
            msg = i.params[0]
            out((((("null" if indent is None else indent) + "log '") + ("null" if msg is None else msg)) + "'"))
        elif (tmp == 20):
            fn = i.params[0]
            out(((("null" if indent is None else indent) + "call_back ") + Std.string(fn)))
        elif (tmp == 21):
            out((("null" if indent is None else indent) + "dump"))
        elif (tmp == 22):
            out((("null" if indent is None else indent) + "halt"))
        elif (tmp == 23):
            msg = i.params[0]
            out((((("null" if indent is None else indent) + "debug_trace '") + ("null" if msg is None else msg)) + "'"))
        elif (tmp == 24):
            count = i.params[0]
            out(((("null" if indent is None else indent) + "halt_count ") + Std.string(count)))
        else:
            pass

    @staticmethod
    def dumpAsm(instructions,out,indent = None):
        if (indent is None):
            indent = ""
        _g = 0
        while (_g < len(instructions)):
            i = (instructions[_g] if _g >= 0 and _g < len(instructions) else None)
            _g = (_g + 1)
            blub_prolog_compiler_Assembler.dumpInstruction(i,out,indent)

    @staticmethod
    def traceDump(instructions,prefix):
        traceCount = 0
        def _hx_local_1(msg):
            nonlocal traceCount
            traceCount = (traceCount + 1)
            haxe_Log.trace(msg,_hx_AnonObject({'methodName': None, 'lineNumber': (traceCount - 1), 'fileName': prefix, 'customParams': None, 'className': None}))
        out = _hx_local_1
        blub_prolog_compiler_Assembler.dumpAsm(instructions,out)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.operations = None
        _hx_o.db = None
        _hx_o.end = None
_hx_classes["blub.prolog.compiler.Assembler"] = blub_prolog_compiler_Assembler


class blub_prolog_compiler_ClauseCompiler(blub_prolog_compiler_CompilerBase):
    _hx_class_name = "blub.prolog.compiler.ClauseCompiler"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_compiler_CompilerBase


    def __init__(self,database):
        super().__init__(database)

    def compile(self,clause):
        if (clause.variableContext.get_count() > 0):
            self.add(blub_prolog_compiler_Instruction.new_environment(clause.variableContext.get_count()))
        head = clause.head
        if (head.getIndicator().arity > 0):
            self.add(blub_prolog_compiler_Instruction.unify_args(head))
        body = clause.body
        if (body is not None):
            self.compileTerm(body,True)
        else:
            self.add(blub_prolog_compiler_Instruction.succeed)
        return self.assemble()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.compiler.ClauseCompiler"] = blub_prolog_compiler_ClauseCompiler

class blub_prolog_compiler_Instruction(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.compiler.Instruction"
    _hx_constructs = ["call_builtin", "call_pred", "tail_call", "call_clauses", "arg_to_env", "set_args", "set_arg_values", "unify_args", "unify_arg", "choice_point", "call_nested", "new_environment", "push_code_frame", "pop_code_frame", "succeed", "no_op", "fail", "cut", "cut_point", "log", "call_back", "dump", "halt", "debug_trace", "halt_count"]

    @staticmethod
    def call_builtin(functor,args):
        return blub_prolog_compiler_Instruction("call_builtin", 0, (functor,args))

    @staticmethod
    def call_pred(functor,args):
        return blub_prolog_compiler_Instruction("call_pred", 1, (functor,args))

    @staticmethod
    def tail_call(functor,args):
        return blub_prolog_compiler_Instruction("tail_call", 2, (functor,args))

    @staticmethod
    def call_clauses(functor):
        return blub_prolog_compiler_Instruction("call_clauses", 3, (functor,))

    @staticmethod
    def arg_to_env(argIndex,envIndex):
        return blub_prolog_compiler_Instruction("arg_to_env", 4, (argIndex,envIndex))

    @staticmethod
    def set_args(terms):
        return blub_prolog_compiler_Instruction("set_args", 5, (terms,))

    @staticmethod
    def set_arg_values(terms):
        return blub_prolog_compiler_Instruction("set_arg_values", 6, (terms,))

    @staticmethod
    def unify_args(head):
        return blub_prolog_compiler_Instruction("unify_args", 7, (head,))

    @staticmethod
    def unify_arg(index,term):
        return blub_prolog_compiler_Instruction("unify_arg", 8, (index,term))

    @staticmethod
    def choice_point(alternative):
        return blub_prolog_compiler_Instruction("choice_point", 9, (alternative,))

    @staticmethod
    def call_nested(code):
        return blub_prolog_compiler_Instruction("call_nested", 10, (code,))

    @staticmethod
    def new_environment(size):
        return blub_prolog_compiler_Instruction("new_environment", 11, (size,))

    @staticmethod
    def log(msg):
        return blub_prolog_compiler_Instruction("log", 19, (msg,))

    @staticmethod
    def call_back(fn):
        return blub_prolog_compiler_Instruction("call_back", 20, (fn,))

    @staticmethod
    def debug_trace(msg):
        return blub_prolog_compiler_Instruction("debug_trace", 23, (msg,))

    @staticmethod
    def halt_count(count):
        return blub_prolog_compiler_Instruction("halt_count", 24, (count,))
blub_prolog_compiler_Instruction.push_code_frame = blub_prolog_compiler_Instruction("push_code_frame", 12, ())
blub_prolog_compiler_Instruction.pop_code_frame = blub_prolog_compiler_Instruction("pop_code_frame", 13, ())
blub_prolog_compiler_Instruction.succeed = blub_prolog_compiler_Instruction("succeed", 14, ())
blub_prolog_compiler_Instruction.no_op = blub_prolog_compiler_Instruction("no_op", 15, ())
blub_prolog_compiler_Instruction.fail = blub_prolog_compiler_Instruction("fail", 16, ())
blub_prolog_compiler_Instruction.cut = blub_prolog_compiler_Instruction("cut", 17, ())
blub_prolog_compiler_Instruction.cut_point = blub_prolog_compiler_Instruction("cut_point", 18, ())
blub_prolog_compiler_Instruction.dump = blub_prolog_compiler_Instruction("dump", 21, ())
blub_prolog_compiler_Instruction.halt = blub_prolog_compiler_Instruction("halt", 22, ())
_hx_classes["blub.prolog.compiler.Instruction"] = blub_prolog_compiler_Instruction


class blub_prolog_compiler_PredicateCompiler(blub_prolog_compiler_CompilerBase):
    _hx_class_name = "blub.prolog.compiler.PredicateCompiler"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_compiler_CompilerBase


    def __init__(self,database):
        super().__init__(database)

    def compile(self,predicate):
        self.add(blub_prolog_compiler_Instruction.call_clauses(predicate.indicator.toString()))
        return self.assemble()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.compiler.PredicateCompiler"] = blub_prolog_compiler_PredicateCompiler


class blub_prolog_compiler_QueryCompiler(blub_prolog_compiler_CompilerBase):
    _hx_class_name = "blub.prolog.compiler.QueryCompiler"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_compiler_CompilerBase


    def __init__(self,database):
        super().__init__(database)

    def compile(self,term):
        self.compileTerm(term,True)
        return self.assemble()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.compiler.QueryCompiler"] = blub_prolog_compiler_QueryCompiler


class blub_prolog_engine_ArithmeticEvaluator:
    _hx_class_name = "blub.prolog.engine.ArithmeticEvaluator"
    __slots__ = ("engine",)
    _hx_fields = ["engine"]
    _hx_methods = ["evaluate", "evalFunc"]
    _hx_statics = ["arithmeticFuncs", "isArithmetic", "isEvaluable", "hasAllNumericArgs"]

    def __init__(self,engine):
        self.engine = engine

    def evaluate(self,expression):
        numTerm = expression.asNumber()
        if (numTerm is not None):
            return numTerm.value
        stru = expression.asStructure()
        if (stru is not None):
            return self.evalFunc(stru)
        self.engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_evaluable,expression,self.engine.context))
        return 0.0

    def evalFunc(self,funcExpression):
        _g = funcExpression.getIndicator().toString()
        if (_g == "*/2"):
            return (self.evaluate(funcExpression.argAt(0)) * self.evaluate(funcExpression.argAt(1)))
        elif (_g == "+/2"):
            return (self.evaluate(funcExpression.argAt(0)) + self.evaluate(funcExpression.argAt(1)))
        elif (_g == "-/2"):
            return (self.evaluate(funcExpression.argAt(0)) - self.evaluate(funcExpression.argAt(1)))
        elif (_g == "./2"):
            val = blub_prolog_builtins_objects_DotAccessor.evalDot(self.engine,funcExpression.argAt(0),funcExpression.argAt(1))
            if Std.isOfType(val,Float):
                flt = val
                return flt
        elif (_g == "//2"):
            return (self.evaluate(funcExpression.argAt(0)) / self.evaluate(funcExpression.argAt(1)))
        else:
            pass
        self.engine.raiseException(blub_prolog_RuntimeError.typeError(blub_prolog_TypeError.VALID_TYPE_evaluable,funcExpression,self.engine.context))
        return 0.0

    @staticmethod
    def isArithmetic(struct):
        this1 = blub_prolog_engine_ArithmeticEvaluator.arithmeticFuncs
        key = struct.getIndicator().toString()
        return (this1.h.get(key,None) == True)

    @staticmethod
    def isEvaluable(t):
        if (t.asNumber() is not None):
            return True
        s = t.asStructure()
        if (s is None):
            return False
        return blub_prolog_engine_ArithmeticEvaluator.isArithmetic(s)

    @staticmethod
    def hasAllNumericArgs(s):
        _g = 0
        _g1 = s.getArgs()
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (a.asNumber() is None):
                return False
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
_hx_classes["blub.prolog.engine.ArithmeticEvaluator"] = blub_prolog_engine_ArithmeticEvaluator


class blub_prolog_engine_DatabaseTransaction:
    _hx_class_name = "blub.prolog.engine.DatabaseTransaction"
    __slots__ = ("database", "preAsserts", "postAsserts", "retractions", "abolitions")
    _hx_fields = ["database", "preAsserts", "postAsserts", "retractions", "abolitions"]
    _hx_methods = ["preAssert", "postAssert", "retract", "abolish", "commit"]

    def __init__(self,database):
        self.abolitions = None
        self.retractions = None
        self.postAsserts = None
        self.preAsserts = None
        self.database = database

    def preAssert(self,term):
        if (self.preAsserts is None):
            self.preAsserts = list()
        _this = self.preAsserts
        _this.append(term)

    def postAssert(self,term):
        if (self.postAsserts is None):
            self.postAsserts = list()
        _this = self.postAsserts
        _this.append(term)

    def retract(self,clause):
        if (self.retractions is None):
            self.retractions = list()
        _this = self.retractions
        _this.append(clause)

    def abolish(self,pred):
        if (self.abolitions is None):
            self.abolitions = list()
        _this = self.abolitions
        _this.append(pred)

    def commit(self):
        if (self.preAsserts is not None):
            _g = 0
            _g1 = self.preAsserts
            while (_g < len(_g1)):
                term = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.database.assertA(term,True)
        if (self.postAsserts is not None):
            _g = 0
            _g1 = self.postAsserts
            while (_g < len(_g1)):
                term = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.database.assertZ(term,True)
        if (self.retractions is not None):
            _g = 0
            _g1 = self.retractions
            while (_g < len(_g1)):
                clause = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                clause.retract()
        if (self.abolitions is not None):
            _g = 0
            _g1 = self.abolitions
            while (_g < len(_g1)):
                pred = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                pred.abolish()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.database = None
        _hx_o.preAsserts = None
        _hx_o.postAsserts = None
        _hx_o.retractions = None
        _hx_o.abolitions = None
_hx_classes["blub.prolog.engine.DatabaseTransaction"] = blub_prolog_engine_DatabaseTransaction


class blub_prolog_engine_Operations:
    _hx_class_name = "blub.prolog.engine.Operations"
    __slots__ = ()
    _hx_statics = ["halt_count", "unify_arg", "unify_args", "set_args", "arg_to_env", "set_arg_values", "call_clauses", "call_builtin", "call_pred", "tail_call", "choice_point", "succeed", "no_op", "fail", "cut", "cut_point", "log", "debug_trace", "call_back", "dump", "halt", "new_environment", "push_code_frame", "call_nested", "pop_code_frame", "jump_to"]

    @staticmethod
    def halt_count(count):
        i = 0
        def _hx_local_0(eng):
            nonlocal i
            if (i >= count):
                eng.halt()
            i = (i + 1)
        return _hx_local_0

    @staticmethod
    def unify_arg(index,term):
        def _hx_local_0(eng):
            eng.unify(term.toValue(eng.environment),(eng.arguments[index] if index >= 0 and index < len(eng.arguments) else None))
        return _hx_local_0

    @staticmethod
    def unify_args(head):
        def _hx_local_0(eng):
            stru = head.asStructure()
            if (stru is None):
                return
            headArgs = stru.getArgs()
            args = eng.arguments
            numArgs = len(args)
            env = eng.environment
            _g = 0
            _g1 = numArgs
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not eng.unify((headArgs[i] if i >= 0 and i < len(headArgs) else None).toValue(env),(args[i] if i >= 0 and i < len(args) else None))):
                    return
        return _hx_local_0

    @staticmethod
    def set_args(terms):
        def _hx_local_0(eng):
            if (terms is not None):
                args = list()
                env = eng.environment
                _g = 0
                while (_g < len(terms)):
                    t = (terms[_g] if _g >= 0 and _g < len(terms) else None)
                    _g = (_g + 1)
                    x = t.toValue(env)
                    args.append(x)
                eng.arguments = args
            else:
                eng.arguments = None
        return _hx_local_0

    @staticmethod
    def arg_to_env(argIndex,envIndex):
        def _hx_local_0(eng):
            (eng.environment[envIndex] if envIndex >= 0 and envIndex < len(eng.environment) else None).bind((eng.arguments[argIndex] if argIndex >= 0 and argIndex < len(eng.arguments) else None))
        return _hx_local_0

    @staticmethod
    def set_arg_values(terms):
        def _hx_local_0(eng):
            eng.arguments = terms
        return _hx_local_0

    @staticmethod
    def call_clauses(db,indicator):
        predicate = db.lookup(indicator)
        if (predicate is not None):
            def _hx_local_0(eng):
                clauses = predicate.findMatchingClauses(eng.arguments)
                _hx_len = len(clauses)
                if (_hx_len == 0):
                    eng.fail()
                else:
                    blub_prolog_engine_parts_ClauseChoices(eng,clauses)
            return _hx_local_0
        def _hx_local_1(eng):
            predicate = db.lookup(indicator)
            if (predicate is None):
                eng.raiseException(blub_prolog_RuntimeError.existenceError(blub_prolog_ExistenceError.ee_procedure,blub_prolog_terms_Atom.unregisteredAtom(indicator.toString()),eng.context))
                return
            clauses = predicate.findMatchingClauses(eng.arguments)
            _hx_len = len(clauses)
            if (_hx_len == 0):
                eng.fail()
            elif (_hx_len == 1):
                eng.context = (clauses[0] if 0 < len(clauses) else None)
                eng.codePointer = (clauses[0] if 0 < len(clauses) else None).code
            else:
                blub_prolog_engine_parts_ClauseChoices(eng,clauses)
        return _hx_local_1

    @staticmethod
    def call_builtin(db,indicator,args):
        predicate = db.lookup(indicator)
        if (predicate is not None):
            if predicate.isBuiltin:
                def _hx_local_0(eng):
                    predicate.builtin.execute(eng,args)
                return _hx_local_0
        raise haxe_Exception.thrown(blub_prolog_PrologError(("Cannot find built-in " + HxOverrides.stringOrNull(indicator.toString()))))

    @staticmethod
    def call_pred(db,indicator,args):
        predicate = db.lookup(indicator)
        if (predicate is not None):
            if predicate.isBuiltin:
                def _hx_local_0(eng):
                    predicate.builtin.execute(eng,args)
                return _hx_local_0
            else:
                def _hx_local_1(eng):
                    if (args is not None):
                        args1 = list()
                        env = eng.environment
                        _g = 0
                        while (_g < len(args)):
                            t = (args[_g] if _g >= 0 and _g < len(args) else None)
                            _g = (_g + 1)
                            x = t.toValue(env)
                            args1.append(x)
                        eng.arguments = args1
                    else:
                        eng.arguments = None
                    eng.codeStack = blub_prolog_engine_parts_CodeFrame(eng)
                    eng.codePointer = predicate.code
                return _hx_local_1
        def _hx_local_3(eng):
            predicate = db.lookup(indicator)
            if (predicate is None):
                eng.raiseException(blub_prolog_RuntimeError.existenceError(blub_prolog_ExistenceError.ee_procedure,blub_prolog_terms_Atom.unregisteredAtom(indicator.toString()),eng.context))
                return
            if (args is not None):
                args1 = list()
                env = eng.environment
                _g = 0
                while (_g < len(args)):
                    t = (args[_g] if _g >= 0 and _g < len(args) else None)
                    _g = (_g + 1)
                    x = t.toValue(env)
                    args1.append(x)
                eng.arguments = args1
            else:
                eng.arguments = None
            eng.codeStack = blub_prolog_engine_parts_CodeFrame(eng)
            eng.codePointer = predicate.code
        return _hx_local_3

    @staticmethod
    def tail_call(db,indicator,args):
        predicate = db.lookup(indicator)
        if (predicate is not None):
            def _hx_local_0(eng):
                if (args is not None):
                    args1 = list()
                    env = eng.environment
                    _g = 0
                    while (_g < len(args)):
                        t = (args[_g] if _g >= 0 and _g < len(args) else None)
                        _g = (_g + 1)
                        x = t.toValue(env)
                        args1.append(x)
                    eng.arguments = args1
                else:
                    eng.arguments = None
                eng.codePointer = predicate.code
            return _hx_local_0
        def _hx_local_2(eng):
            predicate = db.lookup(indicator)
            if (predicate is None):
                eng.raiseException(blub_prolog_RuntimeError.existenceError(blub_prolog_ExistenceError.ee_procedure,blub_prolog_terms_Atom.unregisteredAtom(indicator.toString()),eng.context))
                return
            if (args is not None):
                args1 = list()
                env = eng.environment
                _g = 0
                while (_g < len(args)):
                    t = (args[_g] if _g >= 0 and _g < len(args) else None)
                    _g = (_g + 1)
                    x = t.toValue(env)
                    args1.append(x)
                eng.arguments = args1
            else:
                eng.arguments = None
            eng.codePointer = predicate.code
        return _hx_local_2

    @staticmethod
    def choice_point(alternative):
        def _hx_local_0(eng):
            blub_prolog_engine_parts_ChoicePoint(eng,blub_prolog_engine_parts_CodeFrame(eng,alternative))
        return _hx_local_0

    @staticmethod
    def succeed(eng):
        eng.succeed()

    @staticmethod
    def no_op(eng):
        pass

    @staticmethod
    def fail(eng):
        eng.fail()

    @staticmethod
    def cut(eng):
        eng.cut()

    @staticmethod
    def cut_point(eng):
        cp = blub_prolog_engine_parts_CutPoint(eng)
        eng.cutBarrier = _hx_AnonObject({'prev': eng.cutBarrier, 'choice': cp})

    @staticmethod
    def log(msg):
        def _hx_local_0(eng):
            if (eng.logger is not None):
                eng.logger(msg)
        return _hx_local_0

    @staticmethod
    def debug_trace(msg):
        def _hx_local_0(eng):
            haxe_Log.trace(msg,_hx_AnonObject({'fileName': "src/blub/prolog/engine/Operations.hx", 'lineNumber': 381, 'className': "blub.prolog.engine.Operations", 'methodName': "debug_trace"}))
        return _hx_local_0

    @staticmethod
    def call_back(fn):
        return fn

    @staticmethod
    def dump(eng):
        eng.dump()

    @staticmethod
    def halt(eng):
        eng.halt()

    @staticmethod
    def new_environment(size):
        def _hx_local_0(eng):
            eng.environment = list()
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = eng.environment
                x = blub_prolog_terms_Reference()
                _this.append(x)
        return _hx_local_0

    @staticmethod
    def push_code_frame(eng):
        eng.codeStack = blub_prolog_engine_parts_CodeFrame(eng)

    @staticmethod
    def call_nested(code):
        def _hx_local_0(eng):
            eng.codeStack = blub_prolog_engine_parts_CodeFrame(eng)
            eng.codePointer = code
        return _hx_local_0

    @staticmethod
    def pop_code_frame(eng):
        if (eng.codeStack is not None):
            eng.codeStack.restore()

    @staticmethod
    def jump_to(code):
        def _hx_local_0(eng):
            eng.codePointer = code
        return _hx_local_0
_hx_classes["blub.prolog.engine.Operations"] = blub_prolog_engine_Operations

class blub_prolog_engine_AsyncCallbackType(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.engine.AsyncCallbackType"
    _hx_constructs = ["asyncSoln", "asyncDone", "asyncHalt", "asyncStart"]
blub_prolog_engine_AsyncCallbackType.asyncSoln = blub_prolog_engine_AsyncCallbackType("asyncSoln", 0, ())
blub_prolog_engine_AsyncCallbackType.asyncDone = blub_prolog_engine_AsyncCallbackType("asyncDone", 1, ())
blub_prolog_engine_AsyncCallbackType.asyncHalt = blub_prolog_engine_AsyncCallbackType("asyncHalt", 2, ())
blub_prolog_engine_AsyncCallbackType.asyncStart = blub_prolog_engine_AsyncCallbackType("asyncStart", 3, ())
_hx_classes["blub.prolog.engine.AsyncCallbackType"] = blub_prolog_engine_AsyncCallbackType


class blub_prolog_terms_BindingTrail:
    _hx_class_name = "blub.prolog.terms.BindingTrail"
    __slots__ = ()
    _hx_methods = ["newBinding", "bookmark", "undo"]
_hx_classes["blub.prolog.terms.BindingTrail"] = blub_prolog_terms_BindingTrail


class blub_prolog_engine_QueryEngine:
    _hx_class_name = "blub.prolog.engine.QueryEngine"
    __slots__ = ("database", "arithmetic", "isHalted", "atBreakpoint", "exception", "logger", "codeStack", "codePointer", "bindings", "cutBarrier", "choiceStack", "solutionFound", "arguments", "environment", "context", "_arithmetic", "transaction", "asyncCallback", "asyncUnderway", "asyncOp", "isAsync", "asyncResult", "tracePrefix", "traceCount")
    _hx_fields = ["database", "isHalted", "atBreakpoint", "exception", "logger", "codeStack", "codePointer", "bindings", "cutBarrier", "choiceStack", "solutionFound", "arguments", "environment", "context", "_arithmetic", "transaction", "asyncCallback", "asyncUnderway", "asyncOp", "isAsync", "asyncResult", "tracePrefix", "traceCount"]
    _hx_methods = ["get_arithmetic", "makeTransaction", "findSolution", "executeStep", "debugRun", "clearBreakpoint", "getCurrentAsyncOp", "executeAsync", "beginAsync", "continueAsync", "halt", "backtrack", "breakpoint", "processBuiltinChoices", "log", "setLogger", "raiseException", "unify", "succeed", "fail", "cut", "newBinding", "bookmark", "undo", "undoBindings", "pushCutPoint", "pushCutBarrier", "pushCodeFrame", "popCodeFrame", "createEnvironment", "setArguments", "useTraceLogger", "traceLogger", "dump"]
    _hx_interfaces = [blub_prolog_terms_BindingTrail]

    def __init__(self,database,code):
        self.traceCount = None
        self.tracePrefix = None
        self.asyncResult = None
        self.asyncOp = None
        self.asyncUnderway = None
        self.asyncCallback = None
        self.transaction = None
        self._arithmetic = None
        self.context = None
        self.environment = None
        self.arguments = None
        self.solutionFound = None
        self.choiceStack = None
        self.cutBarrier = None
        self.bindings = None
        self.codeStack = None
        self.logger = None
        self.exception = None
        self.arithmetic = None
        self.database = database
        self.codePointer = code
        self.isAsync = False
        self.isHalted = False
        self.atBreakpoint = False

    def get_arithmetic(self):
        if (self._arithmetic is None):
            self._arithmetic = blub_prolog_engine_ArithmeticEvaluator(self)
        return self._arithmetic

    def makeTransaction(self):
        if (self.transaction is None):
            self.transaction = blub_prolog_engine_DatabaseTransaction(self.database)
        return self.transaction

    def findSolution(self):
        if self.isHalted:
            return False
        self.isAsync = False
        if ((self.codePointer is None) and (not self.backtrack())):
            return False
        self.solutionFound = False
        while (self.codePointer is not None):
            op = self.codePointer.op
            self.codePointer = self.codePointer.next
            op(self)
        return self.solutionFound

    def executeStep(self):
        self.atBreakpoint = False
        if (self.exception is not None):
            e = self.exception
            self.exception = None
            raise haxe_Exception.thrown(self.exception)
        if self.isHalted:
            return
        self.isAsync = False
        self.solutionFound = False
        if (self.codePointer is None):
            self.backtrack()
            return
        if (self.codePointer is not None):
            op = self.codePointer.op
            self.codePointer = self.codePointer.next
            op(self)

    def debugRun(self):
        self.atBreakpoint = False
        if (self.exception is not None):
            e = self.exception
            self.exception = None
            raise haxe_Exception.thrown(self.exception)
        if self.isHalted:
            return
        self.isAsync = False
        self.solutionFound = False
        try:
            if (self.codePointer is None):
                if (not self.backtrack()):
                    return
            while (self.codePointer is not None):
                op = self.codePointer.op
                self.codePointer = self.codePointer.next
                op(self)
                if self.atBreakpoint:
                    return
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,blub_prolog_PrologError):
                ex = _g1
                self.exception = ex
            else:
                raise _g

    def clearBreakpoint(self):
        self.atBreakpoint = False
        if (self.exception is not None):
            e = self.exception
            self.exception = None
            raise haxe_Exception.thrown(self.exception)

    def getCurrentAsyncOp(self):
        return self.asyncOp

    def executeAsync(self,asyncCallback = None):
        self.asyncCallback = asyncCallback
        self.continueAsync()

    def beginAsync(self,operation):
        if (not self.isAsync):
            raise haxe_Exception.thrown(blub_prolog_PrologError(("Async predicate can only be used in an async query, op:" + HxOverrides.stringOrNull(operation.getDescription()))))
        self.asyncOp = operation
        self.asyncResult = None
        self.asyncUnderway = True

    def continueAsync(self,result = None):
        if self.isHalted:
            return
        self.asyncOp = None
        self.isAsync = True
        self.asyncResult = result
        self.asyncUnderway = False
        while True:
            if ((self.codePointer is None) and (not self.backtrack())):
                if (self.asyncCallback is not None):
                    self.asyncCallback(self,blub_prolog_engine_AsyncCallbackType.asyncDone)
                return
            self.solutionFound = False
            while ((self.codePointer is not None) and (not self.asyncUnderway)):
                op = self.codePointer.op
                self.codePointer = self.codePointer.next
                op(self)
            if (self.asyncCallback is not None):
                self.asyncCallback(self,(blub_prolog_engine_AsyncCallbackType.asyncStart if (self.asyncUnderway) else blub_prolog_engine_AsyncCallbackType.asyncSoln))
            if self.asyncUnderway:
                return

    def halt(self):
        if (self.logger is not None):
            self.logger("*** HALTED ***")
        self.codePointer = None
        self.codeStack = None
        self.solutionFound = False
        self.isHalted = True
        if (self.choiceStack is not None):
            cp = self.choiceStack
            while (cp is not None):
                cp.halt()
                cp = cp.prev
            self.choiceStack = None
        if (self.asyncOp is not None):
            self.asyncOp.cancel()
            self.asyncOp = None
        self.asyncResult = None
        self.asyncUnderway = False
        if (self.asyncCallback is not None):
            self.asyncCallback(self,blub_prolog_engine_AsyncCallbackType.asyncHalt)

    def backtrack(self):
        self.solutionFound = False
        self.codePointer = None
        self.codeStack = None
        while (self.choiceStack is not None):
            self.choiceStack.undoBindings()
            if self.choiceStack.nextChoice():
                return True
        return False

    def breakpoint(self):
        self.atBreakpoint = True

    def processBuiltinChoices(self):
        self.backtrack()

    def log(self,msg):
        if (self.logger is not None):
            self.logger(msg)

    def setLogger(self,fn):
        self.logger = fn

    def raiseException(self,exception):
        raise haxe_Exception.thrown(exception)

    def unify(self,termA,termB):
        if termA.unify(termB,self):
            return True
        self.fail()
        return False

    def succeed(self):
        if (self.codeStack is not None):
            if (self.codeStack is not None):
                self.codeStack.restore()
            return
        self.solutionFound = True
        self.codePointer = None

    def fail(self):
        self.backtrack()

    def cut(self):
        if (self.cutBarrier is not None):
            self.choiceStack = self.cutBarrier.choice.prev
            self.cutBarrier = self.cutBarrier.prev
        else:
            self.choiceStack = None

    def newBinding(self,ref,oldValue):
        self.bindings = _hx_AnonObject({'next': self.bindings, 'ref': ref, 'old': oldValue})

    def bookmark(self):
        return self.bindings

    def undo(self,bookmark):
        prevBind = bookmark
        bind = self.bindings
        while ((bind is not None) and ((bind != prevBind))):
            bind.ref.unbind(bind.old)
            bind = bind.next
        self.bindings = prevBind

    def undoBindings(self,prevBind):
        bind = self.bindings
        while ((bind is not None) and ((bind != prevBind))):
            bind.ref.unbind(bind.old)
            bind = bind.next
        self.bindings = prevBind

    def pushCutPoint(self):
        cp = blub_prolog_engine_parts_CutPoint(self)
        self.cutBarrier = _hx_AnonObject({'prev': self.cutBarrier, 'choice': cp})

    def pushCutBarrier(self,cpnt):
        self.cutBarrier = _hx_AnonObject({'prev': self.cutBarrier, 'choice': cpnt})

    def pushCodeFrame(self):
        self.codeStack = blub_prolog_engine_parts_CodeFrame(self)

    def popCodeFrame(self):
        if (self.codeStack is not None):
            self.codeStack.restore()

    def createEnvironment(self,size):
        self.environment = list()
        _g = 0
        _g1 = size
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.environment
            x = blub_prolog_terms_Reference()
            _this.append(x)

    def setArguments(self,newArgs):
        if (newArgs is not None):
            args = list()
            env = self.environment
            _g = 0
            while (_g < len(newArgs)):
                t = (newArgs[_g] if _g >= 0 and _g < len(newArgs) else None)
                _g = (_g + 1)
                x = t.toValue(env)
                args.append(x)
            self.arguments = args
        else:
            self.arguments = None

    def useTraceLogger(self,prefix = None):
        if (prefix is None):
            prefix = ":"
        self.traceCount = 0
        self.tracePrefix = prefix
        self.logger = self.traceLogger

    def traceLogger(self,msg):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.traceCount
            _hx_local_0.traceCount = (_hx_local_1 + 1)
            return _hx_local_1
        haxe_Log.trace(msg,_hx_AnonObject({'methodName': None, 'lineNumber': _hx_local_2(), 'fileName': self.tracePrefix, 'customParams': None, 'className': None}))

    def dump(self):
        if (self.logger is not None):
            self.logger("---------------------------------------")
        msg = ("codeStack:     " + Std.string(self.codeStack))
        if (self.logger is not None):
            self.logger(msg)
        msg = ("codePointer:   " + Std.string(self.codePointer))
        if (self.logger is not None):
            self.logger(msg)
        msg = ("cutBarrier:    " + Std.string(self.cutBarrier))
        if (self.logger is not None):
            self.logger(msg)
        msg = ("choiceStack:   " + Std.string(self.choiceStack))
        if (self.logger is not None):
            self.logger(msg)
        msg = ("solutionFound: " + Std.string(self.solutionFound))
        if (self.logger is not None):
            self.logger(msg)
        msg = ("arguments:     " + Std.string(self.arguments))
        if (self.logger is not None):
            self.logger(msg)
        msg = ("environment:   " + Std.string(self.environment))
        if (self.logger is not None):
            self.logger(msg)
        if (self.logger is not None):
            self.logger("---------------------------------------")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.database = None
        _hx_o.isHalted = None
        _hx_o.atBreakpoint = None
        _hx_o.exception = None
        _hx_o.logger = None
        _hx_o.codeStack = None
        _hx_o.codePointer = None
        _hx_o.bindings = None
        _hx_o.cutBarrier = None
        _hx_o.choiceStack = None
        _hx_o.solutionFound = None
        _hx_o.arguments = None
        _hx_o.environment = None
        _hx_o.context = None
        _hx_o._arithmetic = None
        _hx_o.transaction = None
        _hx_o.asyncCallback = None
        _hx_o.asyncUnderway = None
        _hx_o.asyncOp = None
        _hx_o.isAsync = None
        _hx_o.asyncResult = None
        _hx_o.tracePrefix = None
        _hx_o.traceCount = None
_hx_classes["blub.prolog.engine.QueryEngine"] = blub_prolog_engine_QueryEngine


class blub_prolog_engine_parts_ClauseChoices(blub_prolog_engine_parts_ChoicePoint):
    _hx_class_name = "blub.prolog.engine.parts.ClauseChoices"
    __slots__ = ("clauses", "index")
    _hx_fields = ["clauses", "index"]
    _hx_methods = ["nextChoice", "jumpToChoice", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_engine_parts_ChoicePoint


    def __init__(self,eng,clauses):
        self.index = None
        self.clauses = None
        super().__init__(eng)
        self.clauses = clauses
        self.index = 0
        self.jumpToChoice()

    def nextChoice(self):
        self.frame.restore()
        return self.jumpToChoice()

    def jumpToChoice(self):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.index
            _hx_local_0.index = (_hx_local_1 + 1)
            return _hx_local_1
        clause = python_internal_ArrayImpl._get(self.clauses, _hx_local_2())
        if (self.index == len(self.clauses)):
            self.popThisChoicePoint()
        _this = self.engine
        _this.cutBarrier = _hx_AnonObject({'prev': _this.cutBarrier, 'choice': self})
        self.engine.context = clause
        self.engine.codePointer = clause.code
        return True

    def toString(self):
        return ("Next clause: " + Std.string(python_internal_ArrayImpl._get(self.clauses, self.index).head))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.clauses = None
        _hx_o.index = None
_hx_classes["blub.prolog.engine.parts.ClauseChoices"] = blub_prolog_engine_parts_ClauseChoices


class blub_prolog_engine_parts_CodeFrame:
    _hx_class_name = "blub.prolog.engine.parts.CodeFrame"
    __slots__ = ("engine", "codeStack", "codePointer", "cutBarrier", "arguments", "environment", "context")
    _hx_fields = ["engine", "codeStack", "codePointer", "cutBarrier", "arguments", "environment", "context"]
    _hx_methods = ["restore", "toString"]

    def __init__(self,eng,continuation = None):
        self.context = None
        self.environment = None
        self.arguments = None
        self.cutBarrier = None
        self.codePointer = None
        self.codeStack = None
        self.engine = eng
        self.codeStack = self.engine.codeStack
        self.codePointer = (self.engine.codePointer if ((continuation is None)) else continuation)
        self.cutBarrier = self.engine.cutBarrier
        self.arguments = self.engine.arguments
        self.environment = self.engine.environment
        self.context = self.engine.context

    def restore(self):
        self.engine.codeStack = self.codeStack
        self.engine.codePointer = self.codePointer
        self.engine.cutBarrier = self.cutBarrier
        self.engine.arguments = self.arguments
        self.engine.environment = self.environment
        self.engine.context = self.context

    def toString(self):
        return ("Frame: " + Std.string(self.environment))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.codeStack = None
        _hx_o.codePointer = None
        _hx_o.cutBarrier = None
        _hx_o.arguments = None
        _hx_o.environment = None
        _hx_o.context = None
_hx_classes["blub.prolog.engine.parts.CodeFrame"] = blub_prolog_engine_parts_CodeFrame


class blub_prolog_engine_parts_CutPoint(blub_prolog_engine_parts_ChoicePoint):
    _hx_class_name = "blub.prolog.engine.parts.CutPoint"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["nextChoice"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_engine_parts_ChoicePoint


    def __init__(self,eng):
        super().__init__(eng)

    def nextChoice(self):
        self.frame.engine.choiceStack = self.prev
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.engine.parts.CutPoint"] = blub_prolog_engine_parts_CutPoint


class blub_prolog_engine_parts_RepeatingChoicePoint(blub_prolog_engine_parts_ChoicePoint):
    _hx_class_name = "blub.prolog.engine.parts.RepeatingChoicePoint"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["nextChoice", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_engine_parts_ChoicePoint


    def __init__(self,eng):
        super().__init__(eng,eng.codeStack)

    def nextChoice(self):
        self.frame.restore()
        return True

    def toString(self):
        return ("Repeating: " + Std.string(self.frame))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["blub.prolog.engine.parts.RepeatingChoicePoint"] = blub_prolog_engine_parts_RepeatingChoicePoint


class blub_prolog_stopgap_parse_Char:
    _hx_class_name = "blub.prolog.stopgap.parse.Char"
    __slots__ = ("line", "col", "value", "code")
    _hx_fields = ["line", "col", "value", "code"]
    _hx_methods = ["toString", "isOpChar", "isComma", "isExclamation", "isSemicolon", "isBar", "isUnderscore", "isSingleQuote", "isDoubleQuote", "isUppercase", "isLowercase", "isLetter", "isAtomChar", "isVarChar", "isDigit", "isHexDigit", "isHexX", "isExponentE", "isNumericSign", "isZero", "isNewline", "isReturn", "isPeriod", "isMinus", "isLineComment", "isSlash", "isBackslash", "isAsterisk", "isOpenParen", "isCloseParen", "isOpenBrace", "isCloseBrace", "isOpenBracket", "isCloseBracket", "isWhitespace"]
    _hx_statics = ["OP_CHARS", "WHITESPACE", "isOpChar_"]

    def __init__(self,line,col,text,index):
        self.code = None
        self.line = line
        self.col = col
        self.value = HxString.substr(text,index,1)
        self.code = HxString.charCodeAt(self.value,0)

    def toString(self):
        return self.value

    def isOpChar(self):
        _hx_str = self.value
        startIndex = None
        return ((("#$&*+-./:<=>?@^~\\".find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl("#$&*+-./:<=>?@^~\\",_hx_str,startIndex))) >= 0)

    def isComma(self):
        return (self.value == ",")

    def isExclamation(self):
        return (self.value == "!")

    def isSemicolon(self):
        return (self.value == ";")

    def isBar(self):
        return (self.value == "|")

    def isUnderscore(self):
        return (self.value == "_")

    def isSingleQuote(self):
        return (self.value == "'")

    def isDoubleQuote(self):
        return (self.value == "\"")

    def isUppercase(self):
        if (self.code >= 65):
            return (self.code <= 90)
        else:
            return False

    def isLowercase(self):
        if (self.code >= 97):
            return (self.code <= 122)
        else:
            return False

    def isLetter(self):
        if (not self.isUppercase()):
            return self.isLowercase()
        else:
            return True

    def isAtomChar(self):
        if (not (((self.isUppercase() or self.isLowercase()) or self.isDigit()))):
            return self.isUnderscore()
        else:
            return True

    def isVarChar(self):
        if (not (((self.isUppercase() or self.isLowercase()) or self.isDigit()))):
            return self.isUnderscore()
        else:
            return True

    def isDigit(self):
        if (self.code >= 48):
            return (self.code <= 57)
        else:
            return False

    def isHexDigit(self):
        if (not ((self.isDigit() or (((self.code >= 65) and ((self.code <= 70))))))):
            if (self.code >= 97):
                return (self.code <= 102)
            else:
                return False
        else:
            return True

    def isHexX(self):
        if (self.value != "x"):
            return (self.value == "X")
        else:
            return True

    def isExponentE(self):
        if (self.value != "e"):
            return (self.value == "E")
        else:
            return True

    def isNumericSign(self):
        if (self.value != "-"):
            return (self.value == "+")
        else:
            return True

    def isZero(self):
        return (self.value == "0")

    def isNewline(self):
        return (self.value == "\n")

    def isReturn(self):
        return (self.value == "\r")

    def isPeriod(self):
        return (self.value == ".")

    def isMinus(self):
        return (self.value == "-")

    def isLineComment(self):
        return (self.value == "%")

    def isSlash(self):
        return (self.value == "/")

    def isBackslash(self):
        return (self.value == "\\")

    def isAsterisk(self):
        return (self.value == "*")

    def isOpenParen(self):
        return (self.value == "(")

    def isCloseParen(self):
        return (self.value == ")")

    def isOpenBrace(self):
        return (self.value == "{")

    def isCloseBrace(self):
        return (self.value == "}")

    def isOpenBracket(self):
        return (self.value == "[")

    def isCloseBracket(self):
        return (self.value == "]")

    def isWhitespace(self):
        _hx_str = self.value
        startIndex = None
        return (((" \n\r\t\x0C".find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(" \n\r\t\x0C",_hx_str,startIndex))) >= 0)

    @staticmethod
    def isOpChar_(value):
        startIndex = None
        return ((("#$&*+-./:<=>?@^~\\".find(value) if ((startIndex is None)) else HxString.indexOfImpl("#$&*+-./:<=>?@^~\\",value,startIndex))) >= 0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.line = None
        _hx_o.col = None
        _hx_o.value = None
        _hx_o.code = None
_hx_classes["blub.prolog.stopgap.parse.Char"] = blub_prolog_stopgap_parse_Char


class blub_prolog_stopgap_parse_Lexer:
    _hx_class_name = "blub.prolog.stopgap.parse.Lexer"
    __slots__ = ("buffer", "token", "text", "origin")
    _hx_fields = ["buffer", "token", "text", "origin"]
    _hx_methods = ["next", "gatherString", "escapeReadChar", "gatherQuotedAtom", "gatherAtom", "gatherOp", "gatherNumber", "gatherDigits", "gatherHex", "one", "gatherVar", "gatherWS", "skipWS", "isCommentStart", "skipComment", "skipToEndOfLine", "sanitize", "readAllChars"]

    def __init__(self,text,origin = None,line = None,col = None):
        if (origin is None):
            origin = "<unknown>"
        if (line is None):
            line = 1
        if (col is None):
            col = 1
        self.token = None
        self.text = text
        self.origin = origin
        self.buffer = list()
        self.sanitize()
        self.readAllChars(line,col)

    def next(self,skipWS = None):
        if (skipWS is None):
            skipWS = True
        self.token = list()
        if skipWS:
            self.skipWS()
        if (len(self.buffer) == 0):
            return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_eof,self.token)
        _hx_type = None
        while self.isCommentStart():
            self.skipComment()
        ch = (self.buffer[0] if 0 < len(self.buffer) else None)
        if ch.isWhitespace():
            return self.gatherWS()
        if (ch.isUnderscore() or ch.isUppercase()):
            return self.gatherVar()
        if ch.isDigit():
            return self.gatherNumber()
        if (ch.isPeriod() and (((((len(self.buffer) == 1) or (self.buffer[1] if 1 < len(self.buffer) else None).isWhitespace()) or (self.buffer[1] if 1 < len(self.buffer) else None).isLineComment()) or ((((len(self.buffer) > 2) and (self.buffer[1] if 1 < len(self.buffer) else None).isSlash()) and (self.buffer[2] if 2 < len(self.buffer) else None).isAsterisk()))))):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
            return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_term_end,self.token)
        if ch.isOpChar():
            return self.gatherOp()
        if ch.isLowercase():
            return self.gatherAtom()
        if ch.isSingleQuote():
            return self.gatherQuotedAtom()
        if ch.isDoubleQuote():
            return self.gatherString()
        if ch.isComma():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_atom)
        if ch.isSemicolon():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_atom)
        if ch.isExclamation():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_atom)
        if ch.isBar():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_atom)
        if ch.isOpenParen():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_open_paren)
        if ch.isCloseParen():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_close_paren)
        if ch.isOpenBrace():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_open_brace)
        if ch.isCloseBrace():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_close_brace)
        if ch.isOpenBracket():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_open_bracket)
        if ch.isCloseBracket():
            return self.one(blub_prolog_stopgap_parse_TokenType.token_close_bracket)
        raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError((("unrecognized character '" + HxOverrides.stringOrNull(ch.value)) + "'"),self.origin,ch.line,ch.col))

    def gatherString(self):
        _this = self.buffer
        start = (None if ((len(_this) == 0)) else _this.pop(0))
        end = None
        while True:
            if (len(self.buffer) == 0):
                _this = self.token
                last = (None if ((len(_this) == 0)) else _this.pop())
                raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError("unterminated string",self.origin,last.line,last.col))
            if ((self.buffer[0] if 0 < len(self.buffer) else None).isBackslash() and ((len(self.buffer) > 1))):
                _this1 = self.token
                _this2 = self.buffer
                x = (None if ((len(_this2) == 0)) else _this2.pop(0))
                _this1.append(x)
                _this3 = self.token
                _this4 = self.buffer
                x1 = (None if ((len(_this4) == 0)) else _this4.pop(0))
                _this3.append(x1)
                continue
            if (self.buffer[0] if 0 < len(self.buffer) else None).isDoubleQuote():
                _this5 = self.buffer
                end = (None if ((len(_this5) == 0)) else _this5.pop(0))
                break
            _this6 = self.token
            _this7 = self.buffer
            x2 = (None if ((len(_this7) == 0)) else _this7.pop(0))
            _this6.append(x2)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_string,self.token,start,end)

    def escapeReadChar(self):
        if (len(self.buffer) == 0):
            return None
        _this = self.buffer
        ch = (None if ((len(_this) == 0)) else _this.pop(0))
        if ch.isBackslash():
            if (len(self.buffer) == 0):
                raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError("bad character escape",self.origin,ch.line,ch.col))
            _this = self.buffer
            ch2 = (None if ((len(_this) == 0)) else _this.pop(0))
            _g = ch2.value
            if (_g == "\""):
                ch.value = "\""
            elif (_g == "'"):
                ch.value = "'"
            elif (_g == "\\"):
                ch.value = "\\"
            elif (_g == "`"):
                ch.value = "`"
            elif (_g == "a"):
                ch.value = "\x07"
            elif (_g == "b"):
                ch.value = "\t"
            elif (_g == "f"):
                ch.value = "\x0C"
            elif (_g == "n"):
                ch.value = "\n"
            elif (_g == "r"):
                ch.value = "\r"
            elif (_g == "t"):
                ch.value = "\t"
            elif (_g == "v"):
                ch.value = "\x0B"
            elif ((_g == "x") or ((_g == "X"))):
                s = "0x"
                while True:
                    if (len(self.buffer) == 0):
                        raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError("unterminated escape char",self.origin,ch2.line,ch2.col))
                    _this = self.buffer
                    ch2 = (None if ((len(_this) == 0)) else _this.pop(0))
                    if ch2.isDigit():
                        s = (("null" if s is None else s) + HxOverrides.stringOrNull(ch2.value))
                        continue
                    if ch2.isBackslash():
                        code = Std.parseInt(s)
                        ch.value = "".join(map(chr,[code]))
                        break
                    raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError("non-digit in hex escape char",self.origin,ch2.line,ch2.col))
            else:
                raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError("bad character escape",self.origin,ch.line,ch.col))
        return ch

    def gatherQuotedAtom(self):
        _this = self.buffer
        if (len(_this) != 0):
            _this.pop(0)
        while True:
            if (len(self.buffer) == 0):
                buf = StringBuf()
                _g = 0
                _g1 = self.token
                while (_g < len(_g1)):
                    c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    s = Std.string(c.value)
                    buf.b.write(s)
                _this = self.token
                last = (None if ((len(_this) == 0)) else _this.pop())
                raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError(("unterminated atom: " + Std.string(buf)),self.origin,last.line,last.col))
            if ((self.buffer[0] if 0 < len(self.buffer) else None).isBackslash() and ((len(self.buffer) > 1))):
                _this1 = self.buffer
                if (len(_this1) != 0):
                    _this1.pop(0)
                _this2 = self.buffer
                escChr = (None if ((len(_this2) == 0)) else _this2.pop(0))
                tmp = None
                _g2 = escChr.value
                if (_g2 == "\\"):
                    tmp = "\\"
                elif (_g2 == "n"):
                    tmp = "\n"
                elif (_g2 == "r"):
                    tmp = "\r"
                elif (_g2 == "t"):
                    tmp = "\t"
                else:
                    tmp = ("\\" + HxOverrides.stringOrNull(escChr.value))
                escChr.value = tmp
                _this3 = self.token
                _this3.append(escChr)
                continue
            if (self.buffer[0] if 0 < len(self.buffer) else None).isSingleQuote():
                if ((len(self.buffer) > 1) and (self.buffer[1] if 1 < len(self.buffer) else None).isSingleQuote()):
                    _this4 = self.token
                    _this5 = self.buffer
                    x = (None if ((len(_this5) == 0)) else _this5.pop(0))
                    _this4.append(x)
                    _this6 = self.buffer
                    if (len(_this6) != 0):
                        _this6.pop(0)
                    continue
                _this7 = self.buffer
                if (len(_this7) != 0):
                    _this7.pop(0)
                break
            _this8 = self.token
            _this9 = self.buffer
            x1 = (None if ((len(_this9) == 0)) else _this9.pop(0))
            _this8.append(x1)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_atom,self.token)

    def gatherAtom(self):
        _this = self.token
        _this1 = self.buffer
        x = (None if ((len(_this1) == 0)) else _this1.pop(0))
        _this.append(x)
        while ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isAtomChar()):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_atom,self.token)

    def gatherOp(self):
        while ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isOpChar()):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_atom,self.token)

    def gatherNumber(self):
        _this = self.buffer
        ch = (None if ((len(_this) == 0)) else _this.pop(0))
        _this = self.token
        _this.append(ch)
        _hx_type = blub_prolog_stopgap_parse_TokenType.token_int
        if ((ch.isZero() and ((len(self.buffer) > 0))) and (self.buffer[0] if 0 < len(self.buffer) else None).isHexX()):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
            return self.gatherHex()
        self.gatherDigits()
        if (((len(self.buffer) > 1) and (self.buffer[0] if 0 < len(self.buffer) else None).isPeriod()) and (self.buffer[1] if 1 < len(self.buffer) else None).isDigit()):
            _hx_type = blub_prolog_stopgap_parse_TokenType.token_float
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
            self.gatherDigits()
        if (((len(self.buffer) > 1) and (self.buffer[0] if 0 < len(self.buffer) else None).isExponentE()) and (((self.buffer[1] if 1 < len(self.buffer) else None).isDigit() or ((((len(self.buffer) > 2) and (self.buffer[1] if 1 < len(self.buffer) else None).isNumericSign()) and (self.buffer[2] if 2 < len(self.buffer) else None).isDigit()))))):
            _hx_type = blub_prolog_stopgap_parse_TokenType.token_float
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
            if (self.buffer[0] if 0 < len(self.buffer) else None).isNumericSign():
                _this = self.token
                _this1 = self.buffer
                x = (None if ((len(_this1) == 0)) else _this1.pop(0))
                _this.append(x)
            self.gatherDigits()
        if ((len(self.buffer) > 0) and (((self.buffer[0] if 0 < len(self.buffer) else None).isLetter() or (self.buffer[0] if 0 < len(self.buffer) else None).isUnderscore()))):
            raise haxe_Exception.thrown(blub_prolog_stopgap_parse_ParseError((("invalid char after a number '" + HxOverrides.stringOrNull((self.buffer[0] if 0 < len(self.buffer) else None).value)) + "'"),self.origin,(self.buffer[0] if 0 < len(self.buffer) else None).line,(self.buffer[0] if 0 < len(self.buffer) else None).col))
        return blub_prolog_stopgap_parse_Token(_hx_type,self.token)

    def gatherDigits(self):
        while ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isDigit()):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)

    def gatherHex(self):
        while ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isHexDigit()):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_int,self.token)

    def one(self,_hx_type):
        _this = self.token
        _this1 = self.buffer
        x = (None if ((len(_this1) == 0)) else _this1.pop(0))
        _this.append(x)
        return blub_prolog_stopgap_parse_Token(_hx_type,self.token)

    def gatherVar(self):
        while ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isVarChar()):
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_variable,self.token)

    def gatherWS(self):
        while ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isWhitespace()):
            if self.isCommentStart():
                self.skipComment()
            _this = self.token
            _this1 = self.buffer
            x = (None if ((len(_this1) == 0)) else _this1.pop(0))
            _this.append(x)
        return blub_prolog_stopgap_parse_Token(blub_prolog_stopgap_parse_TokenType.token_whitespace,self.token)

    def skipWS(self):
        while ((len(self.buffer) > 0) and (((self.buffer[0] if 0 < len(self.buffer) else None).isWhitespace() or self.isCommentStart()))):
            if self.isCommentStart():
                self.skipComment()
                continue
            _this = self.buffer
            if (len(_this) != 0):
                _this.pop(0)

    def isCommentStart(self):
        if ((len(self.buffer) > 0) and (self.buffer[0] if 0 < len(self.buffer) else None).isLineComment()):
            return True
        if (((len(self.buffer) > 1) and (self.buffer[0] if 0 < len(self.buffer) else None).isSlash()) and (self.buffer[1] if 1 < len(self.buffer) else None).isAsterisk()):
            return True
        return False

    def skipComment(self):
        if (self.buffer[0] if 0 < len(self.buffer) else None).isLineComment():
            self.skipToEndOfLine()
        else:
            while (len(self.buffer) > 0):
                _this = self.buffer
                if ((((None if ((len(_this) == 0)) else _this.pop(0))).isAsterisk() and ((len(self.buffer) > 0))) and (self.buffer[0] if 0 < len(self.buffer) else None).isSlash()):
                    _this1 = self.buffer
                    if (len(_this1) != 0):
                        _this1.pop(0)
                    break

    def skipToEndOfLine(self):
        while (len(self.buffer) > 0):
            _this = self.buffer
            if ((None if ((len(_this) == 0)) else _this.pop(0))).isNewline():
                break

    def sanitize(self):
        self.text = StringTools.replace(self.text,"\r\n","\n")
        self.text = StringTools.replace(self.text,"\r","\n")

    def readAllChars(self,line,col):
        _g = 0
        _g1 = len(self.text)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = blub_prolog_stopgap_parse_Char(line,col,self.text,i)
            if c.isNewline():
                line = (line + 1)
                col = 1
            else:
                col = (col + 1)
            _this = self.buffer
            _this.append(c)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.token = None
        _hx_o.text = None
        _hx_o.origin = None
_hx_classes["blub.prolog.stopgap.parse.Lexer"] = blub_prolog_stopgap_parse_Lexer


class blub_prolog_stopgap_parse_Operator:
    _hx_class_name = "blub.prolog.stopgap.parse.Operator"
    __slots__ = ("atom", "spec", "priority", "arity", "functor", "rightSpec", "leftSpec")
    _hx_fields = ["atom", "spec", "priority", "arity", "functor"]
    _hx_methods = ["expectsLeft", "expectsRight", "get_rightSpec", "get_leftSpec", "compareToRight"]
    _hx_statics = ["functorForOp", "opSpec"]

    def __init__(self,atom,spec,priority):
        self.leftSpec = None
        self.rightSpec = None
        self.functor = None
        self.priority = priority
        self.spec = spec
        self.atom = atom
        tmp = None
        tmp1 = spec.index
        if ((((tmp1 == 3) or ((tmp1 == 2))) or ((tmp1 == 1))) or ((tmp1 == 0))):
            tmp = 1
        elif (((tmp1 == 6) or ((tmp1 == 5))) or ((tmp1 == 4))):
            tmp = 2
        else:
            pass
        self.arity = tmp
        self.functor = ((HxOverrides.stringOrNull(atom.text) + "/") + Std.string(self.arity))

    def expectsLeft(self):
        return (self.get_leftSpec() is not None)

    def expectsRight(self):
        return (self.get_rightSpec() is not None)

    def get_rightSpec(self):
        tmp = self.spec.index
        if ((tmp == 6) or ((tmp == 1))):
            return blub_prolog_stopgap_parse_Specifier.spec_y
        elif ((tmp == 3) or ((tmp == 2))):
            return None
        elif (((tmp == 5) or ((tmp == 4))) or ((tmp == 0))):
            return blub_prolog_stopgap_parse_Specifier.spec_x
        else:
            pass

    def get_leftSpec(self):
        tmp = self.spec.index
        if ((tmp == 1) or ((tmp == 0))):
            return None
        elif ((tmp == 5) or ((tmp == 3))):
            return blub_prolog_stopgap_parse_Specifier.spec_y
        elif (((tmp == 6) or ((tmp == 4))) or ((tmp == 2))):
            return blub_prolog_stopgap_parse_Specifier.spec_x
        else:
            pass

    def compareToRight(self,right):
        if (self.priority > right.priority):
            return 1
        if (self.priority < right.priority):
            return 2
        rspec = self.get_rightSpec()
        lspec = right.get_leftSpec()
        if (rspec == lspec):
            return 0
        if (rspec == blub_prolog_stopgap_parse_Specifier.spec_y):
            return 1
        return 2

    @staticmethod
    def functorForOp(name,arity):
        return ((("null" if name is None else name) + "/") + Std.string(arity))

    @staticmethod
    def opSpec(s):
        s1 = s
        _hx_local_0 = len(s1)
        if (_hx_local_0 == 3):
            if (s1 == "xfx"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_xfx
            elif (s1 == "xfy"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_xfy
            elif (s1 == "yfx"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_yfx
            else:
                return None
        elif (_hx_local_0 == 2):
            if (s1 == "fx"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_fx
            elif (s1 == "fy"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_fy
            elif (s1 == "xf"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_xf
            elif (s1 == "yf"):
                return blub_prolog_stopgap_parse_OperatorSpec.op_yf
            else:
                return None
        else:
            return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.atom = None
        _hx_o.spec = None
        _hx_o.priority = None
        _hx_o.arity = None
        _hx_o.functor = None
_hx_classes["blub.prolog.stopgap.parse.Operator"] = blub_prolog_stopgap_parse_Operator

class blub_prolog_stopgap_parse_Specifier(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.stopgap.parse.Specifier"
    _hx_constructs = ["spec_x", "spec_y"]
blub_prolog_stopgap_parse_Specifier.spec_x = blub_prolog_stopgap_parse_Specifier("spec_x", 0, ())
blub_prolog_stopgap_parse_Specifier.spec_y = blub_prolog_stopgap_parse_Specifier("spec_y", 1, ())
_hx_classes["blub.prolog.stopgap.parse.Specifier"] = blub_prolog_stopgap_parse_Specifier

class blub_prolog_stopgap_parse_OperatorSpec(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.stopgap.parse.OperatorSpec"
    _hx_constructs = ["op_fx", "op_fy", "op_xf", "op_yf", "op_xfx", "op_yfx", "op_xfy"]
blub_prolog_stopgap_parse_OperatorSpec.op_fx = blub_prolog_stopgap_parse_OperatorSpec("op_fx", 0, ())
blub_prolog_stopgap_parse_OperatorSpec.op_fy = blub_prolog_stopgap_parse_OperatorSpec("op_fy", 1, ())
blub_prolog_stopgap_parse_OperatorSpec.op_xf = blub_prolog_stopgap_parse_OperatorSpec("op_xf", 2, ())
blub_prolog_stopgap_parse_OperatorSpec.op_yf = blub_prolog_stopgap_parse_OperatorSpec("op_yf", 3, ())
blub_prolog_stopgap_parse_OperatorSpec.op_xfx = blub_prolog_stopgap_parse_OperatorSpec("op_xfx", 4, ())
blub_prolog_stopgap_parse_OperatorSpec.op_yfx = blub_prolog_stopgap_parse_OperatorSpec("op_yfx", 5, ())
blub_prolog_stopgap_parse_OperatorSpec.op_xfy = blub_prolog_stopgap_parse_OperatorSpec("op_xfy", 6, ())
_hx_classes["blub.prolog.stopgap.parse.OperatorSpec"] = blub_prolog_stopgap_parse_OperatorSpec


class blub_prolog_stopgap_parse_Operators:
    _hx_class_name = "blub.prolog.stopgap.parse.Operators"
    __slots__ = ("operators",)
    _hx_fields = ["operators"]
    _hx_methods = ["add", "newOp", "lookup", "lookupAny", "couldBeOp", "new_op", "addStandardOps"]

    def __init__(self):
        self.operators = haxe_ds_StringMap()

    def add(self,op):
        self.operators.h[op.functor] = op

    def newOp(self,name,spec,priority,context):
        op = blub_prolog_stopgap_parse_Operator(context.getAtom(name),spec,priority)
        self.add(op)
        return op

    def lookup(self,name,arity):
        return self.operators.h.get(((("null" if name is None else name) + "/") + Std.string(arity)),None)

    def lookupAny(self,name):
        op = self.lookup(name,1)
        if (op is not None):
            return op
        return self.lookup(name,2)

    def couldBeOp(self,name):
        if (self.lookup(name,1) is None):
            return (self.lookup(name,2) is not None)
        else:
            return True

    def new_op(self,name,spec,priority):
        self.newOp(name,spec,priority,blub_prolog_AtomContext.GLOBALS)

    def addStandardOps(self):
        self.new_op("dynamic",blub_prolog_stopgap_parse_OperatorSpec.op_fx,1150)
        self.new_op("discontiguous",blub_prolog_stopgap_parse_OperatorSpec.op_fx,1150)
        self.new_op("multifile",blub_prolog_stopgap_parse_OperatorSpec.op_fx,1150)
        self.new_op(":-",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,1200)
        self.new_op("-->",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,1200)
        self.new_op("?-",blub_prolog_stopgap_parse_OperatorSpec.op_fx,1200)
        self.new_op(";",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,1100)
        self.new_op("|",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,1100)
        self.new_op("->",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,1050)
        self.new_op(",",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,1000)
        self.new_op("\\+",blub_prolog_stopgap_parse_OperatorSpec.op_fy,900)
        self.new_op("<",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("=..",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("=@=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("=:=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("=<",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("==",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("=\\=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op(">",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op(">=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("@<",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("@=<",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("@>",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("@>=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("\\=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("\\==",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("is",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op(":",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,600)
        self.new_op("+",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,500)
        self.new_op("-",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,500)
        self.new_op("/\\",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,500)
        self.new_op("\\/",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,500)
        self.new_op("xor",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,500)
        self.new_op("?",blub_prolog_stopgap_parse_OperatorSpec.op_fx,500)
        self.new_op("*",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op("/",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op("//",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op("<<",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op(">>",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op("mod",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op("rem",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,400)
        self.new_op("**",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,200)
        self.new_op("^",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,200)
        self.new_op("#",blub_prolog_stopgap_parse_OperatorSpec.op_fx,1)
        self.new_op("from_global",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,530)
        self.new_op("to_global",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,530)
        self.new_op("<-",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,510)
        self.new_op(".",blub_prolog_stopgap_parse_OperatorSpec.op_yfx,100)
        self.new_op("<=&",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,510)
        self.new_op("<=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,510)
        self.new_op("<#&",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,510)
        self.new_op("<#",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,510)
        self.new_op("spawn",blub_prolog_stopgap_parse_OperatorSpec.op_fx,910)
        self.new_op("spawns",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,910)
        self.new_op("change_in",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,910)
        self.new_op("@",blub_prolog_stopgap_parse_OperatorSpec.op_fx,110)
        self.new_op("@=",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,700)
        self.new_op("chr_constraint",blub_prolog_stopgap_parse_OperatorSpec.op_fx,1150)
        self.new_op("<=>",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,1190)
        self.new_op("==>",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,1190)
        self.new_op("\\",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,1150)
        self.new_op("or",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,950)
        self.new_op("and",blub_prolog_stopgap_parse_OperatorSpec.op_xfy,930)
        self.new_op("~",blub_prolog_stopgap_parse_OperatorSpec.op_fx,100)
        self.new_op("=>",blub_prolog_stopgap_parse_OperatorSpec.op_xfx,1200)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.operators = None
_hx_classes["blub.prolog.stopgap.parse.Operators"] = blub_prolog_stopgap_parse_Operators


class blub_prolog_stopgap_parse_ParseError(blub_prolog_PrologError):
    _hx_class_name = "blub.prolog.stopgap.parse.ParseError"
    __slots__ = ("origin", "line", "col")
    _hx_fields = ["origin", "line", "col"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = blub_prolog_PrologError


    def __init__(self,msg,origin,line,col):
        self.col = None
        self.line = None
        self.origin = None
        super().__init__(msg)
        self.origin = origin
        self.line = line
        self.col = col

    def toString(self):
        return ((((((HxOverrides.stringOrNull(self.origin) + "<") + Std.string(self.line)) + ":") + Std.string(self.col)) + "> ") + HxOverrides.stringOrNull(self.message))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.origin = None
        _hx_o.line = None
        _hx_o.col = None
_hx_classes["blub.prolog.stopgap.parse.ParseError"] = blub_prolog_stopgap_parse_ParseError


class blub_prolog_stopgap_parse_ParseNode:
    _hx_class_name = "blub.prolog.stopgap.parse.ParseNode"
    __slots__ = ("term", "op", "left", "right", "parent", "parser")
    _hx_fields = ["term", "op", "left", "right", "parent", "parser"]
    _hx_methods = ["toString", "getRoot", "assembleTerm", "checkIfThenElse", "assimilate", "makeLeftChildOf", "findInsertionPoint"]

    def __init__(self,parser,term):
        self.parent = None
        self.right = None
        self.left = None
        self.op = None
        self.parser = parser
        self.term = term
        if ((term is not None) and Std.isOfType(term,blub_prolog_terms_Atom)):
            def _hx_local_1():
                _hx_local_0 = term
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_Atom) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            self.op = parser.operators.lookupAny((_hx_local_1()).text)

    def toString(self):
        return self.term.toString()

    def getRoot(self):
        root = self
        while (root.parent is not None):
            root = root.parent
        return root

    def assembleTerm(self):
        if (self.op is not None):
            def _hx_local_1():
                _hx_local_0 = self.term
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_Atom) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            struct = blub_prolog_terms_Structure(_hx_local_1())
            if (self.left is not None):
                struct.addArg(self.left.assembleTerm())
            if (self.right is not None):
                struct.addArg(self.right.assembleTerm())
            struct = self.checkIfThenElse(struct)
            return struct
        return self.term

    def checkIfThenElse(self,struct):
        def _hx_local_1():
            _hx_local_0 = struct.argAt(0)
            if (Std.isOfType(_hx_local_0,blub_prolog_terms_Structure) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        if ((((struct.getName().text == ";") and ((struct.getArity() == 2))) and Std.isOfType(struct.argAt(0),blub_prolog_terms_Structure)) and (((_hx_local_1()).getName().text == "->"))):
            def _hx_local_3():
                _hx_local_2 = struct.argAt(0)
                if (Std.isOfType(_hx_local_2,blub_prolog_terms_Structure) or ((_hx_local_2 is None))):
                    _hx_local_2
                else:
                    raise "Class cast error"
                return _hx_local_2
            ifThen = _hx_local_3()
            return blub_prolog_terms_Structure(self.parser.context.getAtom("#if_then_else"),[ifThen.argAt(0), ifThen.argAt(1), struct.argAt(1)])
        return struct

    def assimilate(self,node):
        if (node is None):
            if (self.op is not None):
                if (((self.parent is None) and ((self.left is None))) and ((self.right is None))):
                    return None
                if ((self.right is None) and self.op.expectsRight()):
                    raise haxe_Exception.thrown(self.parser.oops((("operator '" + HxOverrides.stringOrNull(self.op.atom.text)) + "' expects a term to the right")))
            return None
        if ((self.op is not None) and ((node.op is None))):
            if (not self.op.expectsRight()):
                raise haxe_Exception.thrown(self.parser.oops((("operator '" + HxOverrides.stringOrNull(self.op.atom.text)) + "' does not expect a term to the right")))
            if (self.right is not None):
                raise haxe_Exception.thrown(self.parser.oops("*** IMPL ERROR - op right arg not empty ***"))
            self.right = node
            node.parent = self
        elif ((self.op is not None) and ((node.op is not None))):
            op2 = node.op
            if (self.op.expectsRight() and (not op2.expectsLeft())):
                self.right = node
                node.parent = self
            else:
                raise haxe_Exception.thrown(self.parser.oops(((("*** IMPL ERROR - op clash *** " + Std.string(self.op)) + " ") + Std.string(op2))))
        elif (node.op is not None):
            op2 = node.op
            if (not op2.expectsLeft()):
                raise haxe_Exception.thrown(self.parser.oops((((((((("operator '" + HxOverrides.stringOrNull(op2.atom.text)) + "' {") + Std.string(op2.priority)) + "} does not expect a term to the left: ") + Std.string(self.op.atom)) + " {") + Std.string(self.op.priority)) + "}")))
            leftChild = self.findInsertionPoint(op2)
            leftChild.makeLeftChildOf(node)
        elif ((self.op is None) and ((node.op is None))):
            raise haxe_Exception.thrown(self.parser.oops(("unexpected term - operator expected: " + Std.string(node))))
        return node

    def makeLeftChildOf(self,node):
        node.left = self
        if (self.parent is not None):
            node.parent = self.parent
            if (self.parent.left == self):
                self.parent.left = node
            else:
                self.parent.right = node
        self.parent = node

    def findInsertionPoint(self,op):
        if (self.op is not None):
            _g = self.op.compareToRight(op)
            if (_g == 0):
                raise haxe_Exception.thrown(self.parser.oops(((("operator priority clash " + Std.string(self)) + " ") + Std.string(op.atom))))
            elif (_g == 1):
                return self.right
            elif (_g == 2):
                if (self.parent is not None):
                    return self.parent.findInsertionPoint(op)
                return self
            else:
                pass
        if (self.parent is not None):
            return self.parent.findInsertionPoint(op)
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.term = None
        _hx_o.op = None
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.parent = None
        _hx_o.parser = None
_hx_classes["blub.prolog.stopgap.parse.ParseNode"] = blub_prolog_stopgap_parse_ParseNode


class blub_prolog_stopgap_parse_Parser:
    _hx_class_name = "blub.prolog.stopgap.parse.Parser"
    __slots__ = ("lexer", "origin", "next", "context", "operators", "lastReadToken", "lastWasOp")
    _hx_fields = ["lexer", "origin", "next", "context", "operators", "lastReadToken", "lastWasOp"]
    _hx_methods = ["nextTerm", "readUntil", "nextRawTerm", "_nextRawTerm", "stringList", "readList", "structureCheck", "readStructure", "pushback", "getNext", "oops"]

    def __init__(self,context,operators,text,origin = None,line = None,col = None):
        if (origin is None):
            origin = "<unknown>"
        if (line is None):
            line = 1
        if (col is None):
            col = 1
        self.lastReadToken = None
        self.next = None
        self.lexer = None
        self.lastWasOp = True
        self.origin = origin
        self.operators = operators
        self.context = context
        if (self.context is None):
            self.context = blub_prolog_AtomContext()
        self.lexer = blub_prolog_stopgap_parse_Lexer(text,origin,line,col)

    def nextTerm(self):
        tok = self.getNext(True)
        if (tok.type == blub_prolog_stopgap_parse_TokenType.token_eof):
            return None
        if ((tok.type == blub_prolog_stopgap_parse_TokenType.token_atom) and ((tok.value == ":-"))):
            directive = self.readUntil(blub_prolog_stopgap_parse_TokenType.token_term_end)
            stru = None
            if (directive is not None):
                stru = directive.asStructure()
                if (stru is not None):
                    stru = stru.unpackParentheses().asStructure()
            if (stru is None):
                raise haxe_Exception.thrown(self.oops("Malformed directive",tok))
            return blub_prolog_terms_Structure.make(self.context.getAtom(":-"),stru)
        else:
            self.pushback(tok)
        term = self.readUntil(blub_prolog_stopgap_parse_TokenType.token_term_end)
        s = term.asStructure()
        if (s is not None):
            term = s.unpackParentheses()
        return term

    def readUntil(self,tokenType):
        self.lastWasOp = True
        node = None
        term = None
        while True:
            term = self.nextRawTerm(tokenType)
            if (not ((term is not None))):
                break
            newNode = blub_prolog_stopgap_parse_ParseNode(self,term)
            if (node is not None):
                node = node.assimilate(newNode)
            else:
                node = newNode
        if (node is not None):
            node.assimilate(None)
            return node.getRoot().assembleTerm()
        else:
            return None

    def nextRawTerm(self,endType = None):
        t = self._nextRawTerm(endType)
        if (t is None):
            return None
        atom = t.asAtom()
        self.lastWasOp = ((atom is not None) and (((self.operators.lookup(atom.text,1) is not None) or ((self.operators.lookup(atom.text,2) is not None)))))
        return t

    def _nextRawTerm(self,endType):
        if (endType is None):
            endType = blub_prolog_stopgap_parse_TokenType.token_term_end
        tok = self.getNext(True)
        if (tok.type == endType):
            return None
        tmp = tok.type.index
        if (tmp == 0):
            def _hx_local_2():
                def _hx_local_1():
                    _hx_local_0 = tok.value
                    if (Std.isOfType(_hx_local_0,str) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                return blub_prolog_terms_Variable(_hx_local_1())
            return _hx_local_2()
        elif (tmp == 1):
            return self.structureCheck(tok)
        elif ((tmp == 3) or ((tmp == 2))):
            def _hx_local_5():
                def _hx_local_4():
                    _hx_local_3 = tok.value
                    if (Std.isOfType(_hx_local_3,Float) or ((_hx_local_3 is None))):
                        _hx_local_3
                    else:
                        raise "Class cast error"
                    return _hx_local_3
                return blub_prolog_terms_NumberTerm(_hx_local_4())
            return _hx_local_5()
        elif (tmp == 5):
            def _hx_local_8():
                def _hx_local_7():
                    _hx_local_6 = tok.value
                    if (Std.isOfType(_hx_local_6,str) or ((_hx_local_6 is None))):
                        _hx_local_6
                    else:
                        raise "Class cast error"
                    return _hx_local_6
                return self.stringList(_hx_local_7())
            return _hx_local_8()
        elif (tmp == 6):
            raise haxe_Exception.thrown(self.oops("unexpected end of term",tok))
        elif (tmp == 7):
            raise haxe_Exception.thrown(self.oops("unexpected end of source"))
        elif (tmp == 8):
            return blub_prolog_terms_Structure.make(self.context.getAtom("()"),self.readUntil(blub_prolog_stopgap_parse_TokenType.token_close_paren))
        elif (tmp == 10):
            return blub_prolog_terms_Structure.make(self.context.getAtom("{}"),self.readUntil(blub_prolog_stopgap_parse_TokenType.token_close_brace))
        elif (tmp == 12):
            return self.readList()
        else:
            pass
        raise haxe_Exception.thrown(self.oops(("unexpected token: " + Std.string(tok)),tok))

    def stringList(self,s):
        t = blub_prolog_terms_Structure.EMPTY_LIST
        i = (len(s) - 1)
        while (i >= 0):
            bar = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST,[blub_prolog_terms_NumberTerm(HxString.charCodeAt(s,i)), t])
            t = bar
            i = (i - 1)
        return t

    def readList(self):
        t = self.readUntil(blub_prolog_stopgap_parse_TokenType.token_close_bracket)
        if (t is None):
            return blub_prolog_terms_Structure.EMPTY_LIST
        tail = None
        head = None
        if Std.isOfType(t,blub_prolog_terms_Structure):
            def _hx_local_1():
                _hx_local_0 = t
                if (Std.isOfType(_hx_local_0,blub_prolog_terms_Structure) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            s = _hx_local_1()
            if (s.getName().text == "|"):
                if (s.getArity() != 2):
                    raise haxe_Exception.thrown(self.oops("list bar '|' requires terms on either side"))
                tail = s.argAt(1)
                head = s.argAt(0)
            else:
                tail = blub_prolog_terms_Structure.EMPTY_LIST
                head = s
        else:
            tail = blub_prolog_terms_Structure.EMPTY_LIST
            head = t
        def _hx_local_3():
            _hx_local_2 = head
            if (Std.isOfType(_hx_local_2,blub_prolog_terms_Structure) or ((_hx_local_2 is None))):
                _hx_local_2
            else:
                raise "Class cast error"
            return _hx_local_2
        if (Std.isOfType(head,blub_prolog_terms_Structure) and (((_hx_local_3()).getName().text == ","))):
            def _hx_local_5():
                _hx_local_4 = head
                if (Std.isOfType(_hx_local_4,blub_prolog_terms_Structure) or ((_hx_local_4 is None))):
                    _hx_local_4
                else:
                    raise "Class cast error"
                return _hx_local_4
            headTerms = (_hx_local_5()).flattenTree(",")
            while (len(headTerms) > 0):
                tailNode = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST,[(None if ((len(headTerms) == 0)) else headTerms.pop()), tail])
                tail = tailNode
            return tail
        _hx_list = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST,[head, tail])
        return _hx_list

    def structureCheck(self,atom):
        tok = self.getNext(False)
        if ((self.lastWasOp and ((atom.value == "-"))) and (((tok.type == blub_prolog_stopgap_parse_TokenType.token_int) or ((tok.type == blub_prolog_stopgap_parse_TokenType.token_float))))):
            def _hx_local_1():
                _hx_local_0 = tok.value
                if (Std.isOfType(_hx_local_0,Float) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            val = _hx_local_1()
            val = -val
            return blub_prolog_terms_NumberTerm(val)
        if ((not self.operators.couldBeOp(atom.value)) and ((tok.type == blub_prolog_stopgap_parse_TokenType.token_open_paren))):
            return self.readStructure(atom)
        self.pushback(tok)
        text = atom.value
        a = self.context.getAtom(text)
        return a

    def readStructure(self,functor):
        args = self.readUntil(blub_prolog_stopgap_parse_TokenType.token_close_paren)
        if (args is None):
            raise haxe_Exception.thrown(self.oops("invalid structure - empty parentheses",functor))
        argTerms = None
        stru = args.asStructure()
        if (stru is not None):
            argTerms = stru.flattenTree(",")
        else:
            argTerms = list()
            argTerms.append(args)
        def _hx_local_2():
            def _hx_local_1():
                _hx_local_0 = functor.value
                if (Std.isOfType(_hx_local_0,str) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            return blub_prolog_terms_Structure(self.context.getAtom(_hx_local_1()),argTerms)
        return _hx_local_2()

    def pushback(self,tok):
        if (self.next is not None):
            raise haxe_Exception.thrown(self.oops("Pushback queue is too small",tok))
        self.next = tok

    def getNext(self,skipWS = None):
        if (skipWS is None):
            skipWS = True
        tok = None
        if (self.next is None):
            tok = self.lexer.next(skipWS)
        elif (skipWS and ((self.next.type == blub_prolog_stopgap_parse_TokenType.token_whitespace))):
            tok = self.lexer.next(True)
        else:
            tok = self.next
        self.next = None
        if (tok.type != blub_prolog_stopgap_parse_TokenType.token_eof):
            self.lastReadToken = tok
        return tok

    def oops(self,msg,tok = None):
        if (tok is None):
            tok = self.lastReadToken
        return blub_prolog_stopgap_parse_ParseError(msg,self.origin,tok.startLine,tok.startCol)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lexer = None
        _hx_o.origin = None
        _hx_o.next = None
        _hx_o.context = None
        _hx_o.operators = None
        _hx_o.lastReadToken = None
        _hx_o.lastWasOp = None
_hx_classes["blub.prolog.stopgap.parse.Parser"] = blub_prolog_stopgap_parse_Parser


class blub_prolog_stopgap_parse_Token:
    _hx_class_name = "blub.prolog.stopgap.parse.Token"
    __slots__ = ("startLine", "startCol", "endLine", "endCol", "value", "type")
    _hx_fields = ["startLine", "startCol", "endLine", "endCol", "value", "type"]
    _hx_methods = ["toString"]

    def __init__(self,_hx_type,chars,start = None,end = None):
        self.value = None
        self.type = _hx_type
        if (_hx_type == blub_prolog_stopgap_parse_TokenType.token_eof):
            return
        if (start is None):
            start = (chars[0] if 0 < len(chars) else None)
        if (end is None):
            end = python_internal_ArrayImpl._get(chars, (len(chars) - 1))
        self.startLine = start.line
        self.startCol = start.col
        self.endLine = end.line
        self.endCol = end.col
        s = "".join([python_Boot.toString1(x1,'') for x1 in chars])
        if (_hx_type == blub_prolog_stopgap_parse_TokenType.token_int):
            self.value = Std.parseInt(s)
        elif (_hx_type == blub_prolog_stopgap_parse_TokenType.token_float):
            self.value = Std.parseFloat(s)
        else:
            self.value = s

    def toString(self):
        return (((((((((((Std.string(self.type) + " [") + Std.string(self.startLine)) + ":") + Std.string(self.startCol)) + "-") + Std.string(self.endLine)) + ":") + Std.string(self.endCol)) + "] = '") + Std.string(self.value)) + "'")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.startLine = None
        _hx_o.startCol = None
        _hx_o.endLine = None
        _hx_o.endCol = None
        _hx_o.value = None
        _hx_o.type = None
_hx_classes["blub.prolog.stopgap.parse.Token"] = blub_prolog_stopgap_parse_Token

class blub_prolog_stopgap_parse_TokenType(Enum):
    __slots__ = ()
    _hx_class_name = "blub.prolog.stopgap.parse.TokenType"
    _hx_constructs = ["token_variable", "token_atom", "token_int", "token_float", "token_whitespace", "token_string", "token_term_end", "token_eof", "token_open_paren", "token_close_paren", "token_open_brace", "token_close_brace", "token_open_bracket", "token_close_bracket"]
blub_prolog_stopgap_parse_TokenType.token_variable = blub_prolog_stopgap_parse_TokenType("token_variable", 0, ())
blub_prolog_stopgap_parse_TokenType.token_atom = blub_prolog_stopgap_parse_TokenType("token_atom", 1, ())
blub_prolog_stopgap_parse_TokenType.token_int = blub_prolog_stopgap_parse_TokenType("token_int", 2, ())
blub_prolog_stopgap_parse_TokenType.token_float = blub_prolog_stopgap_parse_TokenType("token_float", 3, ())
blub_prolog_stopgap_parse_TokenType.token_whitespace = blub_prolog_stopgap_parse_TokenType("token_whitespace", 4, ())
blub_prolog_stopgap_parse_TokenType.token_string = blub_prolog_stopgap_parse_TokenType("token_string", 5, ())
blub_prolog_stopgap_parse_TokenType.token_term_end = blub_prolog_stopgap_parse_TokenType("token_term_end", 6, ())
blub_prolog_stopgap_parse_TokenType.token_eof = blub_prolog_stopgap_parse_TokenType("token_eof", 7, ())
blub_prolog_stopgap_parse_TokenType.token_open_paren = blub_prolog_stopgap_parse_TokenType("token_open_paren", 8, ())
blub_prolog_stopgap_parse_TokenType.token_close_paren = blub_prolog_stopgap_parse_TokenType("token_close_paren", 9, ())
blub_prolog_stopgap_parse_TokenType.token_open_brace = blub_prolog_stopgap_parse_TokenType("token_open_brace", 10, ())
blub_prolog_stopgap_parse_TokenType.token_close_brace = blub_prolog_stopgap_parse_TokenType("token_close_brace", 11, ())
blub_prolog_stopgap_parse_TokenType.token_open_bracket = blub_prolog_stopgap_parse_TokenType("token_open_bracket", 12, ())
blub_prolog_stopgap_parse_TokenType.token_close_bracket = blub_prolog_stopgap_parse_TokenType("token_close_bracket", 13, ())
_hx_classes["blub.prolog.stopgap.parse.TokenType"] = blub_prolog_stopgap_parse_TokenType


class blub_prolog_terms_ListTerm:
    _hx_class_name = "blub.prolog.terms.ListTerm"
    __slots__ = ()
    _hx_methods = ["listToArray"]
    _hx_interfaces = [blub_prolog_terms_ValueTerm]
_hx_classes["blub.prolog.terms.ListTerm"] = blub_prolog_terms_ListTerm


class blub_prolog_terms_Atom:
    _hx_class_name = "blub.prolog.terms.Atom"
    __slots__ = ("object", "text")
    _hx_fields = ["object", "text"]
    _hx_methods = ["getIndicator", "getHead", "getBody", "getFunctor", "getArgs", "getNameText", "toString", "asValueTerm", "asAtom", "asStructure", "asNumber", "asReference", "asUnchasedReference", "isGround", "hasReferences", "hasVariables", "dereference", "toValue", "commaSeparated", "gatherReferences", "couldMatch", "match", "equals", "unify", "isList", "listToArray"]
    _hx_statics = ["ID_GEN", "newUniqueAtom", "unregisteredAtom", "unquote", "escape", "A_CODE", "Z_CODE", "a_CODE", "z_CODE", "zero_CODE", "nine_CODE", "under_CODE"]
    _hx_interfaces = [blub_prolog_terms_ListTerm, blub_prolog_terms_ClauseTerm]

    def __init__(self,text):
        self.object = None
        self.text = text

    def getIndicator(self):
        return blub_prolog_PredicateIndicator(self,0)

    def getHead(self):
        return self

    def getBody(self):
        return None

    def getFunctor(self):
        return (HxOverrides.stringOrNull(self.text) + "/0")

    def getArgs(self):
        return []

    def getNameText(self):
        return self.text

    def toString(self):
        return blub_prolog_terms_Atom.escape(self.text)

    def asValueTerm(self):
        return self

    def asAtom(self):
        return self

    def asStructure(self):
        return None

    def asNumber(self):
        return None

    def asReference(self):
        return None

    def asUnchasedReference(self):
        return None

    def isGround(self):
        return True

    def hasReferences(self):
        return False

    def hasVariables(self):
        return False

    def dereference(self):
        return self

    def toValue(self,env):
        return self

    def commaSeparated(self):
        return [self]

    def gatherReferences(self,refs = None):
        if (refs is not None):
            return refs
        return []

    def couldMatch(self,arg):
        if (arg.asReference() is not None):
            return True
        return self.equals(arg)

    def match(self,other,env,trail):
        return self.equals(other.dereference())

    def equals(self,other):
        if (other is None):
            return False
        otherAtom = other.asAtom()
        if (otherAtom is None):
            return False
        if (self == otherAtom):
            return True
        if ((self.object is not None) and ((otherAtom.object is not None))):
            return HxOverrides.eq(self.object,otherAtom.object)
        return (self.text == otherAtom.text)

    def unify(self,other,trail):
        if (other.asReference() is not None):
            return other.unify(self,trail)
        return self.equals(other)

    def isList(self):
        return (self == blub_prolog_terms_Structure.EMPTY_LIST)

    def listToArray(self):
        if self.isList():
            return []
        return None

    @staticmethod
    def newUniqueAtom(prefix):
        def _hx_local_2():
            _hx_local_0 = blub_prolog_terms_Atom
            _hx_local_1 = _hx_local_0.ID_GEN
            _hx_local_0.ID_GEN = (_hx_local_1 + 1)
            return _hx_local_1
        tmp = (("null" if prefix is None else prefix) + Std.string(_hx_local_2()))
        return blub_prolog_terms_Atom(tmp)

    @staticmethod
    def unregisteredAtom(text):
        return blub_prolog_terms_Atom(text)

    @staticmethod
    def unquote(text):
        if (text.startswith("'") and text.endswith("'")):
            return HxString.substr(text,1,(len(text) - 2))
        return None

    @staticmethod
    def escape(s):
        if (s is None):
            return None
        if (len(s) == 0):
            return "''"
        if ((s == "{}") or ((s == "[]"))):
            return s
        b = StringBuf()
        needsEscape = False
        code = HxString.charCodeAt(s,0)
        char = ("" if ((0 >= len(s))) else s[0])
        if (((code >= blub_prolog_terms_Atom.a_CODE) and ((code <= blub_prolog_terms_Atom.z_CODE))) or blub_prolog_stopgap_parse_Char.isOpChar_(char)):
            needsEscape = False
        else:
            needsEscape = True
        _g = 0
        _g1 = len(s)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            code = HxString.charCodeAt(s,i)
            if ((((code == blub_prolog_terms_Atom.under_CODE) or (((code >= blub_prolog_terms_Atom.A_CODE) and ((code <= blub_prolog_terms_Atom.Z_CODE))))) or (((code >= blub_prolog_terms_Atom.a_CODE) and ((code <= blub_prolog_terms_Atom.z_CODE))))) or (((code >= blub_prolog_terms_Atom.zero_CODE) and ((code <= blub_prolog_terms_Atom.nine_CODE))))):
                s1 = "".join(map(chr,[code]))
                b.b.write(s1)
                continue
            char = ("" if (((i < 0) or ((i >= len(s))))) else s[i])
            if blub_prolog_stopgap_parse_Char.isOpChar_(char):
                s2 = Std.string(char)
                b.b.write(s2)
                continue
            needsEscape = True
            s3 = None
            char1 = char
            if (char1 == "\t"):
                s3 = " "
            elif (char1 == "\n"):
                s3 = " "
            elif (char1 == "\r"):
                s3 = " "
            elif (char1 == "'"):
                s3 = "''"
            elif (char1 == "\\"):
                s3 = "\\\\"
            else:
                s3 = char
            s4 = Std.string(s3)
            b.b.write(s4)
        if needsEscape:
            return (("'" + Std.string(b)) + "'")
        else:
            return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.object = None
        _hx_o.text = None
_hx_classes["blub.prolog.terms.Atom"] = blub_prolog_terms_Atom


class blub_prolog_terms_NumberTerm:
    _hx_class_name = "blub.prolog.terms.NumberTerm"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["asValueTerm", "asAtom", "asStructure", "asNumber", "asReference", "asUnchasedReference", "isGround", "hasReferences", "hasVariables", "dereference", "toValue", "commaSeparated", "gatherReferences", "toString", "equals", "match", "couldMatch", "unify"]
    _hx_interfaces = [blub_prolog_terms_ValueTerm]

    def __init__(self,value):
        self.value = value

    def asValueTerm(self):
        return self

    def asAtom(self):
        return None

    def asStructure(self):
        return None

    def asNumber(self):
        return self

    def asReference(self):
        return None

    def asUnchasedReference(self):
        return None

    def isGround(self):
        return True

    def hasReferences(self):
        return False

    def hasVariables(self):
        return False

    def dereference(self):
        return self

    def toValue(self,env):
        return self

    def commaSeparated(self):
        return [self]

    def gatherReferences(self,refs = None):
        if (refs is not None):
            return refs
        return []

    def toString(self):
        return Std.string(self.value)

    def equals(self,other):
        otherNum = other.asNumber()
        if (otherNum is None):
            return False
        return (otherNum.value == self.value)

    def match(self,other,env,trail):
        return self.equals(other.dereference())

    def couldMatch(self,arg):
        if (arg.asReference() is not None):
            return True
        return self.equals(arg)

    def unify(self,other,trail):
        if (other.asReference() is not None):
            return other.unify(self,trail)
        return self.equals(other)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
_hx_classes["blub.prolog.terms.NumberTerm"] = blub_prolog_terms_NumberTerm


class blub_prolog_terms_Structure:
    _hx_class_name = "blub.prolog.terms.Structure"
    __slots__ = ("args", "atom", "hasVars", "hasRefs", "varContext", "variableContext")
    _hx_fields = ["args", "atom", "hasVars", "hasRefs", "varContext"]
    _hx_methods = ["addArg", "prependArg", "updateArg", "forceHasRefs", "asValueTerm", "asAtom", "asStructure", "asNumber", "asReference", "asUnchasedReference", "hasReferences", "hasVariables", "isGround", "equals", "match", "couldMatch", "unify", "isConjunction", "isDisjunction", "variablize", "unpackParentheses", "toValue", "varsToReferences", "hasUnboundRefs", "gatherReferences", "dereference", "getHead", "getBody", "get_variableContext", "useVarContext", "initContext", "argAt", "getArgs", "getArity", "getName", "getIndicator", "getFunctor", "getNameText", "clone", "flattenTree", "commaSeparated", "commaList", "couldBeList", "isList", "listIterator", "listStructureIterator", "listToArray", "toArray", "listToString", "commaToString", "toString"]
    _hx_statics = ["CONS_LIST", "EMPTY_LIST", "make", "make2", "makeList"]
    _hx_interfaces = [blub_prolog_terms_ListTerm, blub_prolog_terms_ClauseTerm]

    def __init__(self,name,arguments = None):
        self.variableContext = None
        self.varContext = None
        self.hasRefs = None
        self.hasVars = None
        self.args = None
        self.atom = name
        if (arguments is not None):
            self.args = arguments
            _g = 0
            _g1 = self.args
            while (_g < len(_g1)):
                arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.hasRefs = (self.hasRefs or arg.hasReferences())
                self.hasVars = (self.hasVars or arg.hasVariables())
        else:
            self.args = list()

    def addArg(self,t):
        _this = self.args
        _this.append(t)
        self.hasRefs = (self.hasRefs or t.hasReferences())
        self.hasVars = (self.hasVars or t.hasVariables())

    def prependArg(self,t):
        self.args.insert(0, t)
        self.hasRefs = (self.hasRefs or t.hasReferences())
        self.hasVars = (self.hasVars or t.hasVariables())

    def updateArg(self,arg):
        self.hasRefs = (self.hasRefs or arg.hasReferences())
        self.hasVars = (self.hasVars or arg.hasVariables())

    def forceHasRefs(self):
        self.hasRefs = True

    def asValueTerm(self):
        return self

    def asAtom(self):
        return None

    def asStructure(self):
        return self

    def asNumber(self):
        return None

    def asReference(self):
        return None

    def asUnchasedReference(self):
        return None

    def hasReferences(self):
        return self.hasRefs

    def hasVariables(self):
        return self.hasVars

    def isGround(self):
        if self.hasVars:
            return False
        return (not self.hasUnboundRefs())

    def equals(self,other):
        otherS = other.asStructure()
        if (otherS is None):
            return False
        if (not self.atom.equals(otherS.atom)):
            return False
        if (len(self.args) != len(otherS.args)):
            return False
        _g = 0
        _g1 = len(self.args)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (not (self.args[i] if i >= 0 and i < len(self.args) else None).equals((otherS.args[i] if i >= 0 and i < len(otherS.args) else None))):
                return False
        return True

    def match(self,other,env,trail):
        otherStruct = other.asStructure()
        if (otherStruct is None):
            return False
        if (not self.atom.equals(otherStruct.atom)):
            return False
        if (len(self.args) != len(otherStruct.args)):
            return False
        otherArgs = otherStruct.args
        _g = 0
        _g1 = len(self.args)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (not (self.args[i] if i >= 0 and i < len(self.args) else None).match((otherArgs[i] if i >= 0 and i < len(otherArgs) else None).asValueTerm(),env,trail)):
                return False
        return True

    def couldMatch(self,arg):
        if (arg.asReference() is not None):
            return True
        argStruct = arg.asStructure()
        if (argStruct is None):
            return False
        if argStruct.atom.equals(self.atom):
            return (argStruct.getArity() == self.getArity())
        else:
            return False

    def unify(self,other,trail):
        if (other.asReference() is not None):
            return other.unify(self,trail)
        stru = other.asStructure()
        if (stru is None):
            return False
        if (not self.atom.equals(stru.atom)):
            return False
        if (len(self.args) != len(stru.args)):
            return False
        _g = 0
        _g1 = len(self.args)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            arg1 = (self.args[i] if i >= 0 and i < len(self.args) else None).asValueTerm()
            arg2 = (stru.args[i] if i >= 0 and i < len(stru.args) else None).asValueTerm()
            if (not arg1.unify(arg2,trail)):
                return False
        return True

    def isConjunction(self):
        if (len(self.args) == 2):
            return (self.atom.text == ",")
        else:
            return False

    def isDisjunction(self):
        if (len(self.args) == 2):
            return (self.atom.text == ";")
        else:
            return False

    def variablize(self,varMap = None):
        if self.hasVars:
            return self
        if (not self.hasRefs):
            return self
        if (varMap is None):
            varMap = haxe_ds_ObjectMap()
        copy = blub_prolog_terms_Structure(self.atom)
        _g = 0
        _g1 = self.args
        while (_g < len(_g1)):
            arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            ref = arg.asReference()
            if (ref is not None):
                v = varMap.h.get(ref,None)
                if (v is None):
                    v = blub_prolog_terms_Variable(ref.get_name())
                    varMap.set(ref,v)
                copy.addArg(v)
            else:
                stru = arg.asStructure()
                if (stru is not None):
                    copy.addArg(stru.variablize(varMap))
                else:
                    copy.addArg(arg)
        return copy

    def unpackParentheses(self):
        if (self.atom.text == "()"):
            s = self.argAt(0).asStructure()
            if (s is not None):
                return s.unpackParentheses()
            return self.argAt(0)
        _g = 0
        _g1 = len(self.args)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = (self.args[i] if i >= 0 and i < len(self.args) else None).asStructure()
            if (s is not None):
                python_internal_ArrayImpl._set(self.args, i, s.unpackParentheses())
        return self

    def toValue(self,env):
        if (not self.hasVars):
            return self
        copy = blub_prolog_terms_Structure(self.atom)
        _g = 0
        _g1 = self.args
        while (_g < len(_g1)):
            arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            copy.addArg(arg.toValue(env))
        return copy

    def varsToReferences(self):
        if (not self.hasVars):
            return self
        env = self.get_variableContext().createNamedEnvironment()
        return self.toValue(env)

    def hasUnboundRefs(self):
        if (not self.hasRefs):
            return False
        if (self.atom == blub_prolog_terms_Structure.CONS_LIST):
            queue = haxe_ds_List()
            queue.add(self)
            while (not queue.isEmpty()):
                s = queue.pop()
                arg1 = s.argAt(0)
                if (not arg1.isGround()):
                    return True
                arg2 = s.argAt(1)
                _hx_str = arg2.asStructure()
                if ((_hx_str is not None) and ((_hx_str.atom == blub_prolog_terms_Structure.CONS_LIST))):
                    queue.add(_hx_str)
                elif (not arg2.isGround()):
                    return True
        else:
            _g = 0
            _g1 = self.args
            while (_g < len(_g1)):
                arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (not arg.isGround()):
                    return True
        return False

    def gatherReferences(self,refs = None):
        if (refs is None):
            refs = []
        _g = 0
        _g1 = self.args
        while (_g < len(_g1)):
            arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            vt = arg.asValueTerm()
            if (vt is not None):
                vt.gatherReferences(refs)
        return refs

    def dereference(self):
        if (not self.hasRefs):
            return self
        if (self.atom == blub_prolog_terms_Structure.CONS_LIST):
            elems = []
            head = self
            while True:
                if (not head.hasRefs):
                    elems.append(head)
                    break
                headCopy = blub_prolog_terms_Structure(head.getName())
                headCopy.addArg(head.argAt(0).asValueTerm().dereference())
                elems.append(headCopy)
                if (head.argAt(1) is None):
                    break
                next = head.argAt(1).asValueTerm()
                if (next.asStructure() is not None):
                    head = next.asStructure()
                else:
                    headCopy.addArg(next.dereference())
                    break
            tail = None
            while (len(elems) > 0):
                elem = (None if ((len(elems) == 0)) else elems.pop())
                if (tail is not None):
                    elem.addArg(tail)
                tail = elem
            return tail.asStructure()
        else:
            copy = blub_prolog_terms_Structure(self.atom)
            _g = 0
            _g1 = self.args
            while (_g < len(_g1)):
                arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                valTerm = arg
                copy.addArg(valTerm.dereference())
            return copy

    def getHead(self):
        if (((self.atom.text == ":-") and ((len(self.args) == 2))) and Std.isOfType((self.args[0] if 0 < len(self.args) else None),blub_prolog_terms_ClauseTerm)):
            def _hx_local_2():
                def _hx_local_1():
                    _hx_local_0 = (self.args[0] if 0 < len(self.args) else None)
                    if (Std.isOfType(_hx_local_0,blub_prolog_terms_ClauseTerm) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                return _hx_local_1()
            return _hx_local_2()
        return self

    def getBody(self):
        if (((self.atom.text == ":-") and ((len(self.args) == 2))) and Std.isOfType((self.args[1] if 1 < len(self.args) else None),blub_prolog_terms_ClauseTerm)):
            def _hx_local_2():
                def _hx_local_1():
                    _hx_local_0 = (self.args[1] if 1 < len(self.args) else None)
                    if (Std.isOfType(_hx_local_0,blub_prolog_terms_ClauseTerm) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                return _hx_local_1()
            return _hx_local_2()
        return None

    def get_variableContext(self):
        if (self.varContext is None):
            name2var = haxe_ds_StringMap()
            index2var = list()
            self.initContext(blub_prolog_terms_VariableContext(self,name2var,index2var),name2var,index2var)
        return self.varContext

    def useVarContext(self,context,name2var,index2var):
        self.initContext(context,name2var,index2var)

    def initContext(self,context,name2var,index2var):
        self.varContext = context
        _g = 0
        _g1 = len(self.args)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            arg = (self.args[i] if i >= 0 and i < len(self.args) else None)
            if Std.isOfType(arg,blub_prolog_terms_Variable):
                def _hx_local_1():
                    _hx_local_0 = arg
                    if (Std.isOfType(_hx_local_0,blub_prolog_terms_Variable) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                argVar = _hx_local_1()
                if (argVar.get_name() == "_"):
                    continue
                key = argVar.get_name()
                v = name2var.h.get(key,None)
                if (v is None):
                    if (argVar.index != -1):
                        haxe_Log.trace(((("OOPS " + HxOverrides.stringOrNull(argVar.get_name())) + " ") + Std.string(self)),_hx_AnonObject({'fileName': "src/blub/prolog/terms/Structure.hx", 'lineNumber': 434, 'className': "blub.prolog.terms.Structure", 'methodName': "initContext"}))
                    argVar.initIndex(len(index2var))
                    key1 = argVar.get_name()
                    name2var.h[key1] = argVar
                    index2var.append(argVar)
                else:
                    python_internal_ArrayImpl._set(self.args, i, v)
            elif Std.isOfType(arg,blub_prolog_terms_Structure):
                def _hx_local_3():
                    _hx_local_2 = arg
                    if (Std.isOfType(_hx_local_2,blub_prolog_terms_Structure) or ((_hx_local_2 is None))):
                        _hx_local_2
                    else:
                        raise "Class cast error"
                    return _hx_local_2
                argStruct = _hx_local_3()
                argStruct.initContext(context,name2var,index2var)

    def argAt(self,index):
        return (self.args[index] if index >= 0 and index < len(self.args) else None)

    def getArgs(self):
        return self.args

    def getArity(self):
        return len(self.args)

    def getName(self):
        return self.atom

    def getIndicator(self):
        return blub_prolog_PredicateIndicator(self.atom,len(self.args))

    def getFunctor(self):
        return ((HxOverrides.stringOrNull(self.atom.text) + "/") + Std.string(len(self.args)))

    def getNameText(self):
        return self.atom.text

    def clone(self,fn):
        s = blub_prolog_terms_Structure(self.atom)
        _g = 0
        _g1 = self.args
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s.addArg(fn(a))
        return s

    def flattenTree(self,func = None):
        if (func is None):
            func = self.atom.text
        terms = list()
        tree = self
        while True:
            if ((tree.atom.text == func) and ((len(tree.args) == 2))):
                args = tree.args
                terms.append((args[0] if 0 < len(args) else None))
                if Std.isOfType((args[1] if 1 < len(args) else None),blub_prolog_terms_Structure):
                    def _hx_local_1():
                        _hx_local_0 = (args[1] if 1 < len(args) else None)
                        if (Std.isOfType(_hx_local_0,blub_prolog_terms_Structure) or ((_hx_local_0 is None))):
                            _hx_local_0
                        else:
                            raise "Class cast error"
                        return _hx_local_0
                    tree = _hx_local_1()
                else:
                    terms.append((args[1] if 1 < len(args) else None))
                    break
            else:
                terms.append(tree)
                break
        return terms

    def commaSeparated(self):
        return self.commaList()

    def commaList(self,array = None):
        if (array is None):
            array = list()
        if (self.atom.text == ","):
            x = (self.args[0] if 0 < len(self.args) else None)
            array.append(x)
            arg1struct = (self.args[1] if 1 < len(self.args) else None).asStructure()
            if (arg1struct is not None):
                arg1struct.commaList(array)
            else:
                x = (self.args[1] if 1 < len(self.args) else None)
                array.append(x)
            return array
        else:
            array.append(self)
        return array

    def couldBeList(self):
        if (self.atom == blub_prolog_terms_Structure.CONS_LIST):
            return (self.getArity() == 2)
        else:
            return False

    def isList(self):
        _hx_str = self
        while ((_hx_str.atom == blub_prolog_terms_Structure.CONS_LIST) and ((_hx_str.getArity() == 2))):
            tail = _hx_str.argAt(1)
            atm = tail.asAtom()
            if (atm is not None):
                return atm.isList()
            ref = tail.asReference()
            if (ref is not None):
                return True
            _hx_str = tail.asStructure()
            if (_hx_str is None):
                return False
        return False

    def listIterator(self):
        return blub_prolog_terms__Structure_ListIterator(self)

    def listStructureIterator(self):
        return blub_prolog_terms__Structure_ListStructureIterator(self)

    def listToArray(self):
        return self.toArray()

    def toArray(self,array = None):
        if (self.atom == blub_prolog_terms_Structure.CONS_LIST):
            if (array is None):
                array = list()
            x = (self.args[0] if 0 < len(self.args) else None)
            array.append(x)
            s = (self.args[1] if 1 < len(self.args) else None).asStructure()
            if (s is not None):
                s.toArray(array)
            return array
        return None

    def listToString(self):
        buf_b = python_lib_io_StringIO()
        buf_b.write("[")
        stru = self
        while True:
            arg0 = stru.argAt(0)
            if (arg0 is None):
                buf_b.write("<???>")
                break
            buf_b.write(Std.string(arg0.toString()))
            tail = stru.argAt(1)
            if (tail is None):
                buf_b.write("|<???>")
                break
            if (tail.asReference() is not None):
                tail = tail.asReference().dereference()
            if (tail == blub_prolog_terms_Structure.EMPTY_LIST):
                break
            tailS = tail.asStructure()
            if ((tailS is not None) and ((tailS.atom == blub_prolog_terms_Structure.CONS_LIST))):
                buf_b.write(",")
                stru = tailS
                continue
            buf_b.write("|")
            buf_b.write(Std.string(tail.toString()))
            break
        buf_b.write("]")
        return buf_b.getvalue()

    def commaToString(self,s = None):
        if (s is None):
            s = "("
        if (self.atom.text == ","):
            _g = 0
            _g1 = len(self.args)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (i > 0):
                    s = (("null" if s is None else s) + ",")
                if Std.isOfType((self.args[i] if i >= 0 and i < len(self.args) else None),blub_prolog_terms_Structure):
                    def _hx_local_2():
                        _hx_local_1 = (self.args[i] if i >= 0 and i < len(self.args) else None)
                        if (Std.isOfType(_hx_local_1,blub_prolog_terms_Structure) or ((_hx_local_1 is None))):
                            _hx_local_1
                        else:
                            raise "Class cast error"
                        return _hx_local_1
                    s = (_hx_local_2()).commaToString(s)
                else:
                    s = (("null" if s is None else s) + (("" + Std.string((self.args[i] if i >= 0 and i < len(self.args) else None)))))
        else:
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(self.toString()))
        return s

    def toString(self):
        if (self.atom == blub_prolog_terms_Structure.CONS_LIST):
            return self.listToString()
        if (self.atom.text == ","):
            return (HxOverrides.stringOrNull(self.commaToString()) + ")")
        s = self.atom.toString()
        s = (("null" if s is None else s) + "( ")
        first = True
        _g = 0
        _g1 = self.args
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if first:
                first = False
            else:
                s = (("null" if s is None else s) + ", ")
            s = (("null" if s is None else s) + Std.string(t))
        s = (("null" if s is None else s) + " )")
        return s

    @staticmethod
    def make(functor,arg):
        s = blub_prolog_terms_Structure(functor,[arg])
        return s

    @staticmethod
    def make2(functor,arg1,arg2):
        s = blub_prolog_terms_Structure(functor,[arg1, arg2])
        return s

    @staticmethod
    def makeList(elems):
        if (len(elems) == 0):
            return blub_prolog_terms_Structure.EMPTY_LIST
        tail = blub_prolog_terms_Structure.EMPTY_LIST
        while (len(elems) > 0):
            elem = (None if ((len(elems) == 0)) else elems.pop())
            s = blub_prolog_terms_Structure(blub_prolog_terms_Structure.CONS_LIST)
            s.addArg(elem)
            s.addArg(tail)
            tail = s
        return tail

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.args = None
        _hx_o.atom = None
        _hx_o.hasVars = None
        _hx_o.hasRefs = None
        _hx_o.varContext = None
_hx_classes["blub.prolog.terms.Structure"] = blub_prolog_terms_Structure


class blub_prolog_terms__Structure_ListStructureIterator:
    _hx_class_name = "blub.prolog.terms._Structure.ListStructureIterator"
    __slots__ = ("s",)
    _hx_fields = ["s"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,s):
        self.s = s

    def next(self):
        if (self.s.getName() == blub_prolog_terms_Structure.CONS_LIST):
            stru = self.s
            self.s = self.s.argAt(1).asStructure()
            return stru
        return None

    def hasNext(self):
        return (self.s.getName() == blub_prolog_terms_Structure.CONS_LIST)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None
_hx_classes["blub.prolog.terms._Structure.ListStructureIterator"] = blub_prolog_terms__Structure_ListStructureIterator


class blub_prolog_terms__Structure_ListIterator:
    _hx_class_name = "blub.prolog.terms._Structure.ListIterator"
    __slots__ = ("s",)
    _hx_fields = ["s"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,s):
        self.s = s

    def next(self):
        if (self.s.getName() == blub_prolog_terms_Structure.CONS_LIST):
            elem = self.s.argAt(0)
            self.s = self.s.argAt(1).asStructure()
            return elem
        return None

    def hasNext(self):
        return (self.s.getName() == blub_prolog_terms_Structure.CONS_LIST)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None
_hx_classes["blub.prolog.terms._Structure.ListIterator"] = blub_prolog_terms__Structure_ListIterator


class blub_prolog_terms_TermParse:
    _hx_class_name = "blub.prolog.terms.TermParse"
    __slots__ = ()
    _hx_statics = ["parse"]

    @staticmethod
    def parse(s,context = None,operators = None):
        if (context is None):
            context = blub_prolog_AtomContext.GLOBALS
        if (operators is None):
            operators = blub_prolog_stopgap_parse_Operators()
            operators.addStandardOps()
        index = (len(s) - 1)
        if ((("" if (((index < 0) or ((index >= len(s))))) else s[index])) != "."):
            s = (("null" if s is None else s) + " .")
        parser = blub_prolog_stopgap_parse_Parser(context,operators,s,"method=Term.parse()")
        return parser.nextTerm()
_hx_classes["blub.prolog.terms.TermParse"] = blub_prolog_terms_TermParse


class blub_prolog_terms_Variable:
    _hx_class_name = "blub.prolog.terms.Variable"
    __slots__ = ("index", "_name", "name")
    _hx_fields = ["index", "_name"]
    _hx_methods = ["asValueTerm", "asAtom", "asStructure", "asNumber", "asReference", "asUnchasedReference", "isGround", "hasReferences", "hasVariables", "toValue", "commaSeparated", "equals", "match", "couldMatch", "initIndex", "toString", "get_name"]
    _hx_statics = ["nameCount"]
    _hx_interfaces = [blub_prolog_terms_Term]

    def __init__(self,name = None):
        self.name = None
        self._name = name
        self.index = -1

    def asValueTerm(self):
        return None

    def asAtom(self):
        return None

    def asStructure(self):
        return None

    def asNumber(self):
        return None

    def asReference(self):
        return None

    def asUnchasedReference(self):
        return None

    def isGround(self):
        return False

    def hasReferences(self):
        return False

    def hasVariables(self):
        return True

    def toValue(self,env):
        if (self.index < 0):
            return blub_prolog_terms_Reference()
        return python_internal_ArrayImpl._get(env, self.index)

    def commaSeparated(self):
        return [self]

    def equals(self,other):
        return (self == other)

    def match(self,other,env,trail):
        if ((env is None) or ((self.get_name() == "_"))):
            return True
        if (self.index >= len(env)):
            return False
        ref = python_internal_ArrayImpl._get(env, self.index)
        return ref.match(other,env,trail)

    def couldMatch(self,arg):
        return True

    def initIndex(self,index):
        if (self.index != -1):
            raise haxe_Exception.thrown(((((("Cannot set var index more than once - " + HxOverrides.stringOrNull(self._name)) + " was ") + Std.string(self.index)) + ", setting to ") + Std.string(index)))
        self.index = index

    def toString(self):
        return self.get_name()

    def get_name(self):
        if (self._name is None):
            def _hx_local_2():
                _hx_local_0 = blub_prolog_terms_Variable
                _hx_local_1 = _hx_local_0.nameCount
                _hx_local_0.nameCount = (_hx_local_1 + 1)
                return _hx_local_1
            self._name = ("_G" + Std.string(_hx_local_2()))
        return self._name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o._name = None
_hx_classes["blub.prolog.terms.Variable"] = blub_prolog_terms_Variable


class blub_prolog_terms_VariableContext:
    _hx_class_name = "blub.prolog.terms.VariableContext"
    __slots__ = ("root", "count", "name2var", "index2var")
    _hx_fields = ["root", "name2var", "index2var"]
    _hx_methods = ["varNamed", "varAt", "variables", "variableNames", "createEnvironment", "createNamedEnvironment", "get_count", "toString"]
    _hx_statics = ["EMPTY"]

    def __init__(self,root,name2var,index2var):
        self.count = None
        self.root = root
        self.index2var = index2var
        self.name2var = name2var

    def varNamed(self,name):
        return self.name2var.h.get(name,None)

    def varAt(self,index):
        return (self.index2var[index] if index >= 0 and index < len(self.index2var) else None)

    def variables(self):
        return haxe_iterators_ArrayIterator(self.index2var)

    def variableNames(self):
        names = list()
        v = self.variables()
        while v.hasNext():
            v1 = v.next()
            x = v1.get_name()
            names.append(x)
        return names

    def createEnvironment(self):
        c = self.get_count()
        if (c == 0):
            return None
        environment = list()
        _g = 0
        _g1 = c
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = blub_prolog_terms_Reference()
            environment.append(x)
        return environment

    def createNamedEnvironment(self):
        if (self.get_count() == 0):
            return None
        environment = list()
        _g = 0
        _g1 = self.index2var
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            x = blub_prolog_terms_Reference(v.get_name())
            environment.append(x)
        return environment

    def get_count(self):
        return len(self.index2var)

    def toString(self):
        return ("VariableContext:" + Std.string(self.index2var))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.name2var = None
        _hx_o.index2var = None
_hx_classes["blub.prolog.terms.VariableContext"] = blub_prolog_terms_VariableContext

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
_hx_classes["haxe.StackItem"] = haxe_StackItem


class haxe__CallStack_CallStack_Impl_:
    _hx_class_name = "haxe._CallStack.CallStack_Impl_"
    __slots__ = ()
    _hx_statics = ["get_length", "callStack", "exceptionStack", "toString", "subtract", "copy", "get", "asArray", "equalItems", "exceptionToString", "itemToString"]
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def callStack():
        infos = python_lib_Traceback.extract_stack()
        if (len(infos) != 0):
            infos.pop()
        infos.reverse()
        return haxe_NativeStackTrace.toHaxe(infos)

    @staticmethod
    def exceptionStack():
        eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack())
        return haxe__CallStack_CallStack_Impl_.subtract(eStack,haxe__CallStack_CallStack_Impl_.callStack())

    @staticmethod
    def toString(stack):
        b = StringBuf()
        _g = 0
        _g1 = stack
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.b.write("\nCalled from ")
            haxe__CallStack_CallStack_Impl_.itemToString(b,s)
        return b.b.getvalue()

    @staticmethod
    def subtract(this1,stack):
        startIndex = -1
        i = -1
        while True:
            i = (i + 1)
            tmp = i
            if (not ((tmp < len(this1)))):
                break
            _g = 0
            _g1 = len(stack)
            while (_g < _g1):
                j = _g
                _g = (_g + 1)
                if haxe__CallStack_CallStack_Impl_.equalItems((this1[i] if i >= 0 and i < len(this1) else None),python_internal_ArrayImpl._get(stack, j)):
                    if (startIndex < 0):
                        startIndex = i
                    i = (i + 1)
                    if (i >= len(this1)):
                        break
                else:
                    startIndex = -1
            if (startIndex >= 0):
                break
        if (startIndex >= 0):
            return this1[0:startIndex]
        else:
            return this1

    @staticmethod
    def copy(this1):
        return list(this1)

    @staticmethod
    def get(this1,index):
        return (this1[index] if index >= 0 and index < len(this1) else None)

    @staticmethod
    def asArray(this1):
        return this1

    @staticmethod
    def equalItems(item1,item2):
        if (item1 is None):
            if (item2 is None):
                return True
            else:
                return False
        else:
            tmp = item1.index
            if (tmp == 0):
                if (item2 is None):
                    return False
                elif (item2.index == 0):
                    return True
                else:
                    return False
            elif (tmp == 1):
                if (item2 is None):
                    return False
                elif (item2.index == 1):
                    m1 = item1.params[0]
                    m2 = item2.params[0]
                    return (m1 == m2)
                else:
                    return False
            elif (tmp == 2):
                if (item2 is None):
                    return False
                elif (item2.index == 2):
                    item11 = item1.params[0]
                    file1 = item1.params[1]
                    line1 = item1.params[2]
                    col1 = item1.params[3]
                    col2 = item2.params[3]
                    line2 = item2.params[2]
                    file2 = item2.params[1]
                    item21 = item2.params[0]
                    if (((file1 == file2) and ((line1 == line2))) and ((col1 == col2))):
                        return haxe__CallStack_CallStack_Impl_.equalItems(item11,item21)
                    else:
                        return False
                else:
                    return False
            elif (tmp == 3):
                if (item2 is None):
                    return False
                elif (item2.index == 3):
                    class1 = item1.params[0]
                    method1 = item1.params[1]
                    method2 = item2.params[1]
                    class2 = item2.params[0]
                    if (class1 == class2):
                        return (method1 == method2)
                    else:
                        return False
                else:
                    return False
            elif (tmp == 4):
                if (item2 is None):
                    return False
                elif (item2.index == 4):
                    v1 = item1.params[0]
                    v2 = item2.params[0]
                    return (v1 == v2)
                else:
                    return False
            else:
                pass

    @staticmethod
    def exceptionToString(e):
        if (e.get_previous() is None):
            tmp = ("Exception: " + HxOverrides.stringOrNull(e.get_message()))
            tmp1 = e.get_stack()
            return (("null" if tmp is None else tmp) + HxOverrides.stringOrNull((("null" if ((tmp1 is None)) else haxe__CallStack_CallStack_Impl_.toString(tmp1)))))
        result = ""
        e1 = e
        prev = None
        while (e1 is not None):
            if (prev is None):
                result1 = ("Exception: " + HxOverrides.stringOrNull(e1.get_message()))
                tmp = e1.get_stack()
                result = ((("null" if result1 is None else result1) + HxOverrides.stringOrNull((("null" if ((tmp is None)) else haxe__CallStack_CallStack_Impl_.toString(tmp))))) + ("null" if result is None else result))
            else:
                prevStack = haxe__CallStack_CallStack_Impl_.subtract(e1.get_stack(),prev.get_stack())
                result = (((("Exception: " + HxOverrides.stringOrNull(e1.get_message())) + HxOverrides.stringOrNull((("null" if ((prevStack is None)) else haxe__CallStack_CallStack_Impl_.toString(prevStack))))) + "\n\nNext ") + ("null" if result is None else result))
            prev = e1
            e1 = e1.get_previous()
        return result

    @staticmethod
    def itemToString(b,s):
        tmp = s.index
        if (tmp == 0):
            b.b.write("a C function")
        elif (tmp == 1):
            m = s.params[0]
            b.b.write("module ")
            s1 = Std.string(m)
            b.b.write(s1)
        elif (tmp == 2):
            col = s.params[3]
            line = s.params[2]
            file = s.params[1]
            s1 = s.params[0]
            if (s1 is not None):
                haxe__CallStack_CallStack_Impl_.itemToString(b,s1)
                b.b.write(" (")
            s2 = Std.string(file)
            b.b.write(s2)
            b.b.write(" line ")
            s2 = Std.string(line)
            b.b.write(s2)
            if (col is not None):
                b.b.write(" column ")
                s2 = Std.string(col)
                b.b.write(s2)
            if (s1 is not None):
                b.b.write(")")
        elif (tmp == 3):
            meth = s.params[1]
            cname = s.params[0]
            s1 = Std.string(("<unknown>" if ((cname is None)) else cname))
            b.b.write(s1)
            b.b.write(".")
            s1 = Std.string(meth)
            b.b.write(s1)
        elif (tmp == 4):
            n = s.params[0]
            b.b.write("local function #")
            s = Std.string(n)
            b.b.write(s)
        else:
            pass
_hx_classes["haxe._CallStack.CallStack_Impl_"] = haxe__CallStack_CallStack_Impl_


class haxe__EntryPoint_Lock:
    _hx_class_name = "haxe._EntryPoint.Lock"
    __slots__ = ()
    _hx_methods = ["release", "wait"]

    def __init__(self):
        pass

    def release(self):
        pass

    def wait(self,t = None):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["haxe._EntryPoint.Lock"] = haxe__EntryPoint_Lock


class haxe__EntryPoint_Mutex:
    _hx_class_name = "haxe._EntryPoint.Mutex"
    __slots__ = ()
    _hx_methods = ["acquire", "release"]

    def __init__(self):
        pass

    def acquire(self):
        pass

    def release(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["haxe._EntryPoint.Mutex"] = haxe__EntryPoint_Mutex


class haxe__EntryPoint_Thread:
    _hx_class_name = "haxe._EntryPoint.Thread"
    __slots__ = ()
    _hx_statics = ["create"]

    @staticmethod
    def create(f):
        f()
_hx_classes["haxe._EntryPoint.Thread"] = haxe__EntryPoint_Thread


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["sleepLock", "mutex", "pending", "threadCount", "wakeup", "runInMainThread", "addThread", "processEvents", "run"]

    @staticmethod
    def wakeup():
        pass

    @staticmethod
    def runInMainThread(f):
        _this = haxe_EntryPoint.pending
        _this.append(f)
        haxe_EntryPoint.wakeup()

    @staticmethod
    def addThread(f):
        _hx_local_0 = haxe_EntryPoint
        _hx_local_1 = _hx_local_0.threadCount
        _hx_local_0.threadCount = (_hx_local_1 + 1)
        _hx_local_1
        def _hx_local_4():
            f()
            _hx_local_2 = haxe_EntryPoint
            _hx_local_3 = _hx_local_2.threadCount
            _hx_local_2.threadCount = (_hx_local_3 - 1)
            _hx_local_3
            if (haxe_EntryPoint.threadCount == 0):
                haxe_EntryPoint.wakeup()
        haxe__EntryPoint_Thread.create(_hx_local_4)

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while True:
            nextTick = haxe_EntryPoint.processEvents()
            if (nextTick < 0):
                break
            tmp = (nextTick > 0)
_hx_classes["haxe.EntryPoint"] = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___exceptionStack", "_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__exceptionStack", "__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "details", "__shiftStack", "get_message", "get_previous", "get_native", "get_stack"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___exceptionStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def details(self):
        if (self.get_previous() is None):
            tmp = ("Exception: " + HxOverrides.stringOrNull(self.get_message()))
            tmp1 = self.get_stack()
            return (("null" if tmp is None else tmp) + HxOverrides.stringOrNull((("null" if ((tmp1 is None)) else haxe__CallStack_CallStack_Impl_.toString(tmp1)))))
        else:
            result = ""
            e = self
            prev = None
            while (e is not None):
                if (prev is None):
                    result1 = ("Exception: " + HxOverrides.stringOrNull(e.get_message()))
                    tmp = e.get_stack()
                    result = ((("null" if result1 is None else result1) + HxOverrides.stringOrNull((("null" if ((tmp is None)) else haxe__CallStack_CallStack_Impl_.toString(tmp))))) + ("null" if result is None else result))
                else:
                    prevStack = haxe__CallStack_CallStack_Impl_.subtract(e.get_stack(),prev.get_stack())
                    result = (((("Exception: " + HxOverrides.stringOrNull(e.get_message())) + HxOverrides.stringOrNull((("null" if ((prevStack is None)) else haxe__CallStack_CallStack_Impl_.toString(prevStack))))) + "\n\nNext ") + ("null" if result is None else result))
                prev = e
                e = e.get_previous()
            return result

    def _hx___shiftStack(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1

    def get_message(self):
        return str(self)

    def get_previous(self):
        return self._hx___previousException

    def get_native(self):
        return self._hx___nativeException

    def get_stack(self):
        _g = self._hx___exceptionStack
        if (_g is None):
            def _hx_local_1():
                def _hx_local_0():
                    self._hx___exceptionStack = haxe_NativeStackTrace.toHaxe(self._hx___nativeStack,self._hx___skipStack)
                    return self._hx___exceptionStack
                return _hx_local_0()
            return _hx_local_1()
        else:
            s = _g
            return s

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___exceptionStack = None
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None
_hx_classes["haxe.Exception"] = haxe_Exception


class haxe__Int32_Int32_Impl_:
    _hx_class_name = "haxe._Int32.Int32_Impl_"
    __slots__ = ()
    _hx_statics = ["negate", "preIncrement", "postIncrement", "preDecrement", "postDecrement", "add", "addInt", "sub", "subInt", "intSub", "mul", "mulInt", "complement", "or", "orInt", "xor", "xorInt", "shr", "shrInt", "intShr", "shl", "shlInt", "intShl", "toFloat", "ucompare", "clamp"]

    @staticmethod
    def negate(this1):
        return (((~this1 + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def preIncrement(this1):
        this1 = (this1 + 1)
        x = this1
        this1 = ((x + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return this1

    @staticmethod
    def postIncrement(this1):
        ret = this1
        this1 = (this1 + 1)
        this1 = ((this1 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return ret

    @staticmethod
    def preDecrement(this1):
        this1 = (this1 - 1)
        x = this1
        this1 = ((x + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return this1

    @staticmethod
    def postDecrement(this1):
        ret = this1
        this1 = (this1 - 1)
        this1 = ((this1 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return ret

    @staticmethod
    def add(a,b):
        return (((a + b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def addInt(a,b):
        return (((a + b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def sub(a,b):
        return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def subInt(a,b):
        return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def intSub(a,b):
        return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def mul(a,b):
        return ((((a * ((b & 65535))) + ((((((a * (HxOverrides.rshift(b, 16))) << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def mulInt(a,b):
        return haxe__Int32_Int32_Impl_.mul(a,b)

    @staticmethod
    def complement(a):
        return ((~a + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def _hx_or(a,b):
        return ((((a | b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def orInt(a,b):
        return ((((a | b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def xor(a,b):
        return ((((a ^ b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def xorInt(a,b):
        return ((((a ^ b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def shr(a,b):
        return ((((a >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def shrInt(a,b):
        return ((((a >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def intShr(a,b):
        return ((((a >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def shl(a,b):
        return ((((a << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def shlInt(a,b):
        return ((((a << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def intShl(a,b):
        return ((((a << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def toFloat(this1):
        return this1

    @staticmethod
    def ucompare(a,b):
        if (a < 0):
            if (b < 0):
                return (((((~b + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - (((~a + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            else:
                return 1
        if (b < 0):
            return -1
        else:
            return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def clamp(x):
        return ((x + (2 ** 31)) % (2 ** 32) - (2 ** 31))
_hx_classes["haxe._Int32.Int32_Impl_"] = haxe__Int32_Int32_Impl_


class haxe__Int64_Int64_Impl_:
    _hx_class_name = "haxe._Int64.Int64_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "copy", "make", "ofInt", "toInt", "is", "isInt64", "getHigh", "getLow", "isNeg", "isZero", "compare", "ucompare", "toStr", "toString", "parseString", "fromFloat", "divMod", "neg", "preIncrement", "postIncrement", "preDecrement", "postDecrement", "add", "addInt", "sub", "subInt", "intSub", "mul", "mulInt", "div", "divInt", "intDiv", "mod", "modInt", "intMod", "eq", "eqInt", "neq", "neqInt", "lt", "ltInt", "intLt", "lte", "lteInt", "intLte", "gt", "gtInt", "intGt", "gte", "gteInt", "intGte", "complement", "and", "or", "xor", "shl", "shr", "ushr", "get_high", "set_high", "get_low", "set_low"]
    high = None
    low = None

    @staticmethod
    def _new(x):
        this1 = x
        return this1

    @staticmethod
    def copy(this1):
        this2 = haxe__Int64____Int64(this1.high,this1.low)
        return this2

    @staticmethod
    def make(high,low):
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def ofInt(x):
        this1 = haxe__Int64____Int64((x >> 31),x)
        return this1

    @staticmethod
    def toInt(x):
        if (x.high != ((((x.low >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))):
            raise haxe_Exception.thrown("Overflow")
        return x.low

    @staticmethod
    def _hx_is(val):
        return Std.isOfType(val,haxe__Int64____Int64)

    @staticmethod
    def isInt64(val):
        return Std.isOfType(val,haxe__Int64____Int64)

    @staticmethod
    def getHigh(x):
        return x.high

    @staticmethod
    def getLow(x):
        return x.low

    @staticmethod
    def isNeg(x):
        return (x.high < 0)

    @staticmethod
    def isZero(x):
        b_high = 0
        b_low = 0
        if (x.high == b_high):
            return (x.low == b_low)
        else:
            return False

    @staticmethod
    def compare(a,b):
        v = (((a.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b.low)
        if (a.high < 0):
            if (b.high < 0):
                return v
            else:
                return -1
        elif (b.high >= 0):
            return v
        else:
            return 1

    @staticmethod
    def ucompare(a,b):
        v = haxe__Int32_Int32_Impl_.ucompare(a.high,b.high)
        if (v != 0):
            return v
        else:
            return haxe__Int32_Int32_Impl_.ucompare(a.low,b.low)

    @staticmethod
    def toStr(x):
        return haxe__Int64_Int64_Impl_.toString(x)

    @staticmethod
    def toString(this1):
        i = this1
        b_high = 0
        b_low = 0
        if ((i.high == b_high) and ((i.low == b_low))):
            return "0"
        _hx_str = ""
        neg = False
        if (i.high < 0):
            neg = True
        this1 = haxe__Int64____Int64(0,10)
        ten = this1
        while True:
            b_high = 0
            b_low = 0
            if (not (((i.high != b_high) or ((i.low != b_low))))):
                break
            r = haxe__Int64_Int64_Impl_.divMod(i,ten)
            if (r.modulus.high < 0):
                x = r.modulus
                high = ((~x.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((~x.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (low == 0):
                    ret = high
                    high = (high + 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                this_high = high
                this_low = low
                _hx_str = (Std.string(this_low) + ("null" if _hx_str is None else _hx_str))
                x1 = r.quotient
                high1 = ((~x1.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low1 = (((~x1.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (low1 == 0):
                    ret1 = high1
                    high1 = (high1 + 1)
                    high1 = ((high1 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                this1 = haxe__Int64____Int64(high1,low1)
                i = this1
            else:
                _hx_str = (Std.string(r.modulus.low) + ("null" if _hx_str is None else _hx_str))
                i = r.quotient
        if neg:
            _hx_str = ("-" + ("null" if _hx_str is None else _hx_str))
        return _hx_str

    @staticmethod
    def parseString(sParam):
        return haxe_Int64Helper.parseString(sParam)

    @staticmethod
    def fromFloat(f):
        return haxe_Int64Helper.fromFloat(f)

    @staticmethod
    def divMod(dividend,divisor):
        if (divisor.high == 0):
            _g = divisor.low
            if (_g == 0):
                raise haxe_Exception.thrown("divide by zero")
            elif (_g == 1):
                this1 = haxe__Int64____Int64(dividend.high,dividend.low)
                this2 = haxe__Int64____Int64(0,0)
                return _hx_AnonObject({'quotient': this1, 'modulus': this2})
            else:
                pass
        divSign = ((dividend.high < 0) != ((divisor.high < 0)))
        modulus = None
        if (dividend.high < 0):
            high = ((~dividend.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~dividend.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            modulus = this1
        else:
            this1 = haxe__Int64____Int64(dividend.high,dividend.low)
            modulus = this1
        if (divisor.high < 0):
            high = ((~divisor.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~divisor.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            divisor = this1
        this1 = haxe__Int64____Int64(0,0)
        quotient = this1
        this1 = haxe__Int64____Int64(0,1)
        mask = this1
        while (not ((divisor.high < 0))):
            v = haxe__Int32_Int32_Impl_.ucompare(divisor.high,modulus.high)
            cmp = (v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(divisor.low,modulus.low))
            b = 1
            b = (b & 63)
            if (b == 0):
                this1 = haxe__Int64____Int64(divisor.high,divisor.low)
                divisor = this1
            elif (b < 32):
                this2 = haxe__Int64____Int64(((((((((divisor.high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(divisor.low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((divisor.low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                divisor = this2
            else:
                this3 = haxe__Int64____Int64(((((divisor.low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
                divisor = this3
            b1 = 1
            b1 = (b1 & 63)
            if (b1 == 0):
                this4 = haxe__Int64____Int64(mask.high,mask.low)
                mask = this4
            elif (b1 < 32):
                this5 = haxe__Int64____Int64(((((((((mask.high << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(mask.low, ((32 - b1))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((mask.low << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                mask = this5
            else:
                this6 = haxe__Int64____Int64(((((mask.low << ((b1 - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
                mask = this6
            if (cmp >= 0):
                break
        while True:
            b_high = 0
            b_low = 0
            if (not (((mask.high != b_high) or ((mask.low != b_low))))):
                break
            v = haxe__Int32_Int32_Impl_.ucompare(modulus.high,divisor.high)
            if (((v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(modulus.low,divisor.low))) >= 0):
                this1 = haxe__Int64____Int64(((((quotient.high | mask.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((quotient.low | mask.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                quotient = this1
                high = (((modulus.high - divisor.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((modulus.low - divisor.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (haxe__Int32_Int32_Impl_.ucompare(modulus.low,divisor.low) < 0):
                    ret = high
                    high = (high - 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                this2 = haxe__Int64____Int64(high,low)
                modulus = this2
            b = 1
            b = (b & 63)
            if (b == 0):
                this3 = haxe__Int64____Int64(mask.high,mask.low)
                mask = this3
            elif (b < 32):
                this4 = haxe__Int64____Int64(HxOverrides.rshift(mask.high, b),((((((((mask.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(mask.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                mask = this4
            else:
                this5 = haxe__Int64____Int64(0,HxOverrides.rshift(mask.high, ((b - 32))))
                mask = this5
            b1 = 1
            b1 = (b1 & 63)
            if (b1 == 0):
                this6 = haxe__Int64____Int64(divisor.high,divisor.low)
                divisor = this6
            elif (b1 < 32):
                this7 = haxe__Int64____Int64(HxOverrides.rshift(divisor.high, b1),((((((((divisor.high << ((32 - b1)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(divisor.low, b1))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                divisor = this7
            else:
                this8 = haxe__Int64____Int64(0,HxOverrides.rshift(divisor.high, ((b1 - 32))))
                divisor = this8
        if divSign:
            high = ((~quotient.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~quotient.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            quotient = this1
        if (dividend.high < 0):
            high = ((~modulus.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~modulus.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            modulus = this1
        return _hx_AnonObject({'quotient': quotient, 'modulus': modulus})

    @staticmethod
    def neg(x):
        high = ((~x.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((~x.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (low == 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def preIncrement(this1):
        this2 = haxe__Int64____Int64(this1.high,this1.low)
        this1 = this2
        def _hx_local_1():
            _hx_local_0 = this1.low
            this1.low = (this1.low + 1)
            return _hx_local_0
        ret = _hx_local_1()
        this1.low = ((this1.low + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (this1.low == 0):
            def _hx_local_3():
                _hx_local_2 = this1.high
                this1.high = (this1.high + 1)
                return _hx_local_2
            ret = _hx_local_3()
            this1.high = ((this1.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return this1

    @staticmethod
    def postIncrement(this1):
        ret = this1
        this2 = haxe__Int64____Int64(this1.high,this1.low)
        this1 = this2
        def _hx_local_2():
            _hx_local_0 = this1
            _hx_local_1 = _hx_local_0.low
            _hx_local_0.low = (_hx_local_1 + 1)
            return _hx_local_1
        ret1 = _hx_local_2()
        this1.low = ((this1.low + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (this1.low == 0):
            def _hx_local_5():
                _hx_local_3 = this1
                _hx_local_4 = _hx_local_3.high
                _hx_local_3.high = (_hx_local_4 + 1)
                return _hx_local_4
            ret1 = _hx_local_5()
            this1.high = ((this1.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return ret

    @staticmethod
    def preDecrement(this1):
        this2 = haxe__Int64____Int64(this1.high,this1.low)
        this1 = this2
        if (this1.low == 0):
            def _hx_local_1():
                _hx_local_0 = this1.high
                this1.high = (this1.high - 1)
                return _hx_local_0
            ret = _hx_local_1()
            this1.high = ((this1.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        def _hx_local_3():
            _hx_local_2 = this1.low
            this1.low = (this1.low - 1)
            return _hx_local_2
        ret = _hx_local_3()
        this1.low = ((this1.low + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return this1

    @staticmethod
    def postDecrement(this1):
        ret = this1
        this2 = haxe__Int64____Int64(this1.high,this1.low)
        this1 = this2
        if (this1.low == 0):
            def _hx_local_2():
                _hx_local_0 = this1
                _hx_local_1 = _hx_local_0.high
                _hx_local_0.high = (_hx_local_1 - 1)
                return _hx_local_1
            ret1 = _hx_local_2()
            this1.high = ((this1.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        def _hx_local_5():
            _hx_local_3 = this1
            _hx_local_4 = _hx_local_3.low
            _hx_local_3.low = (_hx_local_4 - 1)
            return _hx_local_4
        ret1 = _hx_local_5()
        this1.low = ((this1.low + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return ret

    @staticmethod
    def add(a,b):
        high = (((a.high + b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low + b.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a.low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def addInt(a,b):
        b_high = (b >> 31)
        b_low = b
        high = (((a.high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a.low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def sub(a,b):
        high = (((a.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low - b.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(a.low,b.low) < 0):
            ret = high
            high = (high - 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def subInt(a,b):
        b_high = (b >> 31)
        b_low = b
        high = (((a.high - b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low - b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(a.low,b_low) < 0):
            ret = high
            high = (high - 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def intSub(a,b):
        a_high = (a >> 31)
        a_low = a
        high = (((a_high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a_low - b.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(a_low,b.low) < 0):
            ret = high
            high = (high - 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def mul(a,b):
        mask = 65535
        al = (a.low & mask)
        ah = HxOverrides.rshift(a.low, 16)
        bl = (b.low & mask)
        bh = HxOverrides.rshift(b.low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a.low,b.high) + haxe__Int32_Int32_Impl_.mul(a.high,b.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def mulInt(a,b):
        b_high = (b >> 31)
        b_low = b
        mask = 65535
        al = (a.low & mask)
        ah = HxOverrides.rshift(a.low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a.low,b_high) + haxe__Int32_Int32_Impl_.mul(a.high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        return this1

    @staticmethod
    def div(a,b):
        return haxe__Int64_Int64_Impl_.divMod(a,b).quotient

    @staticmethod
    def divInt(a,b):
        this1 = haxe__Int64____Int64((b >> 31),b)
        return haxe__Int64_Int64_Impl_.divMod(a,this1).quotient

    @staticmethod
    def intDiv(a,b):
        this1 = haxe__Int64____Int64((a >> 31),a)
        x = haxe__Int64_Int64_Impl_.divMod(this1,b).quotient
        if (x.high != ((((x.low >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))):
            raise haxe_Exception.thrown("Overflow")
        x1 = x.low
        this1 = haxe__Int64____Int64((x1 >> 31),x1)
        return this1

    @staticmethod
    def mod(a,b):
        return haxe__Int64_Int64_Impl_.divMod(a,b).modulus

    @staticmethod
    def modInt(a,b):
        this1 = haxe__Int64____Int64((b >> 31),b)
        x = haxe__Int64_Int64_Impl_.divMod(a,this1).modulus
        if (x.high != ((((x.low >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))):
            raise haxe_Exception.thrown("Overflow")
        x1 = x.low
        this1 = haxe__Int64____Int64((x1 >> 31),x1)
        return this1

    @staticmethod
    def intMod(a,b):
        this1 = haxe__Int64____Int64((a >> 31),a)
        x = haxe__Int64_Int64_Impl_.divMod(this1,b).modulus
        if (x.high != ((((x.low >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))):
            raise haxe_Exception.thrown("Overflow")
        x1 = x.low
        this1 = haxe__Int64____Int64((x1 >> 31),x1)
        return this1

    @staticmethod
    def eq(a,b):
        if (a.high == b.high):
            return (a.low == b.low)
        else:
            return False

    @staticmethod
    def eqInt(a,b):
        b_high = (b >> 31)
        b_low = b
        if (a.high == b_high):
            return (a.low == b_low)
        else:
            return False

    @staticmethod
    def neq(a,b):
        if (a.high == b.high):
            return (a.low != b.low)
        else:
            return True

    @staticmethod
    def neqInt(a,b):
        b_high = (b >> 31)
        b_low = b
        if (a.high == b_high):
            return (a.low != b_low)
        else:
            return True

    @staticmethod
    def lt(a,b):
        v = (((a.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a.high < 0)) else (v if ((b.high >= 0)) else 1))) < 0)

    @staticmethod
    def ltInt(a,b):
        b_high = (b >> 31)
        b_low = b
        v = (((a.high - b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b_low)
        return ((((v if ((b_high < 0)) else -1) if ((a.high < 0)) else (v if ((b_high >= 0)) else 1))) < 0)

    @staticmethod
    def intLt(a,b):
        a_high = (a >> 31)
        a_low = a
        v = (((a_high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a_low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a_high < 0)) else (v if ((b.high >= 0)) else 1))) < 0)

    @staticmethod
    def lte(a,b):
        v = (((a.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a.high < 0)) else (v if ((b.high >= 0)) else 1))) <= 0)

    @staticmethod
    def lteInt(a,b):
        b_high = (b >> 31)
        b_low = b
        v = (((a.high - b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b_low)
        return ((((v if ((b_high < 0)) else -1) if ((a.high < 0)) else (v if ((b_high >= 0)) else 1))) <= 0)

    @staticmethod
    def intLte(a,b):
        a_high = (a >> 31)
        a_low = a
        v = (((a_high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a_low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a_high < 0)) else (v if ((b.high >= 0)) else 1))) <= 0)

    @staticmethod
    def gt(a,b):
        v = (((a.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a.high < 0)) else (v if ((b.high >= 0)) else 1))) > 0)

    @staticmethod
    def gtInt(a,b):
        b_high = (b >> 31)
        b_low = b
        v = (((a.high - b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b_low)
        return ((((v if ((b_high < 0)) else -1) if ((a.high < 0)) else (v if ((b_high >= 0)) else 1))) > 0)

    @staticmethod
    def intGt(a,b):
        a_high = (a >> 31)
        a_low = a
        v = (((a_high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a_low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a_high < 0)) else (v if ((b.high >= 0)) else 1))) > 0)

    @staticmethod
    def gte(a,b):
        v = (((a.high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a.high < 0)) else (v if ((b.high >= 0)) else 1))) >= 0)

    @staticmethod
    def gteInt(a,b):
        b_high = (b >> 31)
        b_low = b
        v = (((a.high - b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a.low,b_low)
        return ((((v if ((b_high < 0)) else -1) if ((a.high < 0)) else (v if ((b_high >= 0)) else 1))) >= 0)

    @staticmethod
    def intGte(a,b):
        a_high = (a >> 31)
        a_low = a
        v = (((a_high - b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (v == 0):
            v = haxe__Int32_Int32_Impl_.ucompare(a_low,b.low)
        return ((((v if ((b.high < 0)) else -1) if ((a_high < 0)) else (v if ((b.high >= 0)) else 1))) >= 0)

    @staticmethod
    def complement(a):
        this1 = haxe__Int64____Int64(((~a.high + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((~a.low + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        return this1

    @staticmethod
    def _hx_and(a,b):
        this1 = haxe__Int64____Int64((a.high & b.high),(a.low & b.low))
        return this1

    @staticmethod
    def _hx_or(a,b):
        this1 = haxe__Int64____Int64(((((a.high | b.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a.low | b.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        return this1

    @staticmethod
    def xor(a,b):
        this1 = haxe__Int64____Int64(((((a.high ^ b.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a.low ^ b.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        return this1

    @staticmethod
    def shl(a,b):
        b = (b & 63)
        if (b == 0):
            this1 = haxe__Int64____Int64(a.high,a.low)
            return this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(((((((((a.high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a.low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a.low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            return this1
        else:
            this1 = haxe__Int64____Int64(((((a.low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
            return this1

    @staticmethod
    def shr(a,b):
        b = (b & 63)
        if (b == 0):
            this1 = haxe__Int64____Int64(a.high,a.low)
            return this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(((((a.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((a.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            return this1
        else:
            this1 = haxe__Int64____Int64(((((a.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            return this1

    @staticmethod
    def ushr(a,b):
        b = (b & 63)
        if (b == 0):
            this1 = haxe__Int64____Int64(a.high,a.low)
            return this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(HxOverrides.rshift(a.high, b),((((((((a.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            return this1
        else:
            this1 = haxe__Int64____Int64(0,HxOverrides.rshift(a.high, ((b - 32))))
            return this1

    @staticmethod
    def get_high(this1):
        return this1.high

    @staticmethod
    def set_high(this1,x):
        def _hx_local_1():
            def _hx_local_0():
                this1.high = x
                return this1.high
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def get_low(this1):
        return this1.low

    @staticmethod
    def set_low(this1,x):
        def _hx_local_1():
            def _hx_local_0():
                this1.low = x
                return this1.low
            return _hx_local_0()
        return _hx_local_1()
_hx_classes["haxe._Int64.Int64_Impl_"] = haxe__Int64_Int64_Impl_


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]
    _hx_methods = ["toString"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

    def toString(self):
        return haxe__Int64_Int64_Impl_.toString(self)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.high = None
        _hx_o.low = None
_hx_classes["haxe._Int64.___Int64"] = haxe__Int64____Int64


class haxe_Int64Helper:
    _hx_class_name = "haxe.Int64Helper"
    __slots__ = ()
    _hx_statics = ["parseString", "fromFloat"]

    @staticmethod
    def parseString(sParam):
        base_high = 0
        base_low = 10
        this1 = haxe__Int64____Int64(0,0)
        current = this1
        this1 = haxe__Int64____Int64(0,1)
        multiplier = this1
        sIsNegative = False
        s = StringTools.trim(sParam)
        if ((("" if ((0 >= len(s))) else s[0])) == "-"):
            sIsNegative = True
            s = HxString.substring(s,1,len(s))
        _hx_len = len(s)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            digitInt = (HxString.charCodeAt(s,((_hx_len - 1) - i)) - 48)
            if ((digitInt < 0) or ((digitInt > 9))):
                raise haxe_Exception.thrown("NumberFormatError")
            if (digitInt != 0):
                digit_high = (digitInt >> 31)
                digit_low = digitInt
                if sIsNegative:
                    mask = 65535
                    al = (multiplier.low & mask)
                    ah = HxOverrides.rshift(multiplier.low, 16)
                    bl = (digit_low & mask)
                    bh = HxOverrides.rshift(digit_low, 16)
                    p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
                    p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
                    p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
                    p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
                    low = p00
                    high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
                        ret = high
                        high = (high + 1)
                        high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
                        ret1 = high
                        high = (high + 1)
                        high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    high = (((high + ((((haxe__Int32_Int32_Impl_.mul(multiplier.low,digit_high) + haxe__Int32_Int32_Impl_.mul(multiplier.high,digit_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    b_high = high
                    b_low = low
                    high1 = (((current.high - b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    low1 = (((current.low - b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    if (haxe__Int32_Int32_Impl_.ucompare(current.low,b_low) < 0):
                        ret2 = high1
                        high1 = (high1 - 1)
                        high1 = ((high1 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    this1 = haxe__Int64____Int64(high1,low1)
                    current = this1
                    if (not ((current.high < 0))):
                        raise haxe_Exception.thrown("NumberFormatError: Underflow")
                else:
                    mask1 = 65535
                    al1 = (multiplier.low & mask1)
                    ah1 = HxOverrides.rshift(multiplier.low, 16)
                    bl1 = (digit_low & mask1)
                    bh1 = HxOverrides.rshift(digit_low, 16)
                    p001 = haxe__Int32_Int32_Impl_.mul(al1,bl1)
                    p101 = haxe__Int32_Int32_Impl_.mul(ah1,bl1)
                    p011 = haxe__Int32_Int32_Impl_.mul(al1,bh1)
                    p111 = haxe__Int32_Int32_Impl_.mul(ah1,bh1)
                    low2 = p001
                    high2 = ((((((p111 + (HxOverrides.rshift(p011, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p101, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    p011 = ((((p011 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    low2 = (((low2 + p011) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    if (haxe__Int32_Int32_Impl_.ucompare(low2,p011) < 0):
                        ret3 = high2
                        high2 = (high2 + 1)
                        high2 = ((high2 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    p101 = ((((p101 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    low2 = (((low2 + p101) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    if (haxe__Int32_Int32_Impl_.ucompare(low2,p101) < 0):
                        ret4 = high2
                        high2 = (high2 + 1)
                        high2 = ((high2 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    high2 = (((high2 + ((((haxe__Int32_Int32_Impl_.mul(multiplier.low,digit_high) + haxe__Int32_Int32_Impl_.mul(multiplier.high,digit_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    b_high1 = high2
                    b_low1 = low2
                    high3 = (((current.high + b_high1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    low3 = (((current.low + b_low1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    if (haxe__Int32_Int32_Impl_.ucompare(low3,current.low) < 0):
                        ret5 = high3
                        high3 = (high3 + 1)
                        high3 = ((high3 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                    this2 = haxe__Int64____Int64(high3,low3)
                    current = this2
                    if (current.high < 0):
                        raise haxe_Exception.thrown("NumberFormatError: Overflow")
            mask2 = 65535
            al2 = (multiplier.low & mask2)
            ah2 = HxOverrides.rshift(multiplier.low, 16)
            bl2 = (base_low & mask2)
            bh2 = HxOverrides.rshift(base_low, 16)
            p002 = haxe__Int32_Int32_Impl_.mul(al2,bl2)
            p102 = haxe__Int32_Int32_Impl_.mul(ah2,bl2)
            p012 = haxe__Int32_Int32_Impl_.mul(al2,bh2)
            p112 = haxe__Int32_Int32_Impl_.mul(ah2,bh2)
            low4 = p002
            high4 = ((((((p112 + (HxOverrides.rshift(p012, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p102, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            p012 = ((((p012 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low4 = (((low4 + p012) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (haxe__Int32_Int32_Impl_.ucompare(low4,p012) < 0):
                ret6 = high4
                high4 = (high4 + 1)
                high4 = ((high4 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            p102 = ((((p102 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low4 = (((low4 + p102) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (haxe__Int32_Int32_Impl_.ucompare(low4,p102) < 0):
                ret7 = high4
                high4 = (high4 + 1)
                high4 = ((high4 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            high4 = (((high4 + ((((haxe__Int32_Int32_Impl_.mul(multiplier.low,base_high) + haxe__Int32_Int32_Impl_.mul(multiplier.high,base_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this3 = haxe__Int64____Int64(high4,low4)
            multiplier = this3
        return current

    @staticmethod
    def fromFloat(f):
        if (python_lib_Math.isnan(f) or (not ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))))):
            raise haxe_Exception.thrown("Number is NaN or Infinite")
        noFractions = (f - (HxOverrides.modf(f, 1)))
        if (noFractions > 9007199254740991):
            raise haxe_Exception.thrown("Conversion overflow")
        if (noFractions < -9007199254740991):
            raise haxe_Exception.thrown("Conversion underflow")
        this1 = haxe__Int64____Int64(0,0)
        result = this1
        neg = (noFractions < 0)
        rest = (-noFractions if neg else noFractions)
        i = 0
        while (rest >= 1):
            curr = HxOverrides.modf(rest, 2)
            rest = (rest / 2)
            if (curr >= 1):
                a_high = 0
                a_low = 1
                b = i
                b = (b & 63)
                b1 = None
                if (b == 0):
                    this1 = haxe__Int64____Int64(a_high,a_low)
                    b1 = this1
                elif (b < 32):
                    this2 = haxe__Int64____Int64(((((((((a_high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a_low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a_low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                    b1 = this2
                else:
                    this3 = haxe__Int64____Int64(((((a_low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
                    b1 = this3
                high = (((result.high + b1.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((result.low + b1.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (haxe__Int32_Int32_Impl_.ucompare(low,result.low) < 0):
                    ret = high
                    high = (high + 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                this4 = haxe__Int64____Int64(high,low)
                result = this4
            i = (i + 1)
        if neg:
            high = ((~result.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~result.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            result = this1
        return result
_hx_classes["haxe.Int64Helper"] = haxe_Int64Helper


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
_hx_classes["haxe.Log"] = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "call", "stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def delay(self,t):
        self.nextRun = (Math.NEGATIVE_INFINITY if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def call(self):
        if (self.f is not None):
            self.f()

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
_hx_classes["haxe.MainEvent"] = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "get_threadCount", "hasEvents", "addThread", "runInMainThread", "add", "sortEvents", "tick"]
    pending = None
    threadCount = None

    @staticmethod
    def get_threadCount():
        return haxe_EntryPoint.threadCount

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def addThread(f):
        haxe_EntryPoint.addThread(f)

    @staticmethod
    def runInMainThread(f):
        haxe_EntryPoint.runInMainThread(f)

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise haxe_Exception.thrown("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        return e

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
_hx_classes["haxe.MainLoop"] = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "callStack", "exceptionStack", "toHaxe"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def callStack():
        infos = python_lib_Traceback.extract_stack()
        if (len(infos) != 0):
            infos.pop()
        infos.reverse()
        return infos

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []

    @staticmethod
    def toHaxe(native,skip = None):
        if (skip is None):
            skip = 0
        stack = []
        _g = 0
        _g1 = len(native)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (skip > i):
                continue
            elem = (native[i] if i >= 0 and i < len(native) else None)
            x = haxe_StackItem.FilePos(haxe_StackItem.Method(None,elem[2]),elem[0],elem[1])
            stack.append(x)
        return stack
_hx_classes["haxe.NativeStackTrace"] = haxe_NativeStackTrace


class haxe_Resource:
    _hx_class_name = "haxe.Resource"
    __slots__ = ()
    _hx_statics = ["content", "getContent", "listNames", "getString", "getBytes"]
    content = None

    @staticmethod
    def getContent():
        if (haxe_Resource.content is None):
            haxe_Resource.content = _hx_resources__()
        return haxe_Resource.content

    @staticmethod
    def listNames():
        return list(haxe_Resource.getContent().keys())

    @staticmethod
    def getString(name):
        _hx_bytes = haxe_Resource.getBytes(name)
        if (_hx_bytes is not None):
            return _hx_bytes.toString()
        return None

    @staticmethod
    def getBytes(name):
        data = haxe_Resource.getContent().get(name,None)
        if (data is None):
            return None
        return haxe_io_Bytes.ofData(data)
_hx_classes["haxe.Resource"] = haxe_Resource


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay", "measure", "stamp"]

    def __init__(self,time_ms):
        self.event = None
        _gthis = self
        dt = (time_ms / 1000)
        def _hx_local_2():
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        self.event.delay(dt)

    def stop(self):
        if (self.event is not None):
            self.event.stop()
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def measure(f,pos = None):
        t0 = python_lib_Timeit.default_timer()
        r = f()
        haxe_Log.trace((Std.string((python_lib_Timeit.default_timer() - t0)) + "s"),pos)
        return r

    @staticmethod
    def stamp():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.event = None
_hx_classes["haxe.Timer"] = haxe_Timer


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
_hx_classes["haxe.ValueException"] = haxe_ValueException


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "remove", "exists", "iterator", "keyValueIterator", "keys", "copy", "setLoop", "removeLoop", "keysLoop", "merge", "minBinding", "removeMinBinding", "balance", "compare", "toString", "clear"]
    _hx_statics = ["iteratorLoop"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def remove(self,key):
        try:
            self.root = self.removeLoop(key,self.root)
            return True
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),str):
                return False
            else:
                raise _g

    def exists(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return True
            elif (c < 0):
                node = node.left
            else:
                node = node.right
        return False

    def iterator(self):
        ret = []
        haxe_ds_BalancedTree.iteratorLoop(self.root,ret)
        return haxe_iterators_ArrayIterator(ret)

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def keys(self):
        ret = []
        self.keysLoop(self.root,ret)
        return haxe_iterators_ArrayIterator(ret)

    def copy(self):
        copied = haxe_ds_BalancedTree()
        copied.root = self.root
        return copied

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            nl = self.setLoop(k,v,node.left)
            return self.balance(nl,node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def removeLoop(self,k,node):
        if (node is None):
            raise haxe_Exception.thrown("Not_found")
        c = self.compare(k,node.key)
        if (c == 0):
            return self.merge(node.left,node.right)
        elif (c < 0):
            return self.balance(self.removeLoop(k,node.left),node.key,node.value,node.right)
        else:
            return self.balance(node.left,node.key,node.value,self.removeLoop(k,node.right))

    def keysLoop(self,node,acc):
        if (node is not None):
            self.keysLoop(node.left,acc)
            x = node.key
            acc.append(x)
            self.keysLoop(node.right,acc)

    def merge(self,t1,t2):
        if (t1 is None):
            return t2
        if (t2 is None):
            return t1
        t = self.minBinding(t2)
        return self.balance(t1,t.key,t.value,self.removeMinBinding(t2))

    def minBinding(self,t):
        if (t is None):
            raise haxe_Exception.thrown("Not_found")
        elif (t.left is None):
            return t
        else:
            return self.minBinding(t.left)

    def removeMinBinding(self,t):
        if (t.left is None):
            return t.right
        else:
            return self.balance(self.removeMinBinding(t.left),t.key,t.value,t.right)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this = r.right
            _this1 = r.left
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

    def toString(self):
        if (self.root is None):
            return "{}"
        else:
            return (("{" + HxOverrides.stringOrNull(self.root.toString())) + "}")

    def clear(self):
        self.root = None

    @staticmethod
    def iteratorLoop(node,acc):
        if (node is not None):
            haxe_ds_BalancedTree.iteratorLoop(node.left,acc)
            x = node.value
            acc.append(x)
            haxe_ds_BalancedTree.iteratorLoop(node.right,acc)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
_hx_classes["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]
    _hx_methods = ["toString"]

    def __init__(self,l,k,v,r,h = None):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this = self.left
                tmp = (0 if ((_this is None)) else _this._height)
            else:
                _this = self.right
                tmp = (0 if ((_this is None)) else _this._height)
            self._height = (tmp + 1)
        else:
            self._height = h

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.left is None)) else (HxOverrides.stringOrNull(self.left.toString()) + ", ")))) + (((("" + Std.string(self.key)) + "=") + Std.string(self.value)))) + HxOverrides.stringOrNull((("" if ((self.right is None)) else (", " + HxOverrides.stringOrNull(self.right.toString()))))))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.key = None
        _hx_o.value = None
        _hx_o._height = None
_hx_classes["haxe.ds.TreeNode"] = haxe_ds_TreeNode


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg", "copy"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = list(k1.params)
        p2 = list(k2.params)
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std.isOfType(v1,list) and Std.isOfType(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

    def copy(self):
        copied = haxe_ds_EnumValueMap()
        copied.root = self.root
        return copied

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap


class haxe_ds__HashMap_HashMap_Impl_:
    _hx_class_name = "haxe.ds._HashMap.HashMap_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "set", "get", "exists", "remove", "keys", "copy", "iterator", "keyValueIterator", "clear"]

    @staticmethod
    def _new():
        this1 = haxe_ds__HashMap_HashMapData()
        return this1

    @staticmethod
    def set(this1,k,v):
        this1.keys.set(k.hashCode(),k)
        this1.values.set(k.hashCode(),v)

    @staticmethod
    def get(this1,k):
        _this = this1.values
        key = k.hashCode()
        return _this.h.get(key,None)

    @staticmethod
    def exists(this1,k):
        _this = this1.values
        return (k.hashCode() in _this.h)

    @staticmethod
    def remove(this1,k):
        this1.values.remove(k.hashCode())
        return this1.keys.remove(k.hashCode())

    @staticmethod
    def keys(this1):
        return this1.keys.iterator()

    @staticmethod
    def copy(this1):
        copied = haxe_ds__HashMap_HashMapData()
        copied.keys = this1.keys.copy()
        copied.values = this1.values.copy()
        return copied

    @staticmethod
    def iterator(this1):
        return this1.values.iterator()

    @staticmethod
    def keyValueIterator(this1):
        return haxe_iterators_HashMapKeyValueIterator(this1)

    @staticmethod
    def clear(this1):
        this1.keys.h.clear()
        this1.values.h.clear()
_hx_classes["haxe.ds._HashMap.HashMap_Impl_"] = haxe_ds__HashMap_HashMap_Impl_


class haxe_ds__HashMap_HashMapData:
    _hx_class_name = "haxe.ds._HashMap.HashMapData"
    __slots__ = ("keys", "values")
    _hx_fields = ["keys", "values"]

    def __init__(self):
        self.keys = haxe_ds_IntMap()
        self.values = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.keys = None
        _hx_o.values = None
_hx_classes["haxe.ds._HashMap.HashMapData"] = haxe_ds__HashMap_HashMapData


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString", "clear"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def exists(self,key):
        return (key in self.h)

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def copy(self):
        copied = haxe_ds_IntMap()
        key = self.keys()
        while key.hasNext():
            key1 = key.next()
            copied.set(key1,self.h.get(key1,None))
        return copied

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("}")
        return s_b.getvalue()

    def clear(self):
        self.h.clear()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
_hx_classes["haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "push", "first", "last", "pop", "isEmpty", "clear", "remove", "iterator", "keyValueIterator", "toString", "join", "filter", "map"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def push(self,item):
        x = haxe_ds__List_ListNode(item,self.h)
        self.h = x
        if (self.q is None):
            self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def first(self):
        if (self.h is None):
            return None
        else:
            return self.h.item

    def last(self):
        if (self.q is None):
            return None
        else:
            return self.q.item

    def pop(self):
        if (self.h is None):
            return None
        x = self.h.item
        self.h = self.h.next
        if (self.h is None):
            self.q = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 - 1)
        _hx_local_1
        return x

    def isEmpty(self):
        return (self.h is None)

    def clear(self):
        self.h = None
        self.q = None
        self.length = 0

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if HxOverrides.eq(l.item,v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    def iterator(self):
        return haxe_ds__List_ListIterator(self.h)

    def keyValueIterator(self):
        return haxe_ds__List_ListKeyValueIterator(self.h)

    def toString(self):
        s_b = python_lib_io_StringIO()
        first = True
        l = self.h
        s_b.write("{")
        while (l is not None):
            if first:
                first = False
            else:
                s_b.write(", ")
            s_b.write(Std.string(Std.string(l.item)))
            l = l.next
        s_b.write("}")
        return s_b.getvalue()

    def join(self,sep):
        s_b = python_lib_io_StringIO()
        first = True
        l = self.h
        while (l is not None):
            if first:
                first = False
            else:
                s_b.write(Std.string(sep))
            s_b.write(Std.string(l.item))
            l = l.next
        return s_b.getvalue()

    def filter(self,f):
        l2 = haxe_ds_List()
        l = self.h
        while (l is not None):
            v = l.item
            l = l.next
            if f(v):
                l2.add(v)
        return l2

    def map(self,f):
        b = haxe_ds_List()
        l = self.h
        while (l is not None):
            v = l.item
            l = l.next
            b.add(f(v))
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
_hx_classes["haxe.ds.List"] = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
_hx_classes["haxe.ds._List.ListNode"] = haxe_ds__List_ListNode


class haxe_ds__List_ListIterator:
    _hx_class_name = "haxe.ds._List.ListIterator"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        self.head = head

    def hasNext(self):
        return (self.head is not None)

    def next(self):
        val = self.head.item
        self.head = self.head.next
        return val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.head = None
_hx_classes["haxe.ds._List.ListIterator"] = haxe_ds__List_ListIterator


class haxe_ds__List_ListKeyValueIterator:
    _hx_class_name = "haxe.ds._List.ListKeyValueIterator"
    __slots__ = ("idx", "head")
    _hx_fields = ["idx", "head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        self.head = head
        self.idx = 0

    def hasNext(self):
        return (self.head is not None)

    def next(self):
        val = self.head.item
        self.head = self.head.next
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.idx
                _hx_local_0.idx = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': val, 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.idx = None
        _hx_o.head = None
_hx_classes["haxe.ds._List.ListKeyValueIterator"] = haxe_ds__List_ListKeyValueIterator


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString", "clear"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def exists(self,key):
        return (key in self.h)

    def remove(self,key):
        r = (key in self.h)
        if r:
            del self.h[key]
        return r

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def copy(self):
        copied = haxe_ds_ObjectMap()
        key = self.keys()
        while key.hasNext():
            key1 = key.next()
            copied.set(key1,self.h.get(key1,None))
        return copied

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(Std.string(i1)))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("}")
        return s_b.getvalue()

    def clear(self):
        self.h.clear()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
_hx_classes["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap


class haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_:
    _hx_class_name = "haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_"
    __slots__ = ()
    _hx_statics = ["get_length", "get"]
    length = None

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def get(this1,i):
        return (this1[i] if i >= 0 and i < len(this1) else None)
_hx_classes["haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_"] = haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_


class haxe_ds_WeakMap:
    _hx_class_name = "haxe.ds.WeakMap"
    __slots__ = ()
    _hx_methods = ["set", "get", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString", "clear"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        raise haxe_Exception.thrown("Not implemented for this platform")

    def set(self,key,value):
        pass

    def get(self,key):
        return None

    def exists(self,key):
        return False

    def remove(self,key):
        return False

    def keys(self):
        return None

    def iterator(self):
        return None

    def keyValueIterator(self):
        return None

    def copy(self):
        return None

    def toString(self):
        return None

    def clear(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["haxe.ds.WeakMap"] = haxe_ds_WeakMap


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["get", "set", "blit", "fill", "sub", "compare", "getDouble", "getFloat", "setDouble", "setFloat", "getUInt16", "setUInt16", "getInt32", "getInt64", "setInt32", "setInt64", "getString", "readString", "toString", "toHex", "getData"]
    _hx_statics = ["alloc", "ofString", "ofData", "ofHex", "fastGet"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def get(self,pos):
        return self.b[pos]

    def set(self,pos,v):
        self.b[pos] = (v & 255)

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def fill(self,pos,_hx_len,value):
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos1 = pos
            pos = (pos + 1)
            self.b[pos1] = (value & 255)

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def compare(self,other):
        b1 = self.b
        b2 = other.b
        _hx_len = (self.length if ((self.length < other.length)) else other.length)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (b1[i] != b2[i]):
                return (b1[i] - b2[i])
        return (self.length - other.length)

    def getDouble(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        pos1 = (pos + 4)
        v1 = (((self.b[pos1] | ((self.b[(pos1 + 1)] << 8))) | ((self.b[(pos1 + 2)] << 16))) | ((self.b[(pos1 + 3)] << 24)))
        return haxe_io_FPHelper.i64ToDouble(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1))

    def getFloat(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        return haxe_io_FPHelper.i32ToFloat(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))

    def setDouble(self,pos,v):
        i = haxe_io_FPHelper.doubleToI64(v)
        v = i.low
        self.b[pos] = (v & 255)
        self.b[(pos + 1)] = ((v >> 8) & 255)
        self.b[(pos + 2)] = ((v >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        pos1 = (pos + 4)
        v = i.high
        self.b[pos1] = (v & 255)
        self.b[(pos1 + 1)] = ((v >> 8) & 255)
        self.b[(pos1 + 2)] = ((v >> 16) & 255)
        self.b[(pos1 + 3)] = (HxOverrides.rshift(v, 24) & 255)

    def setFloat(self,pos,v):
        v1 = haxe_io_FPHelper.floatToI32(v)
        self.b[pos] = (v1 & 255)
        self.b[(pos + 1)] = ((v1 >> 8) & 255)
        self.b[(pos + 2)] = ((v1 >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    def getUInt16(self,pos):
        return (self.b[pos] | ((self.b[(pos + 1)] << 8)))

    def setUInt16(self,pos,v):
        self.b[pos] = (v & 255)
        self.b[(pos + 1)] = ((v >> 8) & 255)

    def getInt32(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        if (((v & -2147483648)) != 0):
            return (v | -2147483648)
        else:
            return v

    def getInt64(self,pos):
        pos1 = (pos + 4)
        v = (((self.b[pos1] | ((self.b[(pos1 + 1)] << 8))) | ((self.b[(pos1 + 2)] << 16))) | ((self.b[(pos1 + 3)] << 24)))
        v1 = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        this1 = haxe__Int64____Int64(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1))
        return this1

    def setInt32(self,pos,v):
        self.b[pos] = (v & 255)
        self.b[(pos + 1)] = ((v >> 8) & 255)
        self.b[(pos + 2)] = ((v >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    def setInt64(self,pos,v):
        v1 = v.low
        self.b[pos] = (v1 & 255)
        self.b[(pos + 1)] = ((v1 >> 8) & 255)
        self.b[(pos + 2)] = ((v1 >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)
        pos1 = (pos + 4)
        v1 = v.high
        self.b[pos1] = (v1 & 255)
        self.b[(pos1 + 1)] = ((v1 >> 8) & 255)
        self.b[(pos1 + 2)] = ((v1 >> 16) & 255)
        self.b[(pos1 + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def readString(self,pos,_hx_len):
        return self.getString(pos,_hx_len)

    def toString(self):
        return self.getString(0,self.length)

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g = 0
        _g1 = self.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.b[i]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    def getData(self):
        return self.b

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofHex(s):
        _hx_len = len(s)
        if (((_hx_len & 1)) != 0):
            raise haxe_Exception.thrown("Not a hex string (odd number of digits)")
        ret = haxe_io_Bytes.alloc((_hx_len >> 1))
        _g = 0
        _g1 = ret.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            index = (i * 2)
            high = (-1 if ((index >= len(s))) else ord(s[index]))
            index1 = ((i * 2) + 1)
            low = (-1 if ((index1 >= len(s))) else ord(s[index1]))
            high = (((high & 15)) + ((((((high & 64)) >> 6)) * 9)))
            low = (((low & 15)) + ((((((low & 64)) >> 6)) * 9)))
            ret.b[i] = (((((high << 4) | low)) & 255) & 255)
        return ret

    @staticmethod
    def fastGet(b,pos):
        return b[pos]

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
_hx_classes["haxe.io.Bytes"] = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length", "addByte", "add", "addString", "addInt32", "addInt64", "addFloat", "addDouble", "addBytes", "getBytes"]

    def __init__(self):
        self.b = bytearray()

    def get_length(self):
        return len(self.b)

    def addByte(self,byte):
        self.b.append(byte)

    def add(self,src):
        self.b.extend(src.b)

    def addString(self,v,encoding = None):
        self.b.extend(bytearray(v,"UTF-8"))

    def addInt32(self,v):
        self.b.append((v & 255))
        self.b.append(((v >> 8) & 255))
        self.b.append(((v >> 16) & 255))
        self.b.append(HxOverrides.rshift(v, 24))

    def addInt64(self,v):
        self.addInt32(v.low)
        self.addInt32(v.high)

    def addFloat(self,v):
        self.addInt32(haxe_io_FPHelper.floatToI32(v))

    def addDouble(self,v):
        self.addInt64(haxe_io_FPHelper.doubleToI64(v))

    def addBytes(self,src,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b.extend(src.b[pos:(pos + _hx_len)])

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
_hx_classes["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
_hx_classes["haxe.io.Encoding"] = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["haxe.io.Eof"] = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
_hx_classes["haxe.io.Error"] = haxe_io_Error


class haxe_io_FPHelper:
    _hx_class_name = "haxe.io.FPHelper"
    __slots__ = ()
    _hx_statics = ["i64tmp", "LN2", "_i32ToFloat", "_i64ToDouble", "_floatToI32", "_doubleToI64", "i32ToFloat", "floatToI32", "i64ToDouble", "doubleToI64"]

    @staticmethod
    def _i32ToFloat(i):
        sign = (1 - ((HxOverrides.rshift(i, 31) << 1)))
        e = ((i >> 23) & 255)
        if (e == 255):
            if (((i & 8388607)) == 0):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        m = ((((i & 8388607)) << 1) if ((e == 0)) else ((i & 8388607) | 8388608))
        return ((sign * m) * Math.pow(2,(e - 150)))

    @staticmethod
    def _i64ToDouble(lo,hi):
        sign = (1 - ((HxOverrides.rshift(hi, 31) << 1)))
        e = ((hi >> 20) & 2047)
        if (e == 2047):
            if ((lo == 0) and ((((hi & 1048575)) == 0))):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        m = (2.220446049250313e-16 * ((((((hi & 1048575)) * 4294967296.) + (((HxOverrides.rshift(lo, 31)) * 2147483648.))) + ((lo & 2147483647)))))
        if (e == 0):
            m = (m * 2.0)
        else:
            m = (m + 1.0)
        return ((sign * m) * Math.pow(2,(e - 1023)))

    @staticmethod
    def _floatToI32(f):
        if (f == 0):
            return 0
        af = (-f if ((f < 0)) else f)
        exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
        if (exp > 127):
            return 2139095040
        else:
            if (exp <= -127):
                exp = -127
                af = (af * 7.1362384635298e+44)
            else:
                af = ((((af / Math.pow(2,exp)) - 1.0)) * 8388608)
            return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | Math.floor((af + 0.5)))

    @staticmethod
    def _doubleToI64(v):
        i64 = haxe_io_FPHelper.i64tmp
        if (v == 0):
            i64.low = 0
            i64.high = 0
        elif (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v))))):
            i64.low = 0
            i64.high = (2146435072 if ((v > 0)) else -1048576)
        else:
            av = (-v if ((v < 0)) else v)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((av == 0.0)) else (Math.NaN if ((av < 0.0)) else python_lib_Math.log(av)))) / 0.6931471805599453))
            if (exp > 1023):
                i64.low = -1
                i64.high = 2146435071
            else:
                if (exp <= -1023):
                    exp = -1023
                    av = (av / 2.2250738585072014e-308)
                else:
                    av = ((av / Math.pow(2,exp)) - 1.0)
                v1 = (av * 4503599627370496.)
                sig = (v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))
                sig_l = None
                try:
                    sig_l = int(sig)
                except BaseException as _g:
                    None
                    sig_l = None
                sig_l1 = sig_l
                sig_h = None
                try:
                    sig_h = int((sig / 4294967296.0))
                except BaseException as _g:
                    None
                    sig_h = None
                sig_h1 = sig_h
                i64.low = sig_l1
                i64.high = ((((-2147483648 if ((v < 0)) else 0)) | (((exp + 1023) << 20))) | sig_h1)
        return i64

    @staticmethod
    def i32ToFloat(i):
        sign = (1 - ((HxOverrides.rshift(i, 31) << 1)))
        e = ((i >> 23) & 255)
        if (e == 255):
            if (((i & 8388607)) == 0):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = ((((i & 8388607)) << 1) if ((e == 0)) else ((i & 8388607) | 8388608))
            return ((sign * m) * Math.pow(2,(e - 150)))

    @staticmethod
    def floatToI32(f):
        if (f == 0):
            return 0
        else:
            af = (-f if ((f < 0)) else f)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
            if (exp > 127):
                return 2139095040
            else:
                if (exp <= -127):
                    exp = -127
                    af = (af * 7.1362384635298e+44)
                else:
                    af = ((((af / Math.pow(2,exp)) - 1.0)) * 8388608)
                return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | Math.floor((af + 0.5)))

    @staticmethod
    def i64ToDouble(low,high):
        sign = (1 - ((HxOverrides.rshift(high, 31) << 1)))
        e = ((high >> 20) & 2047)
        if (e == 2047):
            if ((low == 0) and ((((high & 1048575)) == 0))):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = (2.220446049250313e-16 * ((((((high & 1048575)) * 4294967296.) + (((HxOverrides.rshift(low, 31)) * 2147483648.))) + ((low & 2147483647)))))
            if (e == 0):
                m = (m * 2.0)
            else:
                m = (m + 1.0)
            return ((sign * m) * Math.pow(2,(e - 1023)))

    @staticmethod
    def doubleToI64(v):
        i64 = haxe_io_FPHelper.i64tmp
        if (v == 0):
            i64.low = 0
            i64.high = 0
        elif (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v))))):
            i64.low = 0
            i64.high = (2146435072 if ((v > 0)) else -1048576)
        else:
            av = (-v if ((v < 0)) else v)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((av == 0.0)) else (Math.NaN if ((av < 0.0)) else python_lib_Math.log(av)))) / 0.6931471805599453))
            if (exp > 1023):
                i64.low = -1
                i64.high = 2146435071
            else:
                if (exp <= -1023):
                    exp = -1023
                    av = (av / 2.2250738585072014e-308)
                else:
                    av = ((av / Math.pow(2,exp)) - 1.0)
                v1 = (av * 4503599627370496.)
                sig = (v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))
                sig_l = None
                try:
                    sig_l = int(sig)
                except BaseException as _g:
                    None
                    sig_l = None
                sig_l1 = sig_l
                sig_h = None
                try:
                    sig_h = int((sig / 4294967296.0))
                except BaseException as _g:
                    None
                    sig_h = None
                sig_h1 = sig_h
                i64.low = sig_l1
                i64.high = ((((-2147483648 if ((v < 0)) else 0)) | (((exp + 1023) << 20))) | sig_h1)
        return i64
_hx_classes["haxe.io.FPHelper"] = haxe_io_FPHelper


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "close", "set_bigEndian", "readAll", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt8", "readInt16", "readUInt16", "readInt24", "readUInt24", "readInt32", "readString", "getDoubleSig"]

    def readByte(self):
        raise haxe_Exception.thrown("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readAll(self,bufsize = None):
        if (bufsize is None):
            bufsize = 16384
        buf = haxe_io_Bytes.alloc(bufsize)
        total = haxe_io_BytesBuffer()
        try:
            while True:
                _hx_len = self.readBytes(buf,0,bufsize)
                if (_hx_len == 0):
                    raise haxe_Exception.thrown(haxe_io_Error.Blocked)
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
                total.b.extend(buf.b[0:_hx_len])
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return total.getBytes()

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readUntil(self,end):
        buf = haxe_io_BytesBuffer()
        last = None
        while True:
            last = self.readByte()
            if (not ((last != end))):
                break
            buf.b.append(last)
        return buf.getBytes().toString()

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,haxe_io_Eof):
                e = _g1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise haxe_Exception.thrown(e)
            else:
                raise _g
        return s

    def readFloat(self):
        return haxe_io_FPHelper.i32ToFloat(self.readInt32())

    def readDouble(self):
        i1 = self.readInt32()
        i2 = self.readInt32()
        if self.bigEndian:
            return haxe_io_FPHelper.i64ToDouble(i2,i1)
        else:
            return haxe_io_FPHelper.i64ToDouble(i1,i2)

    def readInt8(self):
        n = self.readByte()
        if (n >= 128):
            return (n - 256)
        return n

    def readInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        n = ((ch2 | ((ch1 << 8))) if (self.bigEndian) else (ch1 | ((ch2 << 8))))
        if (((n & 32768)) != 0):
            return (n - 65536)
        return n

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    def readInt24(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        n = (((ch3 | ((ch2 << 8))) | ((ch1 << 16))) if (self.bigEndian) else ((ch1 | ((ch2 << 8))) | ((ch3 << 16))))
        if (((n & 8388608)) != 0):
            return (n - 16777216)
        return n

    def readUInt24(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        if self.bigEndian:
            return ((ch3 | ((ch2 << 8))) | ((ch1 << 16)))
        else:
            return ((ch1 | ((ch2 << 8))) | ((ch3 << 16)))

    def readInt32(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        ch4 = self.readByte()
        n = ((((ch4 | ((ch3 << 8))) | ((ch2 << 16))) | ((ch1 << 24))) if (self.bigEndian) else (((ch1 | ((ch2 << 8))) | ((ch3 << 16))) | ((ch4 << 24))))
        if (((n & -2147483648)) != 0):
            return (n | -2147483648)
        else:
            return n

    def readString(self,_hx_len,encoding = None):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.getString(0,_hx_len,encoding)

    def getDoubleSig(self,_hx_bytes):
        return ((((((((((_hx_bytes[1] if 1 < len(_hx_bytes) else None) & 15)) << 16) | (((_hx_bytes[2] if 2 < len(_hx_bytes) else None) << 8))) | (_hx_bytes[3] if 3 < len(_hx_bytes) else None))) * 4294967296.) + (((((_hx_bytes[4] if 4 < len(_hx_bytes) else None) >> 7)) * 2147483648))) + ((((((((_hx_bytes[4] if 4 < len(_hx_bytes) else None) & 127)) << 24) | (((_hx_bytes[5] if 5 < len(_hx_bytes) else None) << 16))) | (((_hx_bytes[6] if 6 < len(_hx_bytes) else None) << 8))) | (_hx_bytes[7] if 7 < len(_hx_bytes) else None))))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
_hx_classes["haxe.io.Input"] = haxe_io_Input


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "write", "writeFullBytes", "writeFloat", "writeDouble", "writeInt8", "writeInt16", "writeUInt16", "writeInt24", "writeUInt24", "writeInt32", "prepare", "writeInput", "writeString"]

    def writeByte(self,c):
        raise haxe_Exception.thrown("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeFloat(self,x):
        self.writeInt32(haxe_io_FPHelper.floatToI32(x))

    def writeDouble(self,x):
        i64 = haxe_io_FPHelper.doubleToI64(x)
        if self.bigEndian:
            self.writeInt32(i64.high)
            self.writeInt32(i64.low)
        else:
            self.writeInt32(i64.low)
            self.writeInt32(i64.high)

    def writeInt8(self,x):
        if ((x < -128) or ((x >= 128))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        self.writeByte((x & 255))

    def writeInt16(self,x):
        if ((x < -32768) or ((x >= 32768))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        self.writeUInt16((x & 65535))

    def writeUInt16(self,x):
        if ((x < 0) or ((x >= 65536))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 8))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte((x >> 8))

    def writeInt24(self,x):
        if ((x < -8388608) or ((x >= 8388608))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        self.writeUInt24((x & 16777215))

    def writeUInt24(self,x):
        if ((x < 0) or ((x >= 16777216))):
            raise haxe_Exception.thrown(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 16))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x >> 16))

    def writeInt32(self,x):
        if self.bigEndian:
            self.writeByte(HxOverrides.rshift(x, 24))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(HxOverrides.rshift(x, 24))

    def prepare(self,nbytes):
        pass

    def writeInput(self,i,bufsize = None):
        if (bufsize is None):
            bufsize = 4096
        buf = haxe_io_Bytes.alloc(bufsize)
        try:
            while True:
                _hx_len = i.readBytes(buf,0,bufsize)
                if (_hx_len == 0):
                    raise haxe_Exception.thrown(haxe_io_Error.Blocked)
                p = 0
                while (_hx_len > 0):
                    k = self.writeBytes(buf,p,_hx_len)
                    if (k == 0):
                        raise haxe_Exception.thrown(haxe_io_Error.Blocked)
                    p = (p + k)
                    _hx_len = (_hx_len - k)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
_hx_classes["haxe.io.Output"] = haxe_io_Output


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["withoutExtension", "withoutDirectory", "directory", "extension", "withExtension", "join", "normalize", "addTrailingSlash", "removeTrailingSlashes", "isAbsolute", "unescape", "escape"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex = None
        cp = None
        if (startIndex is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i = path.rfind(".", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("."))) if ((i == -1)) else (i + 1))
            check = path.find(".", startLeft, len(path))
            cp = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def withoutExtension(path):
        s = haxe_io_Path(path)
        s.ext = None
        return s.toString()

    @staticmethod
    def withoutDirectory(path):
        s = haxe_io_Path(path)
        s.dir = None
        return s.toString()

    @staticmethod
    def directory(path):
        s = haxe_io_Path(path)
        if (s.dir is None):
            return ""
        return s.dir

    @staticmethod
    def extension(path):
        s = haxe_io_Path(path)
        if (s.ext is None):
            return ""
        return s.ext

    @staticmethod
    def withExtension(path,ext):
        s = haxe_io_Path(path)
        s.ext = ext
        return s.toString()

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g = 0
        _g1 = len(tmp)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g3 = _g2
            if (_g3 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g2
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g3 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g2
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path

    @staticmethod
    def removeTrailingSlashes(path):
        while True:
            _g = HxString.charCodeAt(path,(len(path) - 1))
            if (_g is None):
                break
            else:
                _g1 = _g
                if ((_g1 == 92) or ((_g1 == 47))):
                    path = HxString.substr(path,0,-1)
                else:
                    break
        return path

    @staticmethod
    def isAbsolute(path):
        if path.startswith("/"):
            return True
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        if path.startswith("\\\\"):
            return True
        return False

    @staticmethod
    def unescape(path):
        regex = EReg("-x([0-9][0-9])","g")
        def _hx_local_1():
            def _hx_local_0(regex):
                code = Std.parseInt(regex.matchObj.group(1))
                return "".join(map(chr,[code]))
            return regex.map(path,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def escape(path,allowSlashes = None):
        if (allowSlashes is None):
            allowSlashes = False
        regex = (EReg("[^A-Za-z0-9_/\\\\\\.]","g") if allowSlashes else EReg("[^A-Za-z0-9_\\.]","g"))
        def _hx_local_1():
            def _hx_local_0(v):
                return ("-x" + Std.string(HxString.charCodeAt(v.matchObj.group(0),0)))
            return regex.map(path,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dir = None
        _hx_o.file = None
        _hx_o.ext = None
        _hx_o.backslash = None
_hx_classes["haxe.io.Path"] = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None
_hx_classes["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None
_hx_classes["haxe.iterators.ArrayKeyValueIterator"] = haxe_iterators_ArrayKeyValueIterator


class haxe_iterators_HashMapKeyValueIterator:
    _hx_class_name = "haxe.iterators.HashMapKeyValueIterator"
    __slots__ = ("map", "keys")
    _hx_fields = ["map", "keys"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_map):
        self.map = _hx_map
        self.keys = _hx_map.keys.iterator()

    def hasNext(self):
        return self.keys.hasNext()

    def next(self):
        key = self.keys.next()
        _this = self.map.values
        key1 = key.hashCode()
        return _hx_AnonObject({'value': _this.h.get(key1,None), 'key': key})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.keys = None
_hx_classes["haxe.iterators.HashMapKeyValueIterator"] = haxe_iterators_HashMapKeyValueIterator


class haxe_iterators_MapKeyValueIterator:
    _hx_class_name = "haxe.iterators.MapKeyValueIterator"
    __slots__ = ("map", "keys")
    _hx_fields = ["map", "keys"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_map):
        self.map = _hx_map
        self.keys = _hx_map.keys()

    def hasNext(self):
        return self.keys.hasNext()

    def next(self):
        key = self.keys.next()
        return _hx_AnonObject({'value': self.map.get(key), 'key': key})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.keys = None
_hx_classes["haxe.iterators.MapKeyValueIterator"] = haxe_iterators_MapKeyValueIterator


class haxe_iterators_StringIterator:
    _hx_class_name = "haxe.iterators.StringIterator"
    __slots__ = ("offset", "s")
    _hx_fields = ["offset", "s"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,s):
        self.offset = 0
        self.s = s

    def hasNext(self):
        return (self.offset < len(self.s))

    def next(self):
        s = self.s
        index = self.offset
        self.offset = (self.offset + 1)
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.offset = None
        _hx_o.s = None
_hx_classes["haxe.iterators.StringIterator"] = haxe_iterators_StringIterator


class haxe_iterators_StringIteratorUnicode:
    _hx_class_name = "haxe.iterators.StringIteratorUnicode"
    __slots__ = ("offset", "s")
    _hx_fields = ["offset", "s"]
    _hx_methods = ["hasNext", "next"]
    _hx_statics = ["unicodeIterator"]

    def __init__(self,s):
        self.offset = 0
        self.s = s

    def hasNext(self):
        return (self.offset < len(self.s))

    def next(self):
        s = self.s
        index = self.offset
        self.offset = (self.offset + 1)
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    @staticmethod
    def unicodeIterator(s):
        return haxe_iterators_StringIteratorUnicode(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.offset = None
        _hx_o.s = None
_hx_classes["haxe.iterators.StringIteratorUnicode"] = haxe_iterators_StringIteratorUnicode


class haxe_iterators_StringKeyValueIterator:
    _hx_class_name = "haxe.iterators.StringKeyValueIterator"
    __slots__ = ("offset", "s")
    _hx_fields = ["offset", "s"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,s):
        self.offset = 0
        self.s = s

    def hasNext(self):
        return (self.offset < len(self.s))

    def next(self):
        tmp = self.offset
        s = self.s
        index = self.offset
        self.offset = (self.offset + 1)
        return _hx_AnonObject({'key': tmp, 'value': (-1 if ((index >= len(s))) else ord(s[index]))})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.offset = None
        _hx_o.s = None
_hx_classes["haxe.iterators.StringKeyValueIterator"] = haxe_iterators_StringKeyValueIterator


class python_HaxeIterable:
    _hx_class_name = "python.HaxeIterable"
    __slots__ = ("x",)
    _hx_fields = ["x"]
    _hx_methods = ["iterator"]

    def __init__(self,x):
        self.x = x

    def iterator(self):
        return python_HaxeIterator(self.x.__iter__())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
_hx_classes["python.HaxeIterable"] = python_HaxeIterable


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "toDict", "toDictHelper", "fromDict", "fromT", "typed", "get"]

    @staticmethod
    def _new(d):
        this1 = d
        return this1

    @staticmethod
    def toDict(this1):
        return python__KwArgs_KwArgs_Impl_.toDictHelper(this1,None)

    @staticmethod
    def toDictHelper(this1,x):
        return this1

    @staticmethod
    def fromDict(d):
        this1 = d
        return this1

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1

    @staticmethod
    def typed(this1):
        return _hx_AnonObject(python__KwArgs_KwArgs_Impl_.toDictHelper(this1,None))

    @staticmethod
    def get(this1,key,_hx_def):
        return this1.get(key,_hx_def)
_hx_classes["python._KwArgs.KwArgs_Impl_"] = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "get___name__", "print", "printString", "println", "dictToAnon", "anonToDict", "anonAsDict", "dictAsAnon", "toPythonIterable", "toHaxeIterable", "toHaxeIterator"]
    __name__ = None

    @staticmethod
    def get___name__():
        return __name__

    @staticmethod
    def print(v):
        python_Lib.printString(Std.string(v))

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        _hx_str = Std.string(v)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        return _hx_AnonObject(d)

    @staticmethod
    def toPythonIterable(it):
        def _hx_local_3():
            def _hx_local_2():
                it1 = HxOverrides.iterator(it)
                _hx_self = None
                def _hx_local_0():
                    if it1.hasNext():
                        return it1.next()
                    else:
                        raise haxe_Exception.thrown(StopIteration())
                def _hx_local_1():
                    return _hx_self
                this1 = _hx_AnonObject({'__next__': _hx_local_0, '__iter__': _hx_local_1})
                _hx_self = this1
                return _hx_self
            return _hx_AnonObject({'__iter__': _hx_local_2})
        return _hx_local_3()

    @staticmethod
    def toHaxeIterable(it):
        return python_HaxeIterable(it)

    @staticmethod
    def toHaxeIterator(it):
        return python_HaxeIterator(it)
_hx_classes["python.Lib"] = python_Lib


class python__NativeIterable_NativeIterable_Impl_:
    _hx_class_name = "python._NativeIterable.NativeIterable_Impl_"
    __slots__ = ()
    _hx_statics = ["toHaxeIterable", "iterator"]

    @staticmethod
    def toHaxeIterable(this1):
        return python_HaxeIterable(this1)

    @staticmethod
    def iterator(this1):
        return python_HaxeIterator(this1.__iter__())
_hx_classes["python._NativeIterable.NativeIterable_Impl_"] = python__NativeIterable_NativeIterable_Impl_


class python__NativeIterator_NativeIterator_Impl_:
    _hx_class_name = "python._NativeIterator.NativeIterator_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "toHaxeIterator"]

    @staticmethod
    def _new(p):
        this1 = p
        return this1

    @staticmethod
    def toHaxeIterator(this1):
        return python_HaxeIterator(this1)
_hx_classes["python._NativeIterator.NativeIterator_Impl_"] = python__NativeIterator_NativeIterator_Impl_


class python_NativeStringTools:
    _hx_class_name = "python.NativeStringTools"
    __slots__ = ()
    _hx_statics = ["format", "encode", "contains", "strip", "rpartition", "startswith", "endswith"]

    @staticmethod
    def format(s,args):
        return s.format(*args)

    @staticmethod
    def encode(s,encoding = None,errors = None):
        if (encoding is None):
            encoding = "utf-8"
        if (errors is None):
            errors = "strict"
        return s.encode(encoding, errors)

    @staticmethod
    def contains(s,e):
        return (e in s)

    @staticmethod
    def strip(s,chars = None):
        return s.strip(chars)

    @staticmethod
    def rpartition(s,sep):
        return s.rpartition(sep)

    @staticmethod
    def startswith(s,prefix):
        return s.startswith(prefix)

    @staticmethod
    def endswith(s,suffix):
        return s.endswith(suffix)
_hx_classes["python.NativeStringTools"] = python_NativeStringTools


class python__VarArgs_VarArgs_Impl_:
    _hx_class_name = "python._VarArgs.VarArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "raw", "toArray", "fromArray"]

    @staticmethod
    def _new(d):
        this1 = d
        return this1

    @staticmethod
    def raw(this1):
        return this1

    @staticmethod
    def toArray(this1):
        if (not Std.isOfType(this1,list)):
            return list(this1)
        else:
            return this1

    @staticmethod
    def fromArray(d):
        this1 = d
        return this1
_hx_classes["python._VarArgs.VarArgs_Impl_"] = python__VarArgs_VarArgs_Impl_


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["get_length", "concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set", "unsafeGet", "unsafeSet", "resize"]

    @staticmethod
    def get_length(x):
        return len(x)

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v

    @staticmethod
    def unsafeGet(x,idx):
        return x[idx]

    @staticmethod
    def unsafeSet(x,idx,val):
        x[idx] = val
        return val

    @staticmethod
    def resize(x,_hx_len):
        l = len(x)
        if (l < _hx_len):
            idx = (_hx_len - 1)
            v = None
            l1 = len(x)
            while (l1 < idx):
                x.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                x.append(v)
            else:
                x[idx] = v
        elif (l > _hx_len):
            pos = _hx_len
            len1 = (l - _hx_len)
            if (pos < 0):
                pos = (len(x) + pos)
            if (pos < 0):
                pos = 0
            res = x[pos:(pos + len1)]
            del x[pos:(pos + len1)]
_hx_classes["python.internal.ArrayImpl"] = python_internal_ArrayImpl


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "keyValueIterator", "eq", "stringOrNull", "shift", "pop", "push", "join", "filter", "map", "toUpperCase", "toLowerCase", "split", "length", "rshift", "modf", "mod", "arrayGet", "arraySet", "mapKwArgs", "reverseMapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def keyValueIterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayKeyValueIterator(x)
        return x.keyValueIterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def shift(x):
        if isinstance(x,list):
            _this = x
            return (None if ((len(_this) == 0)) else _this.pop(0))
        return x.shift()

    @staticmethod
    def pop(x):
        if isinstance(x,list):
            _this = x
            return (None if ((len(_this) == 0)) else _this.pop())
        return x.pop()

    @staticmethod
    def push(x,e):
        if isinstance(x,list):
            _this = x
            _this.append(e)
            return len(_this)
        return x.push(e)

    @staticmethod
    def join(x,sep):
        if isinstance(x,list):
            return sep.join([python_Boot.toString1(x1,'') for x1 in x])
        return x.join(sep)

    @staticmethod
    def filter(x,f):
        if isinstance(x,list):
            return list(filter(f,x))
        return x.filter(f)

    @staticmethod
    def map(x,f):
        if isinstance(x,list):
            return list(map(f,x))
        return x.map(f)

    @staticmethod
    def toUpperCase(x):
        if isinstance(x,str):
            return x.upper()
        return x.toUpperCase()

    @staticmethod
    def toLowerCase(x):
        if isinstance(x,str):
            return x.lower()
        return x.toLowerCase()

    @staticmethod
    def split(x,delimiter):
        if isinstance(x,str):
            _this = x
            if (delimiter == ""):
                return list(_this)
            else:
                return _this.split(delimiter)
        return x.split(delimiter)

    @staticmethod
    def length(x):
        if isinstance(x,str):
            return len(x)
        elif isinstance(x,list):
            return len(x)
        return x.length

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def arraySet(a,i,v):
        if isinstance(a,list):
            x = a
            v1 = v
            l = len(x)
            while (l < i):
                x.append(None)
                l = (l + 1)
            if (l == i):
                x.append(v1)
            else:
                x[i] = v1
            return v1
        else:
            a[i] = v
            return v

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1

    @staticmethod
    def reverseMapKwArgs(a,v):
        a1 = a.copy()
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if (val in a1):
                x = a1.get(val,None)
                a1[k1] = x
                del a1[val]
        return a1
_hx_classes["HxOverrides"] = HxOverrides


class python_internal_Internal:
    _hx_class_name = "python.internal.Internal"
    __slots__ = ()
_hx_classes["python.internal.Internal"] = python_internal_Internal


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
_hx_classes["python.internal.MethodClosure"] = python_internal_MethodClosure


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["get_canSeek", "close", "tell", "throwEof", "eof", "readinto", "seek", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def get_canSeek(self):
        return self.stream.seekable()

    def close(self):
        self.stream.close()

    def tell(self):
        return self.stream.tell()

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    def eof(self):
        return self.wasEof

    def readinto(self,b):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def seek(self,p,mode):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
_hx_classes["python.io.NativeInput"] = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "close", "readAll", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt8", "readInt16", "readUInt16", "readInt24", "readUInt24", "readInt32", "readString"]
_hx_classes["python.io.IInput"] = python_io_IInput


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)

    def readinto(self,b):
        return self.stream.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["python.io.NativeBytesInput"] = python_io_NativeBytesInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_methods = ["seek", "tell", "eof"]
    _hx_interfaces = [python_io_IInput]
_hx_classes["python.io.IFileInput"] = python_io_IFileInput


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)
_hx_classes["python.io.FileBytesInput"] = python_io_FileBytesInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["get_canSeek", "close", "prepare", "flush", "tell"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def get_canSeek(self):
        return self.stream.seekable()

    def close(self):
        self.stream.close()

    def prepare(self,nbytes):
        self.stream.truncate(nbytes)

    def flush(self):
        self.stream.flush()

    def tell(self):
        return self.stream.tell()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
_hx_classes["python.io.NativeOutput"] = python_io_NativeOutput


class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["seek", "prepare", "writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def seek(self,p,pos):
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)

    def prepare(self,nbytes):
        self.stream.truncate(nbytes)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.write(s.b[pos:(pos + _hx_len)])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["python.io.NativeBytesOutput"] = python_io_NativeBytesOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "write", "writeFullBytes", "writeFloat", "writeDouble", "writeInt8", "writeInt16", "writeUInt16", "writeInt24", "writeUInt24", "writeInt32", "prepare", "writeInput", "writeString"]
_hx_classes["python.io.IOutput"] = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_methods = ["seek", "tell"]
    _hx_interfaces = [python_io_IOutput]
_hx_classes["python.io.IFileOutput"] = python_io_IFileOutput


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)
_hx_classes["python.io.FileBytesOutput"] = python_io_FileBytesOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["python.io.NativeTextInput"] = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
_hx_classes["python.io.FileTextInput"] = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["seek", "writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def seek(self,p,pos):
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
_hx_classes["python.io.NativeTextOutput"] = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
_hx_classes["python.io.FileTextOutput"] = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes", "seekInTextMode", "seekInBinaryMode"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))

    @staticmethod
    def seekInTextMode(stream,tell,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            p = (tell() + p)
            pos1 = 0
        elif (pos2 == 2):
            stream.seek(0,2)
            p = (tell() + p)
            pos1 = 0
        else:
            pass
        stream.seek(p,pos1)

    @staticmethod
    def seekInBinaryMode(stream,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            pos1 = 1
        elif (pos2 == 2):
            pos1 = 2
        else:
            pass
        stream.seek(p,pos1)
_hx_classes["python.io.IoTools"] = python_io_IoTools


class python_lib__Re_Choice_Impl_:
    _hx_class_name = "python.lib._Re.Choice_Impl_"
    __slots__ = ()
    _hx_statics = ["fromA", "fromB"]

    @staticmethod
    def fromA(x):
        return x

    @staticmethod
    def fromB(x):
        return x
_hx_classes["python.lib._Re.Choice_Impl_"] = python_lib__Re_Choice_Impl_


class python_lib__Re_RegexHelper:
    _hx_class_name = "python.lib._Re.RegexHelper"
    __slots__ = ()
    _hx_statics = ["findallDynamic"]

    @staticmethod
    def findallDynamic(r,string,pos = None,endpos = None):
        if (endpos is None):
            if (pos is None):
                return r.findall(string)
            else:
                return r.findall(string,pos)
        else:
            return r.findall(string,pos,endpos)
_hx_classes["python.lib._Re.RegexHelper"] = python_lib__Re_RegexHelper


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "seek", "tell", "eof", "readByte", "readBytes", "close", "readAll", "readFullBytes", "read", "readUntil", "readLine", "readFloat", "readDouble", "readInt8", "readInt16", "readUInt16", "readInt24", "readUInt24", "readInt32", "readString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def seek(self,p,pos):
        self.impl.seek(p,pos)

    def tell(self):
        return self.impl.tell()

    def eof(self):
        return self.impl.eof()

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def readAll(self,bufsize = None):
        return self.impl.readAll(bufsize)

    def readFullBytes(self,s,pos,_hx_len):
        self.impl.readFullBytes(s,pos,_hx_len)

    def read(self,nbytes):
        return self.impl.read(nbytes)

    def readUntil(self,end):
        return self.impl.readUntil(end)

    def readLine(self):
        return self.impl.readLine()

    def readFloat(self):
        return self.impl.readFloat()

    def readDouble(self):
        return self.impl.readDouble()

    def readInt8(self):
        return self.impl.readInt8()

    def readInt16(self):
        return self.impl.readInt16()

    def readUInt16(self):
        return self.impl.readUInt16()

    def readInt24(self):
        return self.impl.readInt24()

    def readUInt24(self):
        return self.impl.readUInt24()

    def readInt32(self):
        return self.impl.readInt32()

    def readString(self,_hx_len,encoding = None):
        return self.impl.readString(_hx_len)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
_hx_classes["sys.io.FileInput"] = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["seek", "tell", "set_bigEndian", "writeByte", "writeBytes", "flush", "close", "write", "writeFullBytes", "writeFloat", "writeDouble", "writeInt8", "writeInt16", "writeUInt16", "writeInt24", "writeUInt24", "writeInt32", "prepare", "writeInput", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def seek(self,p,pos):
        self.impl.seek(p,pos)

    def tell(self):
        return self.impl.tell()

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

    def write(self,s):
        self.impl.write(s)

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeFloat(self,x):
        self.impl.writeFloat(x)

    def writeDouble(self,x):
        self.impl.writeDouble(x)

    def writeInt8(self,x):
        self.impl.writeInt8(x)

    def writeInt16(self,x):
        self.impl.writeInt16(x)

    def writeUInt16(self,x):
        self.impl.writeUInt16(x)

    def writeInt24(self,x):
        self.impl.writeInt24(x)

    def writeUInt24(self,x):
        self.impl.writeUInt24(x)

    def writeInt32(self,x):
        self.impl.writeInt32(x)

    def prepare(self,nbytes):
        self.impl.prepare(nbytes)

    def writeInput(self,i,bufsize = None):
        self.impl.writeInput(i,bufsize)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
_hx_classes["sys.io.FileOutput"] = sys_io_FileOutput

class sys_io_FileSeek(Enum):
    __slots__ = ()
    _hx_class_name = "sys.io.FileSeek"
    _hx_constructs = ["SeekBegin", "SeekCur", "SeekEnd"]
sys_io_FileSeek.SeekBegin = sys_io_FileSeek("SeekBegin", 0, ())
sys_io_FileSeek.SeekCur = sys_io_FileSeek("SeekCur", 1, ())
sys_io_FileSeek.SeekEnd = sys_io_FileSeek("SeekEnd", 2, ())
_hx_classes["sys.io.FileSeek"] = sys_io_FileSeek


class theories_EightQueens:
    _hx_class_name = "theories.EightQueens"
    __slots__ = ()
    _hx_statics = ["theory"]
_hx_classes["theories.EightQueens"] = theories_EightQueens


class theories_OKeefe8Queens:
    _hx_class_name = "theories.OKeefe8Queens"
    __slots__ = ()
    _hx_statics = ["theory"]
_hx_classes["theories.OKeefe8Queens"] = theories_OKeefe8Queens


class theories_Zebra:
    _hx_class_name = "theories.Zebra"
    __slots__ = ()
    _hx_statics = ["theory"]
_hx_classes["theories.Zebra"] = theories_Zebra

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

haxe_SysTools.winMetaCharacters = [32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13, 44, 59]
StringTools.winMetaCharacters = haxe_SysTools.winMetaCharacters
def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
TimingTests.queens_theory = "queens([]).                                  % when place queen in empty list, solution found\n \nqueens([ Row/Col | Rest]) :-                 % otherwise, for each row\n            queens(Rest),                    % place a queen in each higher numbered row\n            member(Col, [1,2,3,4,5,6,7,8]),  % pick one of the possible column positions\n            safe( Row/Col, Rest).            % and see if that is a safe position\n                                             % if not, fail back and try another column, until\n                                             % the columns are all tried, when fail back to\n                                             % previous row\n \nsafe(_, []).                                 % the empty board is always safe\n \nsafe(Row/Col, [Row1/Col1 | Rest]) :-         % see if attack the queen in next row down\n            Col =\\= Col1,                   % same column?\n            Col1 - Col =\\= Row1 - Row,      % check diagonal\n            Col1 - Col =\\= Row - Row1,\n            safe(Row/Col, Rest).             % no attack on next row, try the rest of board\n  \nboard([1/_, 2/_, 3/_, 4/_, 5/_, 6/_, 7/_, 8/_]).  % prototype board\n\nrun_queens(B) :- board(B),queens(B).\n"
TimingTests.okeefe_queens_theory = "queens(Queens) :-\n    board(Queens, Board, 0, 8, _, _),\n    queens(Board, 0, Queens).\n\nboard([], [], N, N, _, _).\nboard([_|Queens], [Col-Vars|Board], Col0, N, [_|VR], VC) :-\n    Col is Col0+1,\n    functor(Vars, f, N),\n    constraints(N, Vars, VR, VC),\n    board(Queens, Board, Col, N, VR, [_|VC]).\n\nconstraints(0, _, _, _) :- !.\nconstraints(N, Row, [R|Rs], [C|Cs]) :-\n    arg(N, Row, R-C),\n    M is N-1,\n    constraints(M, Row, Rs, Cs).\n\nqueens([], _, []).\nqueens([C|Cs], Row0, [Col|Solution]) :-\n    Row is Row0+1,\n    select(Col-Vars, [C|Cs], Board),\n    arg(Row, Vars, Row-Row),\n    queens(Board, Row, Solution).\n\nrun_queens(B) :- B= [_,_,_,_,_,_,_,_], queens(B).\n\nselect(X, [Head|Tail], Rest) :-\n    select3_(Tail, Head, X, Rest).\n\nselect3_(Tail, Head, Head, Tail).\nselect3_([Head2|Tail], Head, X, [Head|Rest]) :-\n    select3_(Tail, Head2, X, Rest).\n"
TimingTests.zebra_theory = "zebra(Owner) :- solve(S),member([_, Owner, zebra, _, _], S).\n\nsolve(S) :-\n    S = [[C1,N1,P1,D1,S1],\n         [C2,N2,P2,D2,S2],\n         [C3,N3,P3,D3,S3],\n         [C4,N4,P4,D4,S4],\n         [C5,N5,P5,D5,S5]],\n    member([red, 'English man', _, _, _], S),\n    member([_, 'Swede', dog, _, _], S),\n    member([_, 'Dane', _, tea, _], S),\n    left_of([green |_], [white |_], S),\n    member([green, _, _, coffee, _], S),\n    member([_, _, birds, _, pall_mall], S),\n    member([yellow, _, _, _, dunhill], S),\n    D3 = milk,\n    N1 = 'Norwegian',\n    next_to([_, _, _, _, blend], [_, _, cats |_], S),\n    next_to([_, _, _, _, dunhill], [_, _, horse |_], S),\n    member([_, _, _, beer, blue_master], S),\n    member([_, 'German', _, _, prince], S),\n    next_to([_, 'Norwegian' |_], [blue |_], S),\n    next_to([_, _, _, water,_], [_, _, _, _, blend], S),\n    C1 \\== C2, C1 \\== C3, C1 \\== C4, C1 \\== C5,\n    C2 \\== C3, C2 \\== C4, C2 \\== C5,\n    C3 \\== C4, C3 \\== C5, C4 \\== C5,\n    N1 \\== N2, N1 \\== N3, N1 \\== N4, N1 \\== N5,\n    N2 \\== N3, N2 \\== N4, N2 \\== N5,\n    N3 \\== N4, N3 \\== N5, N4 \\== N5,\n    P1 \\== P2, P1 \\== P3, P1 \\== P4, P1 \\== P5,\n    P2 \\== P3, P2 \\== P4, P2 \\== P5,\n    P3 \\== P4, P3 \\== P5, P4 \\== P5,\n    D1 \\== D2, D1 \\== D3, D1 \\== D4, D1 \\== D5,\n    D2 \\== D3, D2 \\== D4, D2 \\== D5,\n    D3 \\== D4, D3 \\== D5, D4 \\== D5,\n    S1 \\== S2, S1 \\== S3, S1 \\== S4, S1 \\== S5,\n    S2 \\== S3, S2 \\== S4, S2 \\== S5,\n    S3 \\== S4, S3 \\== S5, S4 \\== S5.\n\nleft_of(L1, L2, [L1, L2 |_]).\nleft_of(L1, L2, [_| Rest ]) :- left_of(L1, L2, Rest).\n    \nnext_to(L1, L2, S) :- left_of(L1, L2, S).\nnext_to(L1, L2, S) :- left_of(L2, L1, S).\n\n"
blub_prolog_AtomContext.GLOBALS = blub_prolog_AtomContext()
blub_prolog_Marshal.object_atom_id = 0
blub_prolog_PredicateIndicator.SLASH = blub_prolog_AtomContext.GLOBALS.getAtom("/")
blub_prolog_Preprocessor.THEORIES = ["DefiniteClauseGrammar.prolog", "ConstraintHandlingRules.prolog"]
blub_prolog_RuntimeError.ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("error")
blub_prolog_RuntimeError.CONTEXT = blub_prolog_AtomContext.GLOBALS.getAtom("context")
blub_prolog_RuntimeError.NONE = blub_prolog_AtomContext.GLOBALS.getAtom("none")
blub_prolog_RuntimeError.INSTANTIATION_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("instantiation_error")
blub_prolog_RuntimeError.TYPE_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("type_error")
blub_prolog_RuntimeError.EXISTENCE_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("existence_error")
blub_prolog_RuntimeError.DOMAIN_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("domain_error")
blub_prolog_RuntimeError.PERMISSION_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("permission_error")
blub_prolog_RuntimeError.REPRESENTATION_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("representation_error")
blub_prolog_RuntimeError.EVALUATION_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("evaluation_error")
blub_prolog_RuntimeError.RESOURCE_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("resource_error")
blub_prolog_RuntimeError.SYNTAX_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("syntax_error")
blub_prolog_RuntimeError.SYSTEM_ERROR = blub_prolog_AtomContext.GLOBALS.getAtom("system_error")
blub_prolog_RuntimeError.EXIST_PROCEDURE = blub_prolog_AtomContext.GLOBALS.getAtom("procedure")
blub_prolog_RuntimeError.EXIST_SRC_SINK = blub_prolog_AtomContext.GLOBALS.getAtom("source_sink")
blub_prolog_RuntimeError.EXIST_STREAM = blub_prolog_AtomContext.GLOBALS.getAtom("stream")
blub_prolog_TypeError.VALID_TYPE_atom = blub_prolog_AtomContext.GLOBALS.getAtom("atom")
blub_prolog_TypeError.VALID_TYPE_atomic = blub_prolog_AtomContext.GLOBALS.getAtom("atomic")
blub_prolog_TypeError.VALID_TYPE_byte = blub_prolog_AtomContext.GLOBALS.getAtom("byte")
blub_prolog_TypeError.VALID_TYPE_callable = blub_prolog_AtomContext.GLOBALS.getAtom("callable")
blub_prolog_TypeError.VALID_TYPE_character = blub_prolog_AtomContext.GLOBALS.getAtom("character")
blub_prolog_TypeError.VALID_TYPE_evaluable = blub_prolog_AtomContext.GLOBALS.getAtom("evaluable")
blub_prolog_TypeError.VALID_TYPE_in_byte = blub_prolog_AtomContext.GLOBALS.getAtom("in_byte")
blub_prolog_TypeError.VALID_TYPE_in_character = blub_prolog_AtomContext.GLOBALS.getAtom("in_character")
blub_prolog_TypeError.VALID_TYPE_integer = blub_prolog_AtomContext.GLOBALS.getAtom("integer")
blub_prolog_TypeError.VALID_TYPE_list = blub_prolog_AtomContext.GLOBALS.getAtom("list")
blub_prolog_TypeError.VALID_TYPE_number = blub_prolog_AtomContext.GLOBALS.getAtom("number")
blub_prolog_TypeError.VALID_TYPE_predicate_indicator = blub_prolog_AtomContext.GLOBALS.getAtom("predicate_indicator")
blub_prolog_TypeError.VALID_TYPE_variable = blub_prolog_AtomContext.GLOBALS.getAtom("variable")
blub_prolog_TypeError.VALID_TYPE_compound = blub_prolog_AtomContext.GLOBALS.getAtom("compound")
blub_prolog_engine_parts_ChoicePoint.ID = 1
blub_prolog_builtins_Call.INDICATOR = blub_prolog_PredicateIndicator.fromString("call/1")
blub_prolog_builtins_Gensym.count = 1
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
blub_prolog_builtins_Builtins.builtins = ((((((([blub_prolog_builtins_True(), blub_prolog_builtins_Fail(), blub_prolog_builtins_Repeat(), blub_prolog_builtins_Is(), blub_prolog_builtins_Unify(), blub_prolog_builtins_Identical(), blub_prolog_builtins_NotIdentical(), blub_prolog_builtins_Cut(), blub_prolog_builtins_Call(), blub_prolog_builtins_Once(), blub_prolog_builtins_NotUnifiable(), blub_prolog_builtins_NotProvable(), blub_prolog_builtins_IfThen(), blub_prolog_builtins_IfThenElse(), blub_prolog_builtins_AssertA(), blub_prolog_builtins_AssertZ(), blub_prolog_builtins_Retract(), blub_prolog_builtins_Abolish(), blub_prolog_builtins_Timestamp(), blub_prolog_builtins_Gensym(), blub_prolog_builtins_Univ(), blub_prolog_builtins_Write(), blub_prolog_builtins_Clear(), blub_prolog_builtins_Stop(), blub_prolog_builtins_Functor(), blub_prolog_builtins_Arg(), blub_prolog_builtins_AtomCodes(), blub_prolog_builtins_ListSlice(), blub_prolog_builtins_Stack(), blub_prolog_builtins_Member(), blub_prolog_builtins_Breakpoint(), blub_prolog_builtins_Listing(), blub_prolog_builtins_ThrowUp()] + blub_prolog_builtins_BinaryArithmeticPred.get()) + blub_prolog_builtins_TermTypes.get()) + blub_prolog_builtins_Globals.get()) + blub_prolog_builtins_RebindVar.get()) + blub_prolog_builtins_objects_ObjectBuiltins.get()) + blub_prolog_builtins_async_AsyncBuiltins.get()) + blub_prolog_builtins_meta_MetaBuiltins.get())
blub_prolog_compiler_CompilerBase.ADD_LOGGING = True
blub_prolog_terms_Reference.nameGen = 0
def _hx_init_blub_prolog_engine_ArithmeticEvaluator_arithmeticFuncs():
    def _hx_local_0():
        h = haxe_ds_StringMap()
        h.h["+/2"] = True
        h.h["-/2"] = True
        h.h["*/2"] = True
        h.h["//2"] = True
        return h
    return _hx_local_0()
blub_prolog_engine_ArithmeticEvaluator.arithmeticFuncs = _hx_init_blub_prolog_engine_ArithmeticEvaluator_arithmeticFuncs()
blub_prolog_stopgap_parse_Char.OP_CHARS = "#$&*+-./:<=>?@^~\\"
blub_prolog_stopgap_parse_Char.WHITESPACE = " \n\r\t\x0C"
blub_prolog_terms_Atom.ID_GEN = 0
blub_prolog_terms_Atom.A_CODE = HxString.charCodeAt("A",0)
blub_prolog_terms_Atom.Z_CODE = HxString.charCodeAt("Z",0)
blub_prolog_terms_Atom.a_CODE = HxString.charCodeAt("a",0)
blub_prolog_terms_Atom.z_CODE = HxString.charCodeAt("z",0)
blub_prolog_terms_Atom.zero_CODE = HxString.charCodeAt("0",0)
blub_prolog_terms_Atom.nine_CODE = HxString.charCodeAt("9",0)
blub_prolog_terms_Atom.under_CODE = HxString.charCodeAt("_",0)
blub_prolog_terms_Structure.CONS_LIST = blub_prolog_AtomContext.GLOBALS.getAtom("CONS")
blub_prolog_terms_Structure.EMPTY_LIST = blub_prolog_AtomContext.GLOBALS.getAtom("[]")
blub_prolog_terms_Variable.nameCount = 0
blub_prolog_terms_VariableContext.EMPTY = blub_prolog_terms_VariableContext(None,haxe_ds_StringMap(),[])
haxe_EntryPoint.sleepLock = haxe__EntryPoint_Lock()
haxe_EntryPoint.mutex = haxe__EntryPoint_Mutex()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
def _hx_init_haxe_io_FPHelper_i64tmp():
    def _hx_local_0():
        this1 = haxe__Int64____Int64(0,0)
        return this1
    return _hx_local_0()
haxe_io_FPHelper.i64tmp = _hx_init_haxe_io_FPHelper_i64tmp()
haxe_io_FPHelper.LN2 = 0.6931471805599453
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
theories_EightQueens.theory = "queens([]).                                  % when place queen in empty list, solution found\n \nqueens([ Row/Col | Rest]) :-                 % otherwise, for each row\n            queens(Rest),                    % place a queen in each higher numbered row\n            member(Col, [1,2,3,4,5,6,7,8]),  % pick one of the possible column positions\n            safe( Row/Col, Rest).            % and see if that is a safe position\n                                             % if not, fail back and try another column, until\n                                             % the columns are all tried, when fail back to\n                                             % previous row\n \nsafe(_, []).                                 % the empty board is always safe\n \nsafe(Row/Col, [Row1/Col1 | Rest]) :-         % see if attack the queen in next row down\n            Col =\\= Col1,                   % same column?\n            Col1 - Col =\\= Row1 - Row,      % check diagonal\n            Col1 - Col =\\= Row - Row1,\n            safe(Row/Col, Rest).             % no attack on next row, try the rest of board\n  \nboard([1/_, 2/_, 3/_, 4/_, 5/_, 6/_, 7/_, 8/_]).  % prototype board\n\nrun_queens(B) :- board(B),queens(B).\n"
theories_OKeefe8Queens.theory = "queens(Queens) :-\n    board(Queens, Board, 0, 8, _, _),\n    queens(Board, 0, Queens).\n\nboard([], [], N, N, _, _).\nboard([_|Queens], [Col-Vars|Board], Col0, N, [_|VR], VC) :-\n    Col is Col0+1,\n    functor(Vars, f, N),\n    constraints(N, Vars, VR, VC),\n    board(Queens, Board, Col, N, VR, [_|VC]).\n\nconstraints(0, _, _, _) :- !.\nconstraints(N, Row, [R|Rs], [C|Cs]) :-\n    arg(N, Row, R-C),\n    M is N-1,\n    constraints(M, Row, Rs, Cs).\n\nqueens([], _, []).\nqueens([C|Cs], Row0, [Col|Solution]) :-\n    Row is Row0+1,\n    select(Col-Vars, [C|Cs], Board),\n    arg(Row, Vars, Row-Row),\n    queens(Board, Row, Solution).\n\nrun_queens(B) :- B= [_,_,_,_,_,_,_,_], queens(B).\n\nselect(X, [Head|Tail], Rest) :-\n    select3_(Tail, Head, X, Rest).\n\nselect3_(Tail, Head, Head, Tail).\nselect3_([Head2|Tail], Head, X, [Head|Rest]) :-\n    select3_(Tail, Head2, X, Rest).\n"
theories_Zebra.theory = "zebra(Owner) :- solve(S),member([_, Owner, zebra, _, _], S).\n\nsolve(S) :-\n    S = [[C1,N1,P1,D1,S1],\n         [C2,N2,P2,D2,S2],\n         [C3,N3,P3,D3,S3],\n         [C4,N4,P4,D4,S4],\n         [C5,N5,P5,D5,S5]],\n    member([red, 'English man', _, _, _], S),\n    member([_, 'Swede', dog, _, _], S),\n    member([_, 'Dane', _, tea, _], S),\n    left_of([green |_], [white |_], S),\n    member([green, _, _, coffee, _], S),\n    member([_, _, birds, _, pall_mall], S),\n    member([yellow, _, _, _, dunhill], S),\n    D3 = milk,\n    N1 = 'Norwegian',\n    next_to([_, _, _, _, blend], [_, _, cats |_], S),\n    next_to([_, _, _, _, dunhill], [_, _, horse |_], S),\n    member([_, _, _, beer, blue_master], S),\n    member([_, 'German', _, _, prince], S),\n    next_to([_, 'Norwegian' |_], [blue |_], S),\n    next_to([_, _, _, water,_], [_, _, _, _, blend], S),\n    C1 \\== C2, C1 \\== C3, C1 \\== C4, C1 \\== C5,\n    C2 \\== C3, C2 \\== C4, C2 \\== C5,\n    C3 \\== C4, C3 \\== C5, C4 \\== C5,\n    N1 \\== N2, N1 \\== N3, N1 \\== N4, N1 \\== N5,\n    N2 \\== N3, N2 \\== N4, N2 \\== N5,\n    N3 \\== N4, N3 \\== N5, N4 \\== N5,\n    P1 \\== P2, P1 \\== P3, P1 \\== P4, P1 \\== P5,\n    P2 \\== P3, P2 \\== P4, P2 \\== P5,\n    P3 \\== P4, P3 \\== P5, P4 \\== P5,\n    D1 \\== D2, D1 \\== D3, D1 \\== D4, D1 \\== D5,\n    D2 \\== D3, D2 \\== D4, D2 \\== D5,\n    D3 \\== D4, D3 \\== D5, D4 \\== D5,\n    S1 \\== S2, S1 \\== S3, S1 \\== S4, S1 \\== S5,\n    S2 \\== S3, S2 \\== S4, S2 \\== S5,\n    S3 \\== S4, S3 \\== S5, S4 \\== S5.\n\nleft_of(L1, L2, [L1, L2 |_]).\nleft_of(L1, L2, [_| Rest ]) :- left_of(L1, L2, Rest).\n    \nnext_to(L1, L2, S) :- left_of(L1, L2, S).\nnext_to(L1, L2, S) :- left_of(L2, L1, S).\n\n"

TimingTests.main()
haxe_EntryPoint.run()
