-- Generated by Haxe 4.1.3
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            first = true
            buffer = {}
            for k,v in pairs(obj) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end
            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

function _hx_error(obj)
    print(obj)
    if obj.value then
        _G.print("Runtime Error: " .. _hx_tostring(obj.value));
    else
        _G.print("Runtime Error: " .. tostring(obj));
    end

    if _G.debug and _G.debug.traceback then
        _G.print(debug.traceback());
    end
end


local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    res = {}
    idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local _hx_exports = _hx_exports or {}
_hx_exports["blub"] = _hx_exports["blub"] or _hx_e()
_hx_exports["blub"]["prolog"] = _hx_exports["blub"]["prolog"] or _hx_e()
_hx_exports["blub"]["prolog"]["terms"] = _hx_exports["blub"]["prolog"]["terms"] or _hx_e()
local Array = _hx_e()
local Date = _hx_e()
__lua_lib_lrexlib_Rex = _G.require("rex_pcre")
__lua_lib_luautf8_Utf8 = _G.require("lua-utf8")
local EReg = _hx_e()
___EnumValue_EnumValue_Impl_ = _hx_e()
local IntIterator = _hx_e()
local Lambda = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
__haxe_SysTools = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local TimingTests = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
__haxe_ds__Map_Map_Impl_ = _hx_e()
__blub_prolog_AtomContext = _hx_e()
__blub_prolog_Clause = _hx_e()
__blub_prolog_Database = _hx_e()
__blub_prolog_Listeners = _hx_e()
__blub_prolog_PredicateListener = _hx_e()
__blub_prolog_AssertionListener = _hx_e()
__blub_prolog_RetractionListener = _hx_e()
__blub_prolog_Marshal = _hx_e()
__blub_prolog_PredicateIndicator = _hx_e()
__blub_prolog_Predicate = _hx_e()
__blub_prolog_Preprocessor = _hx_e()
__blub_prolog_PrologError = _hx_e()
__blub_prolog_PrologException = _hx_e()
__blub_prolog_RuntimeError = _hx_e()
__blub_prolog_ExistenceError = _hx_e()
__blub_prolog_TypeError = _hx_e()
__blub_prolog_Query = _hx_e()
__blub_prolog_Result = _hx_e()
__blub_prolog_ResultUtil = _hx_e()
__blub_prolog_async_AsyncQuery = _hx_e()
__blub_prolog_async_AsyncResults = _hx_e()
__blub_prolog_async_AsyncResultsImpl = _hx_e()
__blub_prolog_builtins_BuiltinPredicate = _hx_e()
__blub_prolog_builtins_Abolish = _hx_e()
__blub_prolog_builtins_Arg = _hx_e()
__blub_prolog_engine_parts_ChoicePoint = _hx_e()
__blub_prolog_builtins_ArgChoicePoint = _hx_e()
__blub_prolog_builtins_AssertA = _hx_e()
__blub_prolog_builtins_AssertZ = _hx_e()
__blub_prolog_builtins_AtomCodes = _hx_e()
__blub_prolog_builtins_BinaryArithmeticPred = _hx_e()
__blub_prolog_builtins_Breakpoint = _hx_e()
__blub_prolog_builtins_True = _hx_e()
__blub_prolog_builtins_Fail = _hx_e()
__blub_prolog_builtins_Repeat = _hx_e()
__blub_prolog_builtins_Is = _hx_e()
__blub_prolog_builtins_Unify = _hx_e()
__blub_prolog_builtins_Identical = _hx_e()
__blub_prolog_builtins_NotIdentical = _hx_e()
__blub_prolog_builtins_Cut = _hx_e()
__blub_prolog_builtins_Call = _hx_e()
__blub_prolog_builtins_Once = _hx_e()
__blub_prolog_builtins_NotUnifiable = _hx_e()
__blub_prolog_builtins_NotProvable = _hx_e()
__blub_prolog_builtins_IfThen = _hx_e()
__blub_prolog_builtins_IfThenElse = _hx_e()
__blub_prolog_builtins_Retract = _hx_e()
__blub_prolog_builtins_Timestamp = _hx_e()
__blub_prolog_builtins_Gensym = _hx_e()
__blub_prolog_builtins_Univ = _hx_e()
__blub_prolog_builtins_Write = _hx_e()
__blub_prolog_builtins_Clear = _hx_e()
__blub_prolog_builtins_Stop = _hx_e()
__blub_prolog_builtins_Functor = _hx_e()
__blub_prolog_builtins_ListSlice = _hx_e()
__blub_prolog_builtins_Stack = _hx_e()
__blub_prolog_builtins_Member = _hx_e()
__blub_prolog_builtins_Listing = _hx_e()
__blub_prolog_builtins_ThrowUp = _hx_e()
__blub_prolog_builtins_TermTypes = _hx_e()
__lua_Boot = _hx_e()
__lua_Thread = _hx_e()
__lua_UserData = _hx_e()
__blub_prolog_builtins_Globals = _hx_e()
__blub_prolog_builtins_GetGlobal = _hx_e()
__blub_prolog_builtins_SetGlobal = _hx_e()
__blub_prolog_builtins_RebindVar = _hx_e()
__blub_prolog_builtins_NonBacktrackingRebindVar = _hx_e()
__blub_prolog_builtins_BacktrackingRebindVar = _hx_e()
__blub_prolog_builtins_ArithmeticRebind = _hx_e()
__blub_prolog_builtins_NonBacktrackingArithmeticRebind = _hx_e()
__blub_prolog_builtins_BacktrackingArithmeticRebind = _hx_e()
__blub_prolog_builtins_objects_ObjectBuiltins = _hx_e()
__blub_prolog_builtins_objects_DotAccessor = _hx_e()
__blub_prolog_builtins_objects_ArrowAssigner = _hx_e()
__blub_prolog_builtins_async_AsyncBuiltins = _hx_e()
__blub_prolog_builtins_async_messages_Send = _hx_e()
__blub_prolog_builtins_async_messages_Receive = _hx_e()
__blub_prolog_builtins_async_Sleep = _hx_e()
__blub_prolog_builtins_async_Spawn = _hx_e()
__blub_prolog_builtins_async_Spawns = _hx_e()
__blub_prolog_builtins_async_Stop = _hx_e()
__blub_prolog_builtins_meta_MetaBuiltins = _hx_e()
__blub_prolog_builtins_meta_MetaAbort = _hx_e()
__blub_prolog_builtins_meta_MetaQuery = _hx_e()
__blub_prolog_builtins_meta_MetaSolution = _hx_e()
__blub_prolog_builtins_Builtins = _hx_e()
__blub_prolog_builtins_NotCallable = _hx_e()
__blub_prolog_compiler_CompilerBase = _hx_e()
__blub_prolog_builtins_CallCompiler = _hx_e()
__blub_prolog_builtins_MemberChoicePoint = _hx_e()
__blub_prolog_terms_Term = _hx_e()
__blub_prolog_terms_ValueTerm = _hx_e()
__blub_prolog_terms_Reference = _hx_e()
__blub_prolog_builtins__Stack_StackTail = _hx_e()
__blub_prolog_terms_ValueTermImpl = _hx_e()
__blub_prolog_terms_ClauseTerm = _hx_e()
__blub_prolog_terms_ClauseTermImpl = _hx_e()
__blub_prolog_builtins__Stack_StackHead = _hx_e()
__blub_prolog_builtins_async_AsyncOperation = _hx_e()
__blub_prolog_builtins_async_AsyncOperationImpl = _hx_e()
__blub_prolog_builtins_async_messages_MessageChannel = _hx_e()
__blub_prolog_builtins_async_messages_MessageListener = _hx_e()
__blub_prolog_builtins_lazy_LazyLoadPredicates = _hx_e()
__blub_prolog_builtins_meta_TemplateQuery = _hx_e()
__blub_prolog_builtins_objects_ObjectWrapper = _hx_e()
__blub_prolog_builtins_objects_ObjectWrapperImpl = _hx_e()
__blub_prolog_builtins_objects_HashObjectWrapper = _hx_e()
__blub_prolog_builtins_objects_NativeAccess = _hx_e()
__blub_prolog_builtins_objects_PropertyListener = _hx_e()
__blub_prolog_compiler_Assembler = _hx_e()
__blub_prolog_compiler_ClauseCompiler = _hx_e()
__blub_prolog_compiler_Instruction = _hx_e()
__blub_prolog_compiler_PredicateCompiler = _hx_e()
__blub_prolog_compiler_QueryCompiler = _hx_e()
__blub_prolog_engine_ArithmeticEvaluator = _hx_e()
__blub_prolog_engine_DatabaseTransaction = _hx_e()
__blub_prolog_engine_Operations = _hx_e()
__blub_prolog_engine_AsyncCallbackType = _hx_e()
__blub_prolog_terms_BindingTrail = _hx_e()
__blub_prolog_engine_QueryEngine = _hx_e()
__blub_prolog_engine_parts_ClauseChoices = _hx_e()
__blub_prolog_engine_parts_CodeFrame = _hx_e()
__blub_prolog_engine_parts_CutPoint = _hx_e()
__blub_prolog_engine_parts_RepeatingChoicePoint = _hx_e()
__blub_prolog_stopgap_parse_Char = _hx_e()
__blub_prolog_stopgap_parse_Lexer = _hx_e()
__blub_prolog_stopgap_parse_Operator = _hx_e()
__blub_prolog_stopgap_parse_Specifier = _hx_e()
__blub_prolog_stopgap_parse_OperatorSpec = _hx_e()
__blub_prolog_stopgap_parse_Operators = _hx_e()
__blub_prolog_stopgap_parse_ParseError = _hx_e()
__blub_prolog_stopgap_parse_ParseNode = _hx_e()
__blub_prolog_stopgap_parse_Parser = _hx_e()
__blub_prolog_stopgap_parse_Token = _hx_e()
__blub_prolog_stopgap_parse_TokenType = _hx_e()
__blub_prolog_terms_ListTerm = _hx_e()
__blub_prolog_terms_Atom = _hx_e()
__blub_prolog_terms_NumberTerm = _hx_e()
__blub_prolog_terms_Structure = _hx_e()
__blub_prolog_terms__Structure_ListStructureIterator = _hx_e()
__blub_prolog_terms__Structure_ListIterator = _hx_e()
__blub_prolog_terms_TermParse = _hx_e()
__blub_prolog_terms_Variable = _hx_e()
__blub_prolog_terms_VariableContext = _hx_e()
__blub_prolog_util_DLListListener = _hx_e()
__blub_prolog_util_TailIterable = _hx_e()
__blub_prolog_util_EntryDeletionListener = _hx_e()
__blub_prolog_util_DLList = _hx_e()
__blub_prolog_util_Entry = _hx_e()
__blub_prolog_util__DLList_ItemIter = _hx_e()
__blub_prolog_util__DLList_EntryIter = _hx_e()
__blub_prolog_util__DLList_EntryImpl = _hx_e()
__haxe_StackItem = _hx_e()
__haxe__CallStack_CallStack_Impl_ = _hx_e()
__haxe_IMap = _hx_e()
__haxe__EntryPoint_Lock = _hx_e()
__haxe__EntryPoint_Mutex = _hx_e()
__haxe__EntryPoint_Thread = _hx_e()
__haxe_EntryPoint = _hx_e()
__haxe_Exception = _hx_e()
__haxe__Int32_Int32_Impl_ = _hx_e()
__haxe__Int64_Int64_Impl_ = _hx_e()
__haxe__Int64____Int64 = _hx_e()
__haxe_Int64Helper = _hx_e()
__haxe_Log = _hx_e()
__haxe_MainEvent = _hx_e()
__haxe_MainLoop = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe_Resource = _hx_e()
__haxe_Timer = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_io_Bytes = _hx_e()
__haxe_crypto_Base64 = _hx_e()
__haxe_crypto_BaseCode = _hx_e()
__haxe_ds_BalancedTree = _hx_e()
__haxe_ds_TreeNode = _hx_e()
__haxe_ds_EnumValueMap = _hx_e()
__haxe_ds__HashMap_HashMap_Impl_ = _hx_e()
__haxe_ds__HashMap_HashMapData = _hx_e()
__haxe_ds_IntMap = _hx_e()
__haxe_ds_List = _hx_e()
__haxe_ds__List_ListNode = _hx_e()
__haxe_ds__List_ListIterator = _hx_e()
__haxe_ds__List_ListKeyValueIterator = _hx_e()
__haxe_ds_ObjectMap = _hx_e()
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_ = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_ds_WeakMap = _hx_e()
__haxe_io_BytesBuffer = _hx_e()
__haxe_io_Encoding = _hx_e()
__haxe_io_Eof = _hx_e()
__haxe_io_Error = _hx_e()
__haxe_io_FPHelper = _hx_e()
__haxe_io_Input = _hx_e()
__haxe_io_Output = _hx_e()
__haxe_io_Path = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__haxe_iterators_HashMapKeyValueIterator = _hx_e()
__haxe_iterators_MapKeyValueIterator = _hx_e()
__haxe_iterators_StringIterator = _hx_e()
__haxe_iterators_StringIteratorUnicode = _hx_e()
__haxe_iterators_StringKeyValueIterator = _hx_e()
__lua_HaxeIterator = _hx_e()
__lua__Io_IoType_Impl_ = _hx_e()
__lua_Lib = _hx_e()
__lua__NativeIterator_NativeIterator_Impl_ = _hx_e()
__lua_PairTools = _hx_e()
__lua_lib_luv_Handle = _G.require("luv")
__lua_lib_luv_Loop = _G.require("luv")
__lua_lib_luv_Misc = _G.require("luv")
__lua_lib_luv_Os = _G.require("luv")
__lua_lib_luv_Stream = _G.require("luv")
__lua_lib_luv_Pipe = _G.require("luv")
__lua_lib_luv_Process = _G.require("luv")
__lua_lib_luv_Request = _G.require("luv")
__lua_lib_luv_Signal = _G.require("luv")
__lua_lib_luv_Thread = _G.require("luv")
__lua_lib_luv_Timer = _G.require("luv")
__lua_lib_luv_fs_FileSystem = _G.require("luv")
__lua_lib_luv_net_Tcp = _G.require("luv")
__sys_FileSystem = _hx_e()
__sys_io_FileInput = _hx_e()
__sys_io_FileOutput = _hx_e()
__sys_io_FileSeek = _hx_e()
__sys_io_Process = _hx_e()
__sys_io__Process_ProcessInput = _hx_e()
__sys_io__Process_ProcessOutput = _hx_e()
__theories_EightQueens = _hx_e()
__theories_Zebra = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
_hxClasses["Array"] = Array
Array.__name__ = "Array"
Array.prototype = _hx_e();
Array.prototype.length= nil;
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do 
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do 
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    _G.table.insert(tbl, Std.string(i));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do 
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t", self.t);
  self.dUTC = _G.os.date("!*t", self.t);
end
_hxClasses["Date"] = Date
Date.__name__ = "Date"
Date.now = function() 
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d end;
end
Date.fromTime = function(t) 
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return d end;
end
Date.fromString = function(s) 
  do return __lua_Boot.strDate(s) end;
end
Date.prototype = _hx_e();
Date.prototype.d= nil;
Date.prototype.dUTC= nil;
Date.prototype.t= nil;
Date.prototype.getTime = function(self) 
  do return self.t * 1000 end
end
Date.prototype.getHours = function(self) 
  do return self.d.hour end
end
Date.prototype.getMinutes = function(self) 
  do return self.d.min end
end
Date.prototype.getSeconds = function(self) 
  do return self.d.sec end
end
Date.prototype.getFullYear = function(self) 
  do return self.d.year end
end
Date.prototype.getMonth = function(self) 
  do return self.d.month - 1 end
end
Date.prototype.getDate = function(self) 
  do return self.d.day end
end
Date.prototype.getDay = function(self) 
  do return self.d.wday - 1 end
end
Date.prototype.getUTCHours = function(self) 
  do return self.dUTC.hour end
end
Date.prototype.getUTCMinutes = function(self) 
  do return self.dUTC.min end
end
Date.prototype.getUTCSeconds = function(self) 
  do return self.dUTC.sec end
end
Date.prototype.getUTCFullYear = function(self) 
  do return self.dUTC.year end
end
Date.prototype.getUTCMonth = function(self) 
  do return self.dUTC.month - 1 end
end
Date.prototype.getUTCDate = function(self) 
  do return self.dUTC.day end
end
Date.prototype.getUTCDay = function(self) 
  do return self.dUTC.wday - 1 end
end
Date.prototype.getTimezoneOffset = function(self) 
  local tUTC = _G.os.time(self.dUTC);
  do return Std.int((tUTC - self.t) / 60) end
end
Date.prototype.toString = function(self) 
  do return __lua_Boot.dateStr(self) end
end

Date.prototype.__class__ =  Date

EReg.new = function(r,opt) 
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt) 
  local ropt = 0;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(opt);
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g = __lua_lib_luautf8_Utf8.sub(opt, i + 1, i + 1);
    if (_g) == "g" then 
      self.global = true;
    elseif (_g) == "i" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.CASELESS);
    elseif (_g) == "m" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.MULTILINE);
    elseif (_g) == "s" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.DOTALL);else end;
  end;
  ropt = _hx_bit.bor(ropt,EReg.FLAGS.UTF8);
  ropt = _hx_bit.bor(ropt,EReg.FLAGS.UCP);
  if (self.global == nil) then 
    self.global = false;
  end;
  self.r = __lua_lib_lrexlib_Rex.new(r, ropt);
end
_hxClasses["EReg"] = EReg
EReg.__name__ = "EReg"
EReg.escape = function(s) 
  do return EReg.escapeRegExpRe:map(s, function(r) 
    do return Std.string("\\") .. Std.string(r:matched(0)) end;
  end) end;
end
EReg.prototype = _hx_e();
EReg.prototype.r= nil;
EReg.prototype.global= nil;
EReg.prototype.s= nil;
EReg.prototype.m= nil;
EReg.prototype.match = function(self,s) 
  if (s == nil) then 
    do return false end;
  else
    self.m = _hx_table.pack(self.r:exec(s, 1));
    self.s = s;
    do return self.m[1] ~= nil end;
  end;
end
EReg.prototype.matchFromByte = function(self,s,offset) 
  if (s == nil) then 
    do return false end;
  end;
  self.m = _hx_table.pack(self.r:exec(s, offset));
  self.s = s;
  do return self.m[1] ~= nil end
end
EReg.prototype.matched = function(self,n) 
  if ((self.m[1] == nil) or (n < 0)) then 
    _G.error(__haxe_Exception.thrown("EReg::matched"),0);
  else
    if (n == 0) then 
      local k = _G.string.sub(self.s, self.m[1], self.m[2]);
      do return k end;
    else
      if (__lua_Boot.__instanceof(self.m[3], _G.table)) then 
        local mn = 2 * (n - 1);
        if (__lua_Boot.__instanceof(self.m[3][mn + 1], Bool)) then 
          do return nil end;
        end;
        do return _G.string.sub(self.s, self.m[3][mn + 1], self.m[3][mn + 2]) end;
      else
        _G.error(__haxe_Exception.thrown("EReg:matched"),0);
      end;
    end;
  end;
end
EReg.prototype.matchedLeft = function(self) 
  if (self.m[1] == nil) then 
    _G.error(__haxe_Exception.thrown("No string matched"),0);
  end;
  do return _G.string.sub(self.s, 1, self.m[1] - 1) end
end
EReg.prototype.matchedRight = function(self) 
  if (self.m[1] == nil) then 
    _G.error(__haxe_Exception.thrown("No string matched"),0);
  end;
  do return _G.string.sub(self.s, self.m[2] + 1) end
end
EReg.prototype.matchedPos = function(self) 
  local left = self:matchedLeft();
  local matched = self:matched(0);
  if (self.m[1] == nil) then 
    _G.error(__haxe_Exception.thrown("No string matched"),0);
  end;
  do return _hx_o({__fields__={pos=true,len=true},pos=__lua_lib_luautf8_Utf8.len(left),len=__lua_lib_luautf8_Utf8.len(matched)}) end
end
EReg.prototype.matchSub = function(self,s,pos,len) 
  if (len == nil) then 
    len = -1;
  end;
  local pos1 = 0;
  local len = (function() 
    local _hx_1
    if (len < 0) then 
    _hx_1 = __lua_lib_luautf8_Utf8.len(s); else 
    _hx_1 = pos + len; end
    return _hx_1
  end )();
  if ((len == nil) or (len > (pos1 + __lua_lib_luautf8_Utf8.len(s)))) then 
    len = __lua_lib_luautf8_Utf8.len(s);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(s) + len;
    end;
  end;
  if (pos1 < 0) then 
    pos1 = __lua_lib_luautf8_Utf8.len(s) + pos1;
  end;
  if (pos1 < 0) then 
    pos1 = 0;
  end;
  local ss = __lua_lib_luautf8_Utf8.sub(s, pos1 + 1, pos1 + len);
  if (self.global) then 
    self.m = _hx_table.pack(self.r:exec(ss, pos + 1));
    local b = self.m[1] ~= nil;
    if (b) then 
      self.s = s;
    end;
    do return b end;
  else
    self.m = _hx_table.pack(self.r:exec(ss, pos + 1));
    local b = self.m[1] ~= nil;
    if (b) then 
      self.s = s;
    end;
    do return b end;
  end;
end
EReg.prototype.split = function(self,s) 
  if (self.global) then 
    do return __lua_Lib.fillArray(_hx_wrap_if_string_field(__lua_lib_lrexlib_Rex,'split')(s, self.r)) end;
  else
    local d = "#__delim__#";
    do return __lua_Lib.fillArray(_hx_wrap_if_string_field(__lua_lib_lrexlib_Rex,'split')(self:replace(s, d), d)) end;
  end;
end
EReg.prototype.replace = function(self,s,by) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("$$") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(by, "$$", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(by)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(by, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("$$");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(by, idx, __lua_lib_luautf8_Utf8.len(by)));
      idx = nil;
    end;
  end;
  local chunks = ret;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  while (_g1 < chunks.length) do 
    local chunk = chunks[_g1];
    _g1 = _g1 + 1;
    _g:push(__lua_lib_lrexlib_Rex.gsub(chunk, "\\$(\\d)", "%%%1", 1));
  end;
  chunks = _g;
  by = chunks:join("$");
  do return __lua_lib_lrexlib_Rex.gsub(s, self.r, by, (function() 
    local _hx_1
    if (self.global) then 
    _hx_1 = nil; else 
    _hx_1 = 1; end
    return _hx_1
  end )()) end
end
EReg.prototype.map = function(self,s,f) 
  local bytesOffset = 1;
  local buf_b = ({});
  local buf_length = 0;
  while (true) do 
    if (bytesOffset > _G.string.len(s)) then 
      break;
    else
      local tmp;
      if (s == nil) then 
        tmp = false;
      else
        self.m = _hx_table.pack(self.r:exec(s, bytesOffset));
        self.s = s;
        tmp = self.m[1] ~= nil;
      end;
      if (not tmp) then 
        local str = Std.string(_G.string.sub(s, bytesOffset));
        _G.table.insert(buf_b, str);
        buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
        break;
      end;
    end;
    local pos = self.m[1];
    local length = self.m[2] - self.m[1];
    local str = Std.string(_G.string.sub(s, bytesOffset, pos - 1));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(f(self));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    if (length < 0) then 
      local charBytes = _G.string.len(__lua_lib_luautf8_Utf8.sub(_G.string.sub(s, pos), 1, 1));
      local str = Std.string(_G.string.sub(s, pos, (pos + charBytes) - 1));
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      bytesOffset = pos + charBytes;
    else
      bytesOffset = self.m[2] + 1;
    end;
    if (not self.global) then 
      break;
    end;
  end;
  if ((not self.global and (bytesOffset > 1)) and ((bytesOffset - 1) < _G.string.len(s))) then 
    local str = Std.string(_G.string.sub(s, bytesOffset));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  do return _G.table.concat(buf_b) end
end
EReg.prototype.map_old = function(self,s,f) 
  local offset = 0;
  local buf_b = ({});
  local buf_length = 0;
  while (true) do 
    if (offset >= __lua_lib_luautf8_Utf8.len(s)) then 
      break;
    else
      if (not self:matchSub(s, offset)) then 
        local pos = offset;
        local len = nil;
        if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
          len = __lua_lib_luautf8_Utf8.len(s);
        else
          if (len < 0) then 
            len = __lua_lib_luautf8_Utf8.len(s) + len;
          end;
        end;
        if (pos < 0) then 
          pos = __lua_lib_luautf8_Utf8.len(s) + pos;
        end;
        if (pos < 0) then 
          pos = 0;
        end;
        local str = Std.string(__lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len));
        _G.table.insert(buf_b, str);
        buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
        break;
      end;
    end;
    local p = self:matchedPos();
    local pos = offset;
    local len = p.pos - offset;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    local str = Std.string(__lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(f(self));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    if (p.len == 0) then 
      local pos = p.pos;
      local len = 1;
      if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
        len = __lua_lib_luautf8_Utf8.len(s);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(s) + len;
        end;
      end;
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(s) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      local str = Std.string(__lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len));
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      offset = p.pos + 1;
    else
      offset = p.pos + p.len;
    end;
    if (not self.global) then 
      break;
    end;
  end;
  if ((not self.global and (offset > 0)) and (offset < __lua_lib_luautf8_Utf8.len(s))) then 
    local pos = offset;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    local str = Std.string(__lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len));
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  do return _G.table.concat(buf_b) end
end

EReg.prototype.__class__ =  EReg

___EnumValue_EnumValue_Impl_.new = {}
_hxClasses["_EnumValue.EnumValue_Impl_"] = ___EnumValue_EnumValue_Impl_
___EnumValue_EnumValue_Impl_.__name__ = "_EnumValue.EnumValue_Impl_"
___EnumValue_EnumValue_Impl_.match = function(this1,pattern) 
  do return false end;
end

IntIterator.new = function(min,max) 
  local self = _hx_new(IntIterator.prototype)
  IntIterator.super(self,min,max)
  return self
end
IntIterator.super = function(self,min,max) 
  self.min = min;
  self.max = max;
end
_hxClasses["IntIterator"] = IntIterator
IntIterator.__name__ = "IntIterator"
IntIterator.prototype = _hx_e();
IntIterator.prototype.min= nil;
IntIterator.prototype.max= nil;
IntIterator.prototype.hasNext = function(self) 
  do return self.min < self.max end
end
IntIterator.prototype.next = function(self) 
  do return (function() 
  local _hx_obj = self;
  local _hx_fld = 'min';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)() end
end

IntIterator.prototype.__class__ =  IntIterator

Lambda.new = {}
_hxClasses["Lambda"] = Lambda
Lambda.__name__ = "Lambda"
Lambda.array = function(it) 
  local a = Array.new();
  local i = it:iterator();
  while (i:hasNext()) do 
    local i = i:next();
    a:push(i);
  end;
  do return a end;
end
Lambda.list = function(it) 
  local l = __haxe_ds_List.new();
  local i = it:iterator();
  while (i:hasNext()) do 
    local i = i:next();
    l:add(i);
  end;
  do return l end;
end
Lambda.map = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    _g:push(f(x));
  end;
  do return _g end;
end
Lambda.mapi = function(it,f) 
  local i = 0;
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    i = i + 1;
    _g:push(f(i - 1, x));
  end;
  do return _g end;
end
Lambda.flatten = function(it) 
  local _g = _hx_tab_array({}, 0);
  local e = it:iterator();
  while (e:hasNext()) do 
    local e = e:next();
    local x = e:iterator();
    while (x:hasNext()) do 
      local x = x:next();
      _g:push(x);
    end;
  end;
  do return _g end;
end
Lambda.flatMap = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    _g:push(f(x));
  end;
  local _g1 = _hx_tab_array({}, 0);
  local e = _g:iterator();
  while (e:hasNext()) do 
    local e = e:next();
    local x = e:iterator();
    while (x:hasNext()) do 
      local x = x:next();
      _g1:push(x);
    end;
  end;
  do return _g1 end;
end
Lambda.has = function(it,elt) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    if (x == elt) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.exists = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    if (f(x)) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.foreach = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    if (not f(x)) then 
      do return false end;
    end;
  end;
  do return true end;
end
Lambda.iter = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    f(x);
  end;
end
Lambda.filter = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    if (f(x)) then 
      _g:push(x);
    end;
  end;
  do return _g end;
end
Lambda.fold = function(it,f,first) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    first = f(x, first);
  end;
  do return first end;
end
Lambda.foldi = function(it,f,first) 
  local i = 0;
  local x = it:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    first = f(x, first, i);
    i = i + 1;
  end;
  do return first end;
end
Lambda.count = function(it,pred) 
  local n = 0;
  if (pred == nil) then 
    local _ = it:iterator();
    while (_:hasNext()) do 
      local _ = _:next();
      n = n + 1;
    end;
  else
    local x = it:iterator();
    while (x:hasNext()) do 
      local x = x:next();
      if (pred(x)) then 
        n = n + 1;
      end;
    end;
  end;
  do return n end;
end
Lambda.empty = function(it) 
  do return not it:iterator():hasNext() end;
end
Lambda.indexOf = function(it,v) 
  local i = 0;
  local v2 = it:iterator();
  while (v2:hasNext()) do 
    local v2 = v2:next();
    if (v == v2) then 
      do return i end;
    end;
    i = i + 1;
  end;
  do return -1 end;
end
Lambda.find = function(it,f) 
  local v = it:iterator();
  while (v:hasNext()) do 
    local v = v:next();
    if (f(v)) then 
      do return v end;
    end;
  end;
  do return nil end;
end
Lambda.findIndex = function(it,f) 
  local i = 0;
  local v = it:iterator();
  while (v:hasNext()) do 
    local v = v:next();
    if (f(v)) then 
      do return i end;
    end;
    i = i + 1;
  end;
  do return -1 end;
end
Lambda.concat = function(a,b) 
  local l = Array.new();
  local x = a:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    l:push(x);
  end;
  local x = b:iterator();
  while (x:hasNext()) do 
    local x = x:next();
    l:push(x);
  end;
  do return l end;
end

Math.new = {}
_hxClasses["Math"] = Math
Math.__name__ = "Math"
Math.__properties__ = {get_NaN="get_NaN",get_POSITIVE_INFINITY="get_POSITIVE_INFINITY",get_NEGATIVE_INFINITY="get_NEGATIVE_INFINITY",get_PI="get_PI"}
Math.PI = nil
Math.get_PI = function() 
  do return _G.math.pi end;
end
Math.NEGATIVE_INFINITY = nil
Math.get_NEGATIVE_INFINITY = function() 
  do return -_G.math.huge end;
end
Math.POSITIVE_INFINITY = nil
Math.get_POSITIVE_INFINITY = function() 
  do return _G.math.huge end;
end
Math.NaN = nil
Math.get_NaN = function() 
  do return (0/0) end;
end
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.abs = function(v) 
  do return _G.math.abs(v) end;
end
Math.acos = function(v) 
  do return _G.math.acos(v) end;
end
Math.asin = function(v) 
  do return _G.math.asin(v) end;
end
Math.atan = function(v) 
  do return _G.math.atan(v) end;
end
Math.ceil = function(v) 
  do return _G.math.ceil(v) end;
end
Math.cos = function(v) 
  do return _G.math.cos(v) end;
end
Math.exp = function(v) 
  do return _G.math.exp(v) end;
end
Math.sin = function(v) 
  do return _G.math.sin(v) end;
end
Math.sqrt = function(v) 
  do return _G.math.sqrt(v) end;
end
Math.tan = function(v) 
  do return _G.math.tan(v) end;
end
Math.floor = function(v) 
  do return _G.math.floor(v) end;
end
Math.log = function(v) 
  do return _G.math.log(v) end;
end
Math.random = function() 
  do return _G.math.random() end;
end
Math.atan2 = function(y,x) 
  do return _G.math.atan2(y, x) end;
end
Math.max = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.max(a, b) end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end
Math.pow = function(v,exp) 
  do return _G.math.pow(v, exp) end;
end
Math.round = function(v) 
  do return _G.math.floor(v + 0.5) end;
end
Math.ffloor = function(v) 
  do return _G.math.floor(v) end;
end
Math.fceil = function(v) 
  do return _G.math.ceil(v) end;
end
Math.fround = function(v) 
  do return _G.math.floor(v + 0.5) end;
end

Reflect.new = {}
_hxClasses["Reflect"] = Reflect
Reflect.__name__ = "Reflect"
Reflect.hasField = function(o,field) 
  if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
    do return true end;
  else
    if (o.__fields__ ~= nil) then 
      do return o.__fields__[field] ~= nil end;
    else
      do return o[field] ~= nil end;
    end;
  end;
end
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.setField = function(o,field,value) 
  o[field] = value;
end
Reflect.getProperty = function(o,field) 
  if (o == nil) then 
    do return nil end;
  else
    if ((o.__properties__ ~= nil) and (Reflect.field(o, Std.string("get_") .. Std.string(field)) ~= nil)) then 
      do return Reflect.callMethod(o,Reflect.field(o, Std.string("get_") .. Std.string(field)),_hx_tab_array({}, 0)) end;
    else
      do return Reflect.field(o, field) end;
    end;
  end;
end
Reflect.setProperty = function(o,field,value) 
  if ((o.__properties__ ~= nil) and o.__properties__[Std.string("set_") .. Std.string(field)]) then 
    local tmp = o.__properties__[Std.string("set_") .. Std.string(field)];
    Reflect.callMethod(o,Reflect.field(o, tmp),_hx_tab_array({[0]=value}, 1));
  else
    o[field] = value;
  end;
end
Reflect.callMethod = function(o,func,args) 
  if ((args == nil) or (args.length == 0)) then 
    do return func(o) end;
  else
    local self_arg = false;
    if ((o ~= nil) and (o.__name__ == nil)) then 
      self_arg = true;
    end;
    if (self_arg) then 
      do return func(o, _hx_table.unpack(args, 0, args.length - 1)) end;
    else
      do return func(_hx_table.unpack(args, 0, args.length - 1)) end;
    end;
  end;
end
Reflect.fields = function(o) 
  if (_G.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    do return _hx_field_arr(o) end;
  end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.compareMethods = function(f1,f2) 
  do return f1 == f2 end;
end
Reflect.isObject = function(v) 
  if (v == nil) then 
    do return false end;
  end;
  local t = type(v);
  if (not ((t == "string") or ((t == "table") and (v.__enum__ == nil)))) then 
    if (t == "function") then 
      do return ((function() 
        local _hx_1
        if (_G.type(v) ~= "table") then 
        _hx_1 = false; else 
        _hx_1 = v.__name__; end
        return _hx_1
      end )() or (function() 
        local _hx_2
        if (_G.type(v) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = v.__ename__; end
        return _hx_2
      end )()) ~= nil end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and __lua_Boot.__instanceof(v, _G.table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end
Reflect.deleteField = function(o,field) 
  if (not ((function() 
    local _hx_1
    if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
    _hx_1 = true; elseif (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__[field] ~= nil; else 
    _hx_1 = o[field] ~= nil; end
    return _hx_1
  end )())) then 
    do return false end;
  end;
  o[field] = nil;
  o.__fields__[field] = nil;
  do return true end;
end
Reflect.copy = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o2 = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(o);
  while (_g < _g1.length) do 
    local f = _g1[_g];
    _g = _g + 1;
    o2[f] = Reflect.field(o, f);
  end;
  do return o2 end;
end
Reflect.makeVarArgs = function(f) 
  do return function(...)
			local a = {...}
			local b = {}
			local l = 0
			for k, v in pairs(a) do
				b[k-1] = v
				l = math.max(k,l)
			end
			return f(_hx_tab_array(b, l))
		end end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
_hxClasses["String"] = String
String.__name__ = "String"
String.__oldindex = nil
String.__index = function(s,k) 
  if (k == "length") then 
    do return __lua_lib_luautf8_Utf8.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = __lua_lib_luautf8_Utf8.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return __lua_lib_luautf8_Utf8.char(code) end;
end
String.prototype = _hx_e();
String.prototype.length= nil;
String.prototype.toUpperCase = function(self) 
  do return __lua_lib_luautf8_Utf8.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return __lua_lib_luautf8_Utf8.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local p;
    if (str == "") then 
      p = String.indexOfEmpty(self, startIndex1 - 1);
    else
      local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex1, true);
      p = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
    end;
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(delimiter) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(self, delimiter, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(self)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(delimiter);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(self, idx, __lua_lib_luautf8_Utf8.len(self)));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return __lua_lib_luautf8_Utf8.sub(self, endIndex + 1, startIndex) end;
  else
    do return __lua_lib_luautf8_Utf8.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(self)))) then 
    len = __lua_lib_luautf8_Utf8.len(self);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(self) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(self) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return __lua_lib_luautf8_Utf8.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
_hxClasses["Std"] = Std
Std.__name__ = "Std"
Std.is = function(v,t) 
  do return __lua_Boot.__instanceof(v, t) end;
end
Std.isOfType = function(v,t) 
  do return __lua_Boot.__instanceof(v, t) end;
end
Std.downcast = function(value,c) 
  if (__lua_Boot.__instanceof(value, c)) then 
    do return value end;
  else
    do return nil end;
  end;
end
Std.instance = function(value,c) 
  if (__lua_Boot.__instanceof(value, c)) then 
    do return value end;
  else
    do return nil end;
  end;
end
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x, "^[ \t\r\n]*([%-+]*0[xX][%da-fA-F]*)");
  if (hexMatch ~= nil) then 
    local sign;
    local _g = __lua_lib_luautf8_Utf8.byte(hexMatch, 1);
    if (_g) == 43 then 
      sign = 1;
    elseif (_g) == 45 then 
      sign = -1;else
    sign = 0; end;
    local pos = (function() 
      local _hx_1
      if (sign == 0) then 
      _hx_1 = 2; else 
      _hx_1 = 3; end
      return _hx_1
    end )();
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(hexMatch)))) then 
      len = __lua_lib_luautf8_Utf8.len(hexMatch);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(hexMatch) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(hexMatch) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return (function() 
      local _hx_2
      if (sign == -1) then 
      _hx_2 = -1; else 
      _hx_2 = 1; end
      return _hx_2
    end )() * _G.tonumber(__lua_lib_luautf8_Utf8.sub(hexMatch, pos + 1, pos + len), 16) end;
  else
    local intMatch = _G.string.match(x, "^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x, "^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  local pos = __lua_lib_luautf8_Utf8.len(digitMatch);
  local len = nil;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(x)))) then 
    len = __lua_lib_luautf8_Utf8.len(x);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(x) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(x) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = __lua_lib_luautf8_Utf8.sub(x, pos + 1, pos + len);
  local decimalMatch = _G.string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  local pos = __lua_lib_luautf8_Utf8.len(decimalMatch);
  local len = nil;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(x)))) then 
    len = __lua_lib_luautf8_Utf8.len(x);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(x) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(x) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = __lua_lib_luautf8_Utf8.sub(x, pos + 1, pos + len);
  local eMatch = _G.string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = ({});
  self.length = 0;
end
_hxClasses["StringBuf"] = StringBuf
StringBuf.__name__ = "StringBuf"
StringBuf.prototype = _hx_e();
StringBuf.prototype.b= nil;
StringBuf.prototype.length= nil;
StringBuf.prototype.get_length = function(self) 
  do return self.length end
end
StringBuf.prototype.add = function(self,x) 
  local str = Std.string(x);
  _G.table.insert(self.b, str);
  local tmp = self;
  tmp.length = tmp.length + __lua_lib_luautf8_Utf8.len(str);
end
StringBuf.prototype.addChar = function(self,c) 
  _G.table.insert(self.b, __lua_lib_luautf8_Utf8.char(c));
  local tmp = self;
  tmp.length = tmp.length + 1;
end
StringBuf.prototype.addSub = function(self,s,pos,len) 
  local part;
  if (len == nil) then 
    local pos = pos;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    part = __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len);
  else
    local pos = pos;
    local len = len;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    part = __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len);
  end;
  _G.table.insert(self.b, part);
  local tmp = self;
  tmp.length = tmp.length + __lua_lib_luautf8_Utf8.len(part);
end
StringBuf.prototype.toString = function(self) 
  do return _G.table.concat(self.b) end
end

StringBuf.prototype.__class__ =  StringBuf

StringBuf.prototype.__properties__ =  {get_length="get_length"}

__haxe_SysTools.new = {}
_hxClasses["haxe.SysTools"] = __haxe_SysTools
__haxe_SysTools.__name__ = "haxe.SysTools"
__haxe_SysTools.quoteUnixArg = function(argument) 
  if (argument == "") then 
    do return "''" end;
  end;
  if (not EReg.new("[^a-zA-Z0-9_@%+=:,./-]", ""):match(argument)) then 
    do return argument end;
  end;
  do return Std.string(Std.string("'") .. Std.string(StringTools.replace(argument, "'", "'\"'\"'"))) .. Std.string("'") end;
end
__haxe_SysTools.quoteWinArg = function(argument,escapeMetaCharacters) 
  if (not EReg.new("^[^ \t\\\\\"]+$", ""):match(argument)) then 
    local result_b = ({});
    local result_length = 0;
    local needquote;
    local startIndex = nil;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(argument, " ", startIndex, true);
    if ((function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )() == -1) then 
      local startIndex = nil;
      if (startIndex == nil) then 
        startIndex = 1;
      else
        startIndex = startIndex + 1;
      end;
      local r = __lua_lib_luautf8_Utf8.find(argument, "\t", startIndex, true);
      needquote = (function() 
        local _hx_2
        if ((r ~= nil) and (r > 0)) then 
        _hx_2 = r - 1; else 
        _hx_2 = -1; end
        return _hx_2
      end )() ~= -1;
    else
      needquote = true;
    end;
    local needquote = needquote or (argument == "");
    if (needquote) then 
      local str = "\"";
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local bs_buf = StringBuf.new();
    local _g = 0;
    local _g1 = __lua_lib_luautf8_Utf8.len(argument);
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local _g = __lua_lib_luautf8_Utf8.byte(argument, i + 1);
      local _g1 = _g;
      if (_g1) == 34 then 
        local bs = _G.table.concat(bs_buf.b);
        local str = Std.string(bs);
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
        local str = Std.string(bs);
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
        bs_buf = StringBuf.new();
        local str = "\\\"";
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
      elseif (_g1) == 92 then 
        local str = "\\";
        _G.table.insert(bs_buf.b, str);
        local bs_buf = bs_buf;
        bs_buf.length = bs_buf.length + __lua_lib_luautf8_Utf8.len(str);else
      local c = _g;
      if (bs_buf.length > 0) then 
        local str = Std.string(_G.table.concat(bs_buf.b));
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
        bs_buf = StringBuf.new();
      end;
      _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(c));
      result_length = result_length + 1; end;
    end;
    local str = Std.string(_G.table.concat(bs_buf.b));
    _G.table.insert(result_b, str);
    result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    if (needquote) then 
      local str = Std.string(_G.table.concat(bs_buf.b));
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
      local str = "\"";
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    argument = _G.table.concat(result_b);
  end;
  if (escapeMetaCharacters) then 
    local result_b = ({});
    local result_length = 0;
    local _g = 0;
    local _g1 = __lua_lib_luautf8_Utf8.len(argument);
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local c = __lua_lib_luautf8_Utf8.byte(argument, i + 1);
      if (__haxe_SysTools.winMetaCharacters:indexOf(c) >= 0) then 
        _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(94));
        result_length = result_length + 1;
      end;
      _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(c));
      result_length = result_length + 1;
    end;
    do return _G.table.concat(result_b) end;
  else
    do return argument end;
  end;
end

StringTools.new = {}
_hxClasses["StringTools"] = StringTools
StringTools.__name__ = "StringTools"
StringTools.urlEncode = function(s) 
  s = _G.string.gsub(s, "\n", "\r\n");
  s = _G.string.gsub(s, "([^%w %-%_%.%~])", function(c) 
    do return _G.string.format("%%%02X", Std.string(_G.string.byte(c)) .. Std.string("")) end;
  end);
  s = _G.string.gsub(s, " ", "+");
  do return s end;
end
StringTools.urlDecode = function(s) 
  s = _G.string.gsub(s, "+", " ");
  s = _G.string.gsub(s, "%%(%x%x)", function(h) 
    do return _G.string.char(_G.tonumber(h, 16)) end;
  end);
  s = _G.string.gsub(s, "\r\n", "\n");
  do return s end;
end
StringTools.htmlEscape = function(s,quotes) 
  local buf_b = ({});
  local buf_length = 0;
  local _g_offset = 0;
  local _g_s = s;
  while (_g_offset < __lua_lib_luautf8_Utf8.len(_g_s)) do 
    _g_offset = _g_offset + 1;
    local code = __lua_lib_luautf8_Utf8.byte(_g_s, (_g_offset - 1) + 1);
    local code1 = code;
    if (code1) == 34 then 
      if (quotes) then 
        local str = "&quot;";
        _G.table.insert(buf_b, str);
        buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      else
        _G.table.insert(buf_b, __lua_lib_luautf8_Utf8.char(code));
        buf_length = buf_length + 1;
      end;
    elseif (code1) == 38 then 
      local str = "&amp;";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    elseif (code1) == 39 then 
      if (quotes) then 
        local str = "&#039;";
        _G.table.insert(buf_b, str);
        buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      else
        _G.table.insert(buf_b, __lua_lib_luautf8_Utf8.char(code));
        buf_length = buf_length + 1;
      end;
    elseif (code1) == 60 then 
      local str = "&lt;";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    elseif (code1) == 62 then 
      local str = "&gt;";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);else
    _G.table.insert(buf_b, __lua_lib_luautf8_Utf8.char(code));
    buf_length = buf_length + 1; end;
  end;
  do return _G.table.concat(buf_b) end;
end
StringTools.htmlUnescape = function(s) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("&gt;") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(s, "&gt;", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("&gt;");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
      idx = nil;
    end;
  end;
  local _this = ret:join(">");
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("&lt;") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, "&lt;", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("&lt;");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  local _this = ret:join("<");
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("&quot;") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, "&quot;", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("&quot;");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  local _this = ret:join("\"");
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("&#039;") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, "&#039;", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("&#039;");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  local _this = ret:join("'");
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("&amp;") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, "&amp;", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("&amp;");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  do return ret:join("&") end;
end
StringTools.contains = function(s,value) 
  local startIndex = nil;
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local tmp;
  if (value == "") then 
    tmp = String.indexOfEmpty(s, startIndex - 1);
  else
    local r = __lua_lib_luautf8_Utf8.find(s, value, startIndex, true);
    tmp = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
  end;
  do return tmp ~= -1 end;
end
StringTools.startsWith = function(s,start) 
  if (__lua_lib_luautf8_Utf8.len(s) >= __lua_lib_luautf8_Utf8.len(start)) then 
    local startIndex = 0;
    local ret = -1;
    if (startIndex == nil) then 
      startIndex = __lua_lib_luautf8_Utf8.len(s);
    end;
    while (true) do 
      local startIndex1 = ret + 1;
      if (startIndex1 == nil) then 
        startIndex1 = 1;
      else
        startIndex1 = startIndex1 + 1;
      end;
      local p;
      if (start == "") then 
        p = String.indexOfEmpty(s, startIndex1 - 1);
      else
        local r = __lua_lib_luautf8_Utf8.find(s, start, startIndex1, true);
        p = (function() 
          local _hx_1
          if ((r ~= nil) and (r > 0)) then 
          _hx_1 = r - 1; else 
          _hx_1 = -1; end
          return _hx_1
        end )();
      end;
      if (((p == -1) or (p > startIndex)) or (p == ret)) then 
        break;
      end;
      ret = p;
    end;
    do return ret == 0 end;
  else
    do return false end;
  end;
end
StringTools.endsWith = function(s,_end) 
  local elen = __lua_lib_luautf8_Utf8.len(_end);
  local slen = __lua_lib_luautf8_Utf8.len(s);
  if (slen >= elen) then 
    local startIndex = slen - elen;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local tmp;
    if (_end == "") then 
      tmp = String.indexOfEmpty(s, startIndex - 1);
    else
      local r = __lua_lib_luautf8_Utf8.find(s, _end, startIndex, true);
      tmp = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
    end;
    do return tmp == (slen - elen) end;
  else
    do return false end;
  end;
end
StringTools.isSpace = function(s,pos) 
  if (((__lua_lib_luautf8_Utf8.len(s) == 0) or (pos < 0)) or (pos >= __lua_lib_luautf8_Utf8.len(s))) then 
    do return false end;
  end;
  local c = __lua_lib_luautf8_Utf8.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = r;
    local len = l - r;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, (l - r) - 1)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = 0;
    local len = l - r;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.lpad = function(s,c,l) 
  if (__lua_lib_luautf8_Utf8.len(c) <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  l = l - __lua_lib_luautf8_Utf8.len(s);
  while (buf_length < l) do 
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(buf_b) end;
end
StringTools.rpad = function(s,c,l) 
  if (__lua_lib_luautf8_Utf8.len(c) <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  while (buf_length < l) do 
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  do return _G.table.concat(buf_b) end;
end
StringTools.replace = function(s,sub,by) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(sub) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(s, sub, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(sub);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
      idx = nil;
    end;
  end;
  do return ret:join(by) end;
end
StringTools.hex = function(n,digits) 
  local s = "";
  local hexChars = "0123456789ABCDEF";
  while (true) do 
    local index = _hx_bit.band(n,15);
    s = Std.string(__lua_lib_luautf8_Utf8.sub(hexChars, index + 1, index + 1)) .. Std.string(s);
    n = _hx_bit.rshift(n,4);
    if (not (n > 0)) then 
      break;
    end;
  end;
  if (digits ~= nil) then 
    while (__lua_lib_luautf8_Utf8.len(s) < digits) do 
      s = Std.string("0") .. Std.string(s);
    end;
  end;
  do return s end;
end
StringTools.fastCodeAt = function(s,index) 
  do return __lua_lib_luautf8_Utf8.byte(s, index + 1) end;
end
StringTools.iterator = function(s) 
  do return __haxe_iterators_StringIterator.new(s) end;
end
StringTools.keyValueIterator = function(s) 
  do return __haxe_iterators_StringKeyValueIterator.new(s) end;
end
StringTools.isEof = function(c) 
  do return c == nil end;
end
StringTools.quoteUnixArg = function(argument) 
  if (argument == "") then 
    do return "''" end;
  else
    if (not EReg.new("[^a-zA-Z0-9_@%+=:,./-]", ""):match(argument)) then 
      do return argument end;
    else
      do return Std.string(Std.string("'") .. Std.string(StringTools.replace(argument, "'", "'\"'\"'"))) .. Std.string("'") end;
    end;
  end;
end
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) 
  local argument = argument;
  if (not EReg.new("^[^ \t\\\\\"]+$", ""):match(argument)) then 
    local result_b = ({});
    local result_length = 0;
    local needquote;
    local startIndex = nil;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(argument, " ", startIndex, true);
    if ((function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )() == -1) then 
      local startIndex = nil;
      if (startIndex == nil) then 
        startIndex = 1;
      else
        startIndex = startIndex + 1;
      end;
      local r = __lua_lib_luautf8_Utf8.find(argument, "\t", startIndex, true);
      needquote = (function() 
        local _hx_2
        if ((r ~= nil) and (r > 0)) then 
        _hx_2 = r - 1; else 
        _hx_2 = -1; end
        return _hx_2
      end )() ~= -1;
    else
      needquote = true;
    end;
    local needquote = needquote or (argument == "");
    if (needquote) then 
      local str = "\"";
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local bs_buf = StringBuf.new();
    local _g = 0;
    local _g1 = __lua_lib_luautf8_Utf8.len(argument);
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local _g = __lua_lib_luautf8_Utf8.byte(argument, i + 1);
      local _g1 = _g;
      if (_g1) == 34 then 
        local bs = _G.table.concat(bs_buf.b);
        local str = Std.string(bs);
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
        local str = Std.string(bs);
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
        bs_buf = StringBuf.new();
        local str = "\\\"";
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
      elseif (_g1) == 92 then 
        local str = "\\";
        _G.table.insert(bs_buf.b, str);
        local bs_buf = bs_buf;
        bs_buf.length = bs_buf.length + __lua_lib_luautf8_Utf8.len(str);else
      local c = _g;
      if (bs_buf.length > 0) then 
        local str = Std.string(_G.table.concat(bs_buf.b));
        _G.table.insert(result_b, str);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
        bs_buf = StringBuf.new();
      end;
      _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(c));
      result_length = result_length + 1; end;
    end;
    local str = Std.string(_G.table.concat(bs_buf.b));
    _G.table.insert(result_b, str);
    result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    if (needquote) then 
      local str = Std.string(_G.table.concat(bs_buf.b));
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
      local str = "\"";
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    argument = _G.table.concat(result_b);
  end;
  if (escapeMetaCharacters) then 
    local result_b = ({});
    local result_length = 0;
    local _g = 0;
    local _g1 = __lua_lib_luautf8_Utf8.len(argument);
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local c = __lua_lib_luautf8_Utf8.byte(argument, i + 1);
      if (__haxe_SysTools.winMetaCharacters:indexOf(c) >= 0) then 
        _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(94));
        result_length = result_length + 1;
      end;
      _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(c));
      result_length = result_length + 1;
    end;
    do return _G.table.concat(result_b) end;
  else
    do return argument end;
  end;
end

Sys.new = {}
_hxClasses["Sys"] = Sys
Sys.__name__ = "Sys"
Sys._system_name = nil
Sys.print = function(v) 
  _G.io.write(Std.string(v));
  _G.io.flush();
end
Sys.println = function(v) 
  _G.print(Std.string(v));
end
Sys.args = function() 
  local targs = __lua_PairTools.copy(_G.arg);
  local length = nil;
  local tab = __lua_PairTools.copy(targs);
  local length = length;
  local args;
  if (length == nil) then 
    length = _hx_table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      _G.table.remove(tab, 1);
      tab[0] = head;
      args = _hx_tab_array(tab, length);
    else
      args = _hx_tab_array({}, 0);
    end;
  else
    args = _hx_tab_array(tab, length);
  end;
  do return args end;
end
Sys.command = function(cmd,args) 
  local p = __sys_io_Process.new(cmd, args);
  local code = p:exitCode();
  p:close();
  do return code end;
end
Sys.cpuTime = function() 
  do return _G.os.clock() end;
end
Sys.exit = function(code) 
  _G.os.exit(code);
end
Sys.getChar = function(echo) 
  do return __lua_lib_luautf8_Utf8.byte(_G.io.read(), 1) end;
end
Sys.getSystemName = function() 
  do return __lua_Boot.systemName() end;
end
Sys.systemName = function() 
  if (Sys._system_name == nil) then 
    Sys._system_name = Sys.getSystemName();
  end;
  do return Sys._system_name end;
end
Sys.environment = function() 
  local env = __lua_lib_luv_Os.os_environ();
  local obj = __haxe_ds_ObjectMap.new();
  __lua_PairTools.pairsFold(env, function(k,v,m) 
    obj.h[k] = v;
    obj.k[k] = true;
    do return obj end;
  end, obj);
  do return obj end;
end
Sys.executablePath = function() 
  do return __lua_lib_luv_Misc.exepath() end;
end
Sys.programPath = function() 
  do return __haxe_io_Path.join(_hx_tab_array({[0]=__lua_lib_luv_Misc.cwd(), _G.arg[0]}, 2)) end;
end
Sys.getCwd = function() 
  do return __lua_lib_luv_Misc.cwd() end;
end
Sys.setCwd = function(s) 
  __lua_lib_luv_Misc.chdir(s);
end
Sys.getEnv = function(s) 
  do return __lua_lib_luv_Os.os_getenv(s) end;
end
Sys.putEnv = function(s,v) 
  __lua_lib_luv_Os.os_setenv(s, v);
end
Sys.setTimeLocale = function(loc) 
  do return _G.os.setlocale(loc) ~= nil end;
end
Sys.sleep = function(seconds) 
  __lua_lib_luv_Thread.sleep(_G.math.floor(seconds * 1000));
end
Sys.stderr = function() 
  do return __sys_io_FileOutput.new(_G.io.stderr) end;
end
Sys.stdin = function() 
  do return __sys_io_FileInput.new(_G.io.stdin) end;
end
Sys.stdout = function() 
  do return __sys_io_FileOutput.new(_G.io.stdout) end;
end
Sys.time = function() 
  local _hx_1_stamp_seconds, _hx_1_stamp_microseconds = __lua_lib_luv_Misc.gettimeofday();
  do return _hx_1_stamp_seconds + (_hx_1_stamp_microseconds / 100000) end;
end

TimingTests.new = function(theory) 
  local self = _hx_new(TimingTests.prototype)
  TimingTests.super(self,theory)
  return self
end
TimingTests.super = function(self,theory) 
  self.db = __blub_prolog_Database.new();
  self.db:loadString(theory, true);
end
_hx_exports["TimingTests"] = TimingTests
_hxClasses["TimingTests"] = TimingTests
TimingTests.__name__ = "TimingTests"
TimingTests.log = function(v) 
  __haxe_Log.trace(v, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=32,className="TimingTests",methodName="log"}));
end
TimingTests.clear = function() 
end
TimingTests.stressTestQueens = function(count) 
  __haxe_Log.trace(Std.string(Std.string("Running 8 Queens * ") .. Std.string(count)) .. Std.string(" ..."), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=47,className="TimingTests",methodName="stressTestQueens"}));
  local run = function() 
    local solutions = TimingTests.stressTest(TimingTests.queens_theory, "run_queens", count);
    if (count == 1) then 
      __haxe_Log.trace(Std.string("solution count = ") .. Std.string(solutions.length), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=52,className="TimingTests",methodName="stressTestQueens"}));
      local _g = 0;
      while (_g < solutions.length) do 
        local solution = solutions[_g];
        _g = _g + 1;
        __haxe_Log.trace(solution:toString(), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=54,className="TimingTests",methodName="stressTestQueens"}));
      end;
    end;
  end;
  run();
end
TimingTests.stressTestZebra = function(count) 
  __haxe_Log.trace(Std.string(Std.string("Running Zebra * ") .. Std.string(count)) .. Std.string(" ..."), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=67,className="TimingTests",methodName="stressTestZebra"}));
  TimingTests.stressTest(TimingTests.zebra_theory, "zebra", count);
end
TimingTests.stressTest = function(theory,predName,count) 
  local test = TimingTests.new(theory);
  local time = 0.0;
  local solutions = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = count;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local timestamp = Sys.time();
    solutions = test:run(predName);
    time = time + (Sys.time() - timestamp);
  end;
  __haxe_Log.trace(Std.string("Average time = ") .. Std.string(time / count), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=83,className="TimingTests",methodName="stressTest"}));
  do return solutions end;
end
TimingTests.main = function() 
  __haxe_Timer.delay(function() 
    __haxe_Log.trace("Starting....", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=116,className="TimingTests",methodName="main"}));
    local zebra = TimingTests.new(TimingTests.zebra_theory);
    local timestamp = Sys.time();
    local solutions = zebra:run("zebra");
    __haxe_Log.trace(Std.string(Std.string("Zebra in ") .. Std.string((Sys.time() - timestamp))) .. Std.string(" seconds"), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=120,className="TimingTests",methodName="main"}));
    __haxe_Log.trace(Std.string("solution count = ") .. Std.string(solutions.length), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=121,className="TimingTests",methodName="main"}));
    local _g = 0;
    while (_g < solutions.length) do 
      local solution = solutions[_g];
      _g = _g + 1;
      __haxe_Log.trace(solution:toString(), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=123,className="TimingTests",methodName="main"}));
    end;
    local queens = TimingTests.new(TimingTests.queens_theory);
    timestamp = Sys.time();
    local solutions = queens:run("run_queens");
    __haxe_Log.trace(Std.string(Std.string("8 queens in ") .. Std.string((Sys.time() - timestamp))) .. Std.string(" seconds"), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=130,className="TimingTests",methodName="main"}));
    __haxe_Log.trace(Std.string("solution count = ") .. Std.string(solutions.length), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=131,className="TimingTests",methodName="main"}));
    local _g = 0;
    while (_g < solutions.length) do 
      local solution = solutions[_g];
      _g = _g + 1;
      __haxe_Log.trace(solution:toString(), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/TimingTests.hx",lineNumber=136,className="TimingTests",methodName="main"}));
    end;
  end, 500);
end
TimingTests.prototype = _hx_e();
TimingTests.prototype.db= nil;
TimingTests.prototype.query= nil;
TimingTests.prototype.run = function(self,predName) 
  local qterm = __blub_prolog_terms_Structure.new(self.db.context:getAtom(predName), _hx_tab_array({[0]=__blub_prolog_terms_Variable.new("Result")}, 1));
  self.query = __blub_prolog_Query.new(self.db, qterm);
  local solutions = _hx_tab_array({}, 0);
  local result = self.query;
  while (result:hasNext()) do 
    local result = result:next();
    if (__blub_prolog_ResultUtil.isSuccess(result)) then 
      local ret = __blub_prolog_ResultUtil.getBindings(result).h.Result;
      if (ret == __haxe_ds_StringMap.tnull) then 
        ret = nil;
      end;
      solutions:push(ret);
    end;
  end;
  do return solutions end
end

TimingTests.prototype.__class__ =  TimingTests
_hxClasses["ValueType"] = ValueType;
_hxClasses["ValueType"] = { __ename__ = "ValueType", __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)

ValueType.__empty_constructs__ = _hx_tab_array({[0] = ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown}, 7)

Type.new = {}
_hxClasses["Type"] = Type
Type.__name__ = "Type"
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o = o;
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getEnum = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  do return o.__enum__ end;
end
Type.getSuperClass = function(c) 
  do return c.__super__ end;
end
Type.getClassName = function(c) 
  do return c.__name__ end;
end
Type.getEnumName = function(e) 
  if (e.__ename__ == nil) then 
    do return nil end;
  end;
  do return e.__ename__ end;
end
Type.resolveClass = function(name) 
  local cl = _hxClasses[name];
  local tmp;
  if (cl ~= nil) then 
    local o = cl;
    tmp = not ((function() 
      local _hx_1
      if (_G.type(o) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = o.__name__; end
      return _hx_1
    end )());
  else
    tmp = true;
  end;
  if (tmp) then 
    do return nil end;
  end;
  do return cl end;
end
Type.resolveEnum = function(name) 
  local e = _hxClasses[name];
  if ((e == nil) or not ((function() 
    local _hx_1
    if (_G.type(e) ~= "table") then 
    _hx_1 = false; else 
    _hx_1 = e.__ename__; end
    return _hx_1
  end )())) then 
    do return nil end;
  end;
  do return e end;
end
Type.createInstance = function(cl,args) 
  do return cl.new(_hx_table.unpack(args, 0)) end;
end
Type.createEmptyInstance = function(cl) 
  local ret = ({});
  _G.setmetatable(ret, _hx_o({__fields__={__index=true},__index=cl.prototype}));
  do return ret end;
end
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e, constr);
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("No such constructor ") .. Std.string(constr)),0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string(Std.string("Constructor ") .. Std.string(constr)) .. Std.string(" need parameters")),0);
    end;
    do return Reflect.callMethod(nil,f,params) end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string("Constructor ") .. Std.string(constr)) .. Std.string(" does not need parameters")),0);
  end;
  do return f end;
end
Type.createEnumIndex = function(e,index,params) 
  local c = e.__constructs__[index];
  if (c == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string(index) .. Std.string(" is not a valid enum constructor index")),0);
  end;
  do return Type.createEnum(e, c, params) end;
end
Type.getInstanceFields = function(c) 
  local p = c.prototype;
  local a = _hx_tab_array({}, 0);
  while (p ~= nil) do 
    local _g = 0;
    local _g1 = Reflect.fields(p);
    while (_g < _g1.length) do 
      local f = _g1[_g];
      _g = _g + 1;
      if (not Lambda.has(a, f)) then 
        a:push(f);
      end;
    end;
    local mt = _G.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then 
      p = mt.__index;
    else
      p = nil;
    end;
  end;
  do return a end;
end
Type.getClassFields = function(c) 
  local a = Reflect.fields(c);
  a:remove("__name__");
  a:remove("__interfaces__");
  a:remove("__properties__");
  a:remove("__super__");
  a:remove("__meta__");
  a:remove("prototype");
  a:remove("new");
  do return a end;
end
Type.getEnumConstructs = function(e) 
  local a = e.__constructs__;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = a;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end
Type.enumEq = function(a,b) 
  if (a == b) then 
    do return true end;
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      if (a[0] ~= b[0]) then 
        do return false end;
      end;
      local _g = 2;
      local _g1 = a.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        if (not Type.enumEq(a[i], b[i])) then 
          do return false end;
        end;
      end;
      local e = a.__enum__;
      if ((e ~= b.__enum__) or (e == nil)) then 
        do return false end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    do return false end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return true end;
end
Type.enumConstructor = function(e) 
  do return e[0] end;
end
Type.enumParameters = function(e) 
  do return e:slice(2) end;
end
Type.enumIndex = function(e) 
  do return e[1] end;
end
Type.allEnums = function(e) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = e.__empty_constructs__;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end

__haxe_ds__Map_Map_Impl_.new = {}
_hxClasses["haxe.ds._Map.Map_Impl_"] = __haxe_ds__Map_Map_Impl_
__haxe_ds__Map_Map_Impl_.__name__ = "haxe.ds._Map.Map_Impl_"
__haxe_ds__Map_Map_Impl_.set = function(this1,key,value) 
  this1:set(key, value);
end
__haxe_ds__Map_Map_Impl_.get = function(this1,key) 
  do return this1:get(key) end;
end
__haxe_ds__Map_Map_Impl_.exists = function(this1,key) 
  do return this1:exists(key) end;
end
__haxe_ds__Map_Map_Impl_.remove = function(this1,key) 
  do return this1:remove(key) end;
end
__haxe_ds__Map_Map_Impl_.keys = function(this1) 
  do return this1:keys() end;
end
__haxe_ds__Map_Map_Impl_.iterator = function(this1) 
  do return this1:iterator() end;
end
__haxe_ds__Map_Map_Impl_.keyValueIterator = function(this1) 
  do return this1:keyValueIterator() end;
end
__haxe_ds__Map_Map_Impl_.copy = function(this1) 
  do return this1:copy() end;
end
__haxe_ds__Map_Map_Impl_.toString = function(this1) 
  do return this1:toString() end;
end
__haxe_ds__Map_Map_Impl_.clear = function(this1) 
  this1:clear();
end
__haxe_ds__Map_Map_Impl_.arrayWrite = function(this1,k,v) 
  this1:set(k, v);
  do return v end;
end
__haxe_ds__Map_Map_Impl_.toStringMap = function(t) 
  do return __haxe_ds_StringMap.new() end;
end
__haxe_ds__Map_Map_Impl_.toIntMap = function(t) 
  do return __haxe_ds_IntMap.new() end;
end
__haxe_ds__Map_Map_Impl_.toEnumValueMapMap = function(t) 
  do return __haxe_ds_EnumValueMap.new() end;
end
__haxe_ds__Map_Map_Impl_.toObjectMap = function(t) 
  do return __haxe_ds_ObjectMap.new() end;
end
__haxe_ds__Map_Map_Impl_.fromStringMap = function(map) 
  do return map end;
end
__haxe_ds__Map_Map_Impl_.fromIntMap = function(map) 
  do return map end;
end
__haxe_ds__Map_Map_Impl_.fromObjectMap = function(map) 
  do return map end;
end

__blub_prolog_AtomContext.new = function() 
  local self = _hx_new(__blub_prolog_AtomContext.prototype)
  __blub_prolog_AtomContext.super(self)
  return self
end
__blub_prolog_AtomContext.super = function(self) 
  self.atoms = __haxe_ds_StringMap.new();
end
_hxClasses["blub.prolog.AtomContext"] = __blub_prolog_AtomContext
__blub_prolog_AtomContext.__name__ = "blub.prolog.AtomContext"
__blub_prolog_AtomContext.prototype = _hx_e();
__blub_prolog_AtomContext.prototype.atoms= nil;
__blub_prolog_AtomContext.prototype.getAtom = function(self,text) 
  local atom = self:lookupAtom(text);
  if (atom == nil) then 
    atom = self:createAtom(text);
    local _this = self.atoms;
    if (atom == nil) then 
      _this.h[text] = __haxe_ds_StringMap.tnull;
    else
      _this.h[text] = atom;
    end;
  end;
  do return atom end
end
__blub_prolog_AtomContext.prototype.lookupAtom = function(self,text,checkGlobals) 
  if (checkGlobals == nil) then 
    checkGlobals = true;
  end;
  local ret = self.atoms.h[text];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local atom = ret;
  if (((atom == nil) and checkGlobals) and (self ~= __blub_prolog_AtomContext.GLOBALS)) then 
    do return __blub_prolog_AtomContext.GLOBALS:lookupAtom(text, false) end;
  end;
  do return atom end
end
__blub_prolog_AtomContext.prototype.createAtom = function(self,text) 
  do return __blub_prolog_terms_Atom.unregisteredAtom(text) end
end

__blub_prolog_AtomContext.prototype.__class__ =  __blub_prolog_AtomContext

__blub_prolog_Clause.new = function(predicate,clause) 
  local self = _hx_new(__blub_prolog_Clause.prototype)
  __blub_prolog_Clause.super(self,predicate,clause)
  return self
end
__blub_prolog_Clause.super = function(self,predicate,clause) 
  self.predicate = predicate;
  self.term = clause;
  self.listeners = __blub_prolog_Listeners.new();
  self.variableContext = (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(clause, __blub_prolog_terms_Structure)) then 
    _hx_1 = (__lua_Boot.__cast(clause , __blub_prolog_terms_Structure)):get_variableContext(); else 
    _hx_1 = __blub_prolog_terms_VariableContext.EMPTY; end
    return _hx_1
  end )();
  self.head = clause:getHead();
  self.body = clause:getBody();
end
_hxClasses["blub.prolog.Clause"] = __blub_prolog_Clause
__blub_prolog_Clause.__name__ = "blub.prolog.Clause"
__blub_prolog_Clause.prototype = _hx_e();
__blub_prolog_Clause.prototype.predicate= nil;
__blub_prolog_Clause.prototype.listeners= nil;
__blub_prolog_Clause.prototype.code= nil;
__blub_prolog_Clause.prototype.term= nil;
__blub_prolog_Clause.prototype.variableContext= nil;
__blub_prolog_Clause.prototype.head= nil;
__blub_prolog_Clause.prototype.body= nil;
__blub_prolog_Clause.prototype.possibleMatch = function(self,args) 
  local headStruct = self.head:asStructure();
  local arity = headStruct:getArity();
  local _g = 0;
  local _g1 = arity;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (not headStruct:argAt(i):couldMatch(args[i])) then 
      do return false end;
    end;
  end;
  do return true end
end
__blub_prolog_Clause.prototype.headArg = function(self,index) 
  if (__lua_Boot.__instanceof(self.head, __blub_prolog_terms_Structure)) then 
    do return (__lua_Boot.__cast(self.head , __blub_prolog_terms_Structure)):argAt(index) end;
  end;
  do return nil end
end
__blub_prolog_Clause.prototype.retract = function(self) 
  self.predicate:retractClause(self);
end
__blub_prolog_Clause.prototype.isRetracted = function(self) 
  local lis = self.listeners:iterator();
  while (lis:hasNext()) do 
    local lis = lis:next();
    lis:clauseRetracted(self);
  end;
end
__blub_prolog_Clause.prototype.compile = function(self) 
  self.code = __blub_prolog_compiler_ClauseCompiler.new(self.predicate.database):compile(self);
end
__blub_prolog_Clause.prototype.setCode = function(self,code) 
  self.code = code;
end

__blub_prolog_Clause.prototype.__class__ =  __blub_prolog_Clause

__blub_prolog_Database.new = function(context,operators) 
  local self = _hx_new(__blub_prolog_Database.prototype)
  __blub_prolog_Database.super(self,context,operators)
  return self
end
__blub_prolog_Database.super = function(self,context,operators) 
  self.context = (function() 
    local _hx_1
    if (context ~= nil) then 
    _hx_1 = context; else 
    _hx_1 = __blub_prolog_AtomContext.new(); end
    return _hx_1
  end )();
  self.predicates = __haxe_ds_StringMap.new();
  self.listeners = __blub_prolog_Listeners.new();
  if (operators == nil) then 
    operators = __blub_prolog_stopgap_parse_Operators.new();
    operators:addStandardOps();
  end;
  self.operators = operators;
  __blub_prolog_builtins_Builtins.register(self);
  self.globals = __haxe_ds_StringMap.new();
end
_hx_exports["blub"]["prolog"]["Database"] = __blub_prolog_Database
_hxClasses["blub.prolog.Database"] = __blub_prolog_Database
__blub_prolog_Database.__name__ = "blub.prolog.Database"
__blub_prolog_Database.prototype = _hx_e();
__blub_prolog_Database.prototype.operators= nil;
__blub_prolog_Database.prototype.context= nil;
__blub_prolog_Database.prototype.listeners= nil;
__blub_prolog_Database.prototype.preprocessor= nil;
__blub_prolog_Database.prototype.predicates= nil;
__blub_prolog_Database.prototype.lazyPredicates= nil;
__blub_prolog_Database.prototype.compileQueue= nil;
__blub_prolog_Database.prototype.globals= nil;
__blub_prolog_Database.prototype.setGlobal = function(self,key,value) 
  local atom = __blub_prolog_terms_Atom.unregisteredAtom(key);
  atom.object = value;
  local _this = self.globals;
  if (atom == nil) then 
    _this.h[key] = __haxe_ds_StringMap.tnull;
  else
    _this.h[key] = atom;
  end;
end
__blub_prolog_Database.prototype.getGlobal = function(self,key) 
  local ret = self.globals.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local atom = ret;
  if ((atom == nil) or (atom:asAtom() == nil)) then 
    do return nil end;
  end;
  do return atom:asAtom().object end
end
__blub_prolog_Database.prototype.addPredicate = function(self,indicator,isDynamic) 
  if (isDynamic == nil) then 
    isDynamic = false;
  end;
  local pred = __blub_prolog_Predicate.new(self, indicator, isDynamic);
  local this1 = self.predicates;
  local key = indicator:toString();
  local _this = this1;
  if (pred == nil) then 
    _this.h[key] = __haxe_ds_StringMap.tnull;
  else
    _this.h[key] = pred;
  end;
  local lis = self.listeners:iterator();
  while (lis:hasNext()) do 
    local lis = lis:next();
    lis:predicateAdded(pred);
  end;
  do return pred end
end
__blub_prolog_Database.prototype.addPredicateSrc = function(self,functor,src,filename) 
  if (filename == nil) then 
    filename = "lazy-load";
  end;
  local parser = __blub_prolog_stopgap_parse_Parser.new(self.context, self.operators, src, filename);
  local pred = nil;
  local _hx_continue_1 = false;
  while (true) do repeat 
    local t = parser:nextTerm();
    if (t == nil) then 
      _hx_continue_1 = true;break;
    end;
    if (__lua_Boot.__instanceof(t, __blub_prolog_terms_ClauseTerm)) then 
      local clause = __lua_Boot.__cast(t , __blub_prolog_terms_ClauseTerm);
      if (pred == nil) then 
        local head = clause:getHead();
        pred = self:addPredicate(head:getIndicator(), false);
      end;
      pred:appendClause(clause);
      break;
    else
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Invalid top-level clause: ") .. Std.string(Std.string(t)))),0);
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if ((self.compileQueue ~= nil) and (pred ~= nil)) then 
    self.compileQueue:add(pred);
  end;
  do return pred end
end
__blub_prolog_Database.prototype.lookup = function(self,indicator) 
  local this1 = self.predicates;
  local key = indicator:toString();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local pred = ret;
  if ((pred == nil) and (self.compileQueue ~= nil)) then 
    if (self.lazyPredicates == nil) then 
      self.lazyPredicates = __blub_prolog_builtins_lazy_LazyLoadPredicates.new(self);
    end;
    if (self.lazyPredicates:load(indicator)) then 
      local this1 = self.predicates;
      local key = indicator:toString();
      local ret = this1.h[key];
      if (ret == __haxe_ds_StringMap.tnull) then 
        ret = nil;
      end;
      pred = ret;
    end;
  end;
  do return pred end
end
__blub_prolog_Database.prototype.compile = function(self) 
  self.compileQueue = __haxe_ds_List.new();
  local pred = self.predicates:iterator();
  while (pred:hasNext()) do 
    local pred = pred:next();
    self.compileQueue:add(pred);
  end;
  while (not self.compileQueue:isEmpty()) do 
    local pred = self.compileQueue:pop();
    pred:compile();
  end;
  self.compileQueue = nil;
end
__blub_prolog_Database.prototype.assertA = function(self,term,isQuery) 
  if (isQuery == nil) then 
    isQuery = false;
  end;
  self:assert(term, true, isQuery);
end
__blub_prolog_Database.prototype.assertZ = function(self,term,isQuery) 
  if (isQuery == nil) then 
    isQuery = false;
  end;
  self:assert(term, false, isQuery);
end
__blub_prolog_Database.prototype.assert = function(self,clause,atFront,isQuery) 
  local head = clause:getHead();
  local indic = head:getIndicator();
  local pred = self:lookup(indic);
  if (pred == nil) then 
    pred = self:addPredicate(indic, isQuery);
  else
    if (isQuery and not pred.isDynamic) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Cannot assert clauses to a non-dynamic predicate: ") .. Std.string(Std.string(indic)))),0);
    end;
  end;
  local c = (function() 
    local _hx_1
    if (atFront) then 
    _hx_1 = pred:prependClause(clause); else 
    _hx_1 = pred:appendClause(clause); end
    return _hx_1
  end )();
  if (isQuery) then 
    c:compile();
  end;
end
__blub_prolog_Database.prototype.abolish = function(self,indicator) 
  local this1 = self.predicates;
  local key = indicator:toString();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local pred = ret;
  if (pred ~= nil) then 
    self.predicates:remove(indicator:toString());
    pred:isAbolished();
    local lis = self.listeners:iterator();
    while (lis:hasNext()) do 
      local lis = lis:next();
      lis:predicateAbolished(pred);
    end;
  end;
end
__blub_prolog_Database.prototype.loadString = function(self,source,compileAll,filename,preprocessor) 
  if (filename == nil) then 
    filename = "<unknown>";
  end;
  if (compileAll == nil) then 
    compileAll = true;
  end;
  local parser = __blub_prolog_stopgap_parse_Parser.new(self.context, self.operators, source, filename);
  if (preprocessor == nil) then 
    preprocessor = self.preprocessor;
  end;
  if (preprocessor == nil) then 
    self.preprocessor = __blub_prolog_Preprocessor.getAStandardPreprocessor();
    preprocessor = self.preprocessor;
  end;
  local _hx_continue_1 = false;
  while (true) do repeat 
    local t = parser:nextTerm();
    if (t == nil) then 
      _hx_continue_1 = true;break;
    end;
    local stru = t:asStructure();
    if ((((stru ~= nil) and (stru:getNameText() == ":-")) and (stru:getArity() == 1)) and (stru:argAt(0):asStructure() ~= nil)) then 
      local directive = stru:argAt(0):asStructure();
      if ((directive:getNameText() == "op") and (directive:getArity() == 3)) then 
        self:processDirective(stru:argAt(0):asStructure());
        break;
      end;
    end;
    local terms = preprocessor:process(self, t);
    local _g = 0;
    while (_g < terms.length) do 
      local t = terms[_g];
      _g = _g + 1;
      self:loadTerm(t);
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (compileAll) then 
    self:compile();
  end;
end
__blub_prolog_Database.prototype.loadTerm = function(self,t) 
  local stru = t:asStructure();
  if ((((stru ~= nil) and (stru:getNameText() == ":-")) and (stru:getArity() == 1)) and (stru:argAt(0):asStructure() ~= nil)) then 
    self:processDirective(stru:argAt(0):asStructure());
    do return end;
  end;
  if (__lua_Boot.__instanceof(t, __blub_prolog_terms_ClauseTerm)) then 
    local ct = t;
    self:assertZ(ct);
    do return end;
  end;
  _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Invalid top-level clause: ") .. Std.string(Std.string(t)))),0);
end
__blub_prolog_Database.prototype.declareDynamic = function(self,indicator) 
  local pred = self:lookup(indicator);
  if (pred == nil) then 
    pred = self:addPredicate(indicator, true);
  else
    _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("cannot declare existing predicate to be dynamic: ") .. Std.string(Std.string(indicator)))),0);
  end;
end
__blub_prolog_Database.prototype.processDirective = function(self,directive) 
  local text = directive:getNameText();
  if (text == "op") then 
    local op = directive;
    if (op:getArity() ~= 3) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("op/3 directive requires 3 args: ") .. Std.string(Std.string(op)))),0);
    end;
    local priority = __lua_Boot.__cast(op:argAt(0) , __blub_prolog_terms_NumberTerm);
    if (priority == nil) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("op/3 directive requires numeric priority as first arg: ") .. Std.string(Std.string(op)))),0);
    end;
    if ((priority.value < 0) or (priority.value > 1200)) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("op/3 directive requires numeric priority from 0 to 1200: ") .. Std.string(Std.string(op)))),0);
    end;
    if (Std.int(priority.value) ~= priority.value) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("op/3 directive requires integer priority: ") .. Std.string(Std.string(op)))),0);
    end;
    if (not __lua_Boot.__instanceof(op:argAt(1), __blub_prolog_terms_Atom)) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("op/3 directive requires spec as 2nd arg: ") .. Std.string(Std.string(op)))),0);
    end;
    if (not __lua_Boot.__instanceof(op:argAt(2), __blub_prolog_terms_Atom)) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("op/3 directive requires operator as 3rd arg: ") .. Std.string(Std.string(op)))),0);
    end;
    self.operators:newOp((__lua_Boot.__cast(op:argAt(2) , __blub_prolog_terms_Atom)).text, __blub_prolog_stopgap_parse_Operator.opSpec((__lua_Boot.__cast(op:argAt(1) , __blub_prolog_terms_Atom)).text), Std.int(priority.value), self.context);
    do return end;
  else
    if (text == "dynamic") then 
      local preds = directive:argAt(0):asStructure();
      if (preds == nil) then 
        _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("dynamic/1 directive requires one or more predicate specs: ") .. Std.string(Std.string(directive)))),0);
      end;
      local specs = preds:commaList();
      local _g = 0;
      while (_g < specs.length) do 
        local spec = specs[_g];
        _g = _g + 1;
        local indic = __blub_prolog_PredicateIndicator.fromTerm(spec);
        self:declareDynamic(indic);
      end;
    end;
  end;
end
__blub_prolog_Database.prototype.listing = function(self,logger) 
  local pred = self.predicates:iterator();
  while (pred:hasNext()) do 
    local pred = pred:next();
    if (not pred.isBuiltin) then 
      pred:listing(logger);
    end;
  end;
end
__blub_prolog_Database.prototype.query = function(self,term) 
  local t = __blub_prolog_terms_TermParse.parse(term, self.context, self.operators);
  if (not __lua_Boot.__instanceof(t, __blub_prolog_terms_ClauseTerm)) then 
    _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Query is not a valid atom or structure: ") .. Std.string(term))),0);
  end;
  do return __blub_prolog_Query.new(self, __lua_Boot.__cast(t , __blub_prolog_terms_ClauseTerm)) end
end

__blub_prolog_Database.prototype.__class__ =  __blub_prolog_Database

__blub_prolog_Listeners.new = function() 
  local self = _hx_new(__blub_prolog_Listeners.prototype)
  __blub_prolog_Listeners.super(self)
  return self
end
__blub_prolog_Listeners.super = function(self) 
  self.listeners = Array.new();
end
_hxClasses["blub.prolog.Listeners"] = __blub_prolog_Listeners
__blub_prolog_Listeners.__name__ = "blub.prolog.Listeners"
__blub_prolog_Listeners.prototype = _hx_e();
__blub_prolog_Listeners.prototype.listeners= nil;
__blub_prolog_Listeners.prototype.add = function(self,listener) 
  self.listeners:push(listener);
end
__blub_prolog_Listeners.prototype.remove = function(self,listener) 
  self.listeners:remove(listener);
end
__blub_prolog_Listeners.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self.listeners) end
end

__blub_prolog_Listeners.prototype.__class__ =  __blub_prolog_Listeners

__blub_prolog_PredicateListener.new = {}
_hxClasses["blub.prolog.PredicateListener"] = __blub_prolog_PredicateListener
__blub_prolog_PredicateListener.__name__ = "blub.prolog.PredicateListener"
__blub_prolog_PredicateListener.prototype = _hx_e();
__blub_prolog_PredicateListener.prototype.predicateAdded= nil;
__blub_prolog_PredicateListener.prototype.predicateAbolished= nil;

__blub_prolog_PredicateListener.prototype.__class__ =  __blub_prolog_PredicateListener

__blub_prolog_AssertionListener.new = {}
_hxClasses["blub.prolog.AssertionListener"] = __blub_prolog_AssertionListener
__blub_prolog_AssertionListener.__name__ = "blub.prolog.AssertionListener"
__blub_prolog_AssertionListener.prototype = _hx_e();
__blub_prolog_AssertionListener.prototype.clauseAsserted= nil;

__blub_prolog_AssertionListener.prototype.__class__ =  __blub_prolog_AssertionListener

__blub_prolog_RetractionListener.new = {}
_hxClasses["blub.prolog.RetractionListener"] = __blub_prolog_RetractionListener
__blub_prolog_RetractionListener.__name__ = "blub.prolog.RetractionListener"
__blub_prolog_RetractionListener.prototype = _hx_e();
__blub_prolog_RetractionListener.prototype.clauseRetracted= nil;

__blub_prolog_RetractionListener.prototype.__class__ =  __blub_prolog_RetractionListener

__blub_prolog_Marshal.new = {}
_hxClasses["blub.prolog.Marshal"] = __blub_prolog_Marshal
__blub_prolog_Marshal.__name__ = "blub.prolog.Marshal"
__blub_prolog_Marshal.newAtom = function() 
  local tmp = Std.string("object#") .. Std.string((function() 
  local _hx_obj = __blub_prolog_Marshal;
  local _hx_fld = 'object_atom_id';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)());
  do return __blub_prolog_terms_Atom.unregisteredAtom(tmp) end;
end
__blub_prolog_Marshal.valueToTerm = function(value) 
  if (value == nil) then 
    do return __blub_prolog_AtomContext.GLOBALS:getAtom("null") end;
  end;
  if (__lua_Boot.__instanceof(value, __blub_prolog_terms_Term)) then 
    local t = __lua_Boot.__cast(value , __blub_prolog_terms_Term);
    local vt = t:asValueTerm();
    if (vt ~= nil) then 
      do return vt:dereference() end;
    end;
  end;
  if (__lua_Boot.__instanceof(value, Bool)) then 
    local b = value;
    if (b) then 
      do return __blub_prolog_AtomContext.GLOBALS:getAtom("true") end;
    else
      do return __blub_prolog_AtomContext.GLOBALS:getAtom("false") end;
    end;
  end;
  if (__lua_Boot.__instanceof(value, Float)) then 
    do return __blub_prolog_terms_NumberTerm.new(value) end;
  end;
  if (__lua_Boot.__instanceof(value, Array)) then 
    local array = value;
    local terms = Array.new();
    local _g = 0;
    while (_g < array.length) do 
      local el = array[_g];
      _g = _g + 1;
      terms:push(__blub_prolog_Marshal.valueToTerm(el));
    end;
    do return __blub_prolog_terms_Structure.makeList(terms) end;
  end;
  if (__lua_Boot.__instanceof(value, __haxe_ds_StringMap)) then 
    local hashAtom = __blub_prolog_Marshal.newAtom();
    local hash = value;
    hashAtom.object = __blub_prolog_builtins_objects_HashObjectWrapper.new(hashAtom, hash);
    do return hashAtom end;
  end;
  local atom = (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(value, String)) then 
    _hx_1 = __blub_prolog_terms_Atom.unregisteredAtom(value); else 
    _hx_1 = __blub_prolog_Marshal.newAtom(); end
    return _hx_1
  end )();
  atom.object = nil;
  do return atom end;
end
__blub_prolog_Marshal.termToValue = function(term) 
  if (term == nil) then 
    do return nil end;
  end;
  local atom = term:asAtom();
  if (atom ~= nil) then 
    if (atom.object ~= nil) then 
      local object = atom.object;
      if (__lua_Boot.__instanceof(object, __blub_prolog_builtins_objects_ObjectWrapper)) then 
        local wrapper = object;
        do return wrapper:getObject() end;
      end;
      do return object end;
    end;
    local _g = atom.text;
    if (_g) == "false" then 
      do return false end;
    elseif (_g) == "null" then 
      do return nil end;
    elseif (_g) == "true" then 
      do return true end;else
    do return atom.text end; end;
  end;
  local num = term:asNumber();
  if (num ~= nil) then 
    do return num.value end;
  end;
  local struc = term:asStructure();
  if (struc ~= nil) then 
    if ((struc:getArity() == 1) and (struc:getNameText() == "term")) then 
      do return struc:argAt(0) end;
    end;
    local array = struc:toArray();
    if (array == nil) then 
      do return struc:toString() end;
    end;
    local resultArray = Array.new();
    local _g = 0;
    while (_g < array.length) do 
      local t = array[_g];
      _g = _g + 1;
      resultArray:push(__blub_prolog_Marshal.termToValue(t:asValueTerm()));
    end;
    do return resultArray end;
  end;
  term = term:dereference();
  if (term:asReference() ~= nil) then 
    do return nil end;
  end;
  do return __blub_prolog_Marshal.termToValue(term) end;
end

__blub_prolog_PredicateIndicator.new = function(name,arity) 
  local self = _hx_new(__blub_prolog_PredicateIndicator.prototype)
  __blub_prolog_PredicateIndicator.super(self,name,arity)
  return self
end
__blub_prolog_PredicateIndicator.super = function(self,name,arity) 
  self.name = name;
  self.arity = arity;
end
_hxClasses["blub.prolog.PredicateIndicator"] = __blub_prolog_PredicateIndicator
__blub_prolog_PredicateIndicator.__name__ = "blub.prolog.PredicateIndicator"
__blub_prolog_PredicateIndicator.fromString = function(text,context) 
  local startIndex = nil;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(text);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(text, "/", startIndex1, true);
    local p = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  local slash = ret;
  local atom = text;
  local arity = 0;
  if (slash >= 0) then 
    local pos = 0;
    local len = slash;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(text)))) then 
      len = __lua_lib_luautf8_Utf8.len(text);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(text) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(text) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    atom = __lua_lib_luautf8_Utf8.sub(text, pos + 1, pos + len);
    local pos = slash + 1;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(text)))) then 
      len = __lua_lib_luautf8_Utf8.len(text);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(text) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(text) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    arity = Std.parseInt(__lua_lib_luautf8_Utf8.sub(text, pos + 1, pos + len));
  end;
  do return __blub_prolog_PredicateIndicator.new(((function() 
    local _hx_2
    if (context ~= nil) then 
    _hx_2 = context; else 
    _hx_2 = __blub_prolog_AtomContext.GLOBALS; end
    return _hx_2
  end )()):getAtom(atom), arity) end;
end
__blub_prolog_PredicateIndicator.fromTerm = function(term,clauseContext) 
  local structure = term:asStructure();
  if (((((structure == nil) or (structure:getArity() ~= 2)) or not structure:getName():equals(__blub_prolog_PredicateIndicator.SLASH)) or (structure:argAt(0):asAtom() == nil)) or (structure:argAt(1):asNumber() == nil)) then 
    _G.error(__haxe_Exception.thrown(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_predicate_indicator, term, clauseContext)),0);
  end;
  do return __blub_prolog_PredicateIndicator.new(structure:argAt(0):asAtom(), Std.int(structure:argAt(1):asNumber().value)) end;
end
__blub_prolog_PredicateIndicator.prototype = _hx_e();
__blub_prolog_PredicateIndicator.prototype.name= nil;
__blub_prolog_PredicateIndicator.prototype.arity= nil;
__blub_prolog_PredicateIndicator.prototype.term= nil;
__blub_prolog_PredicateIndicator.prototype._string= nil;
__blub_prolog_PredicateIndicator.prototype.toString = function(self) 
  if (self._string == nil) then 
    self._string = Std.string(Std.string(self.name.text) .. Std.string("/")) .. Std.string(self.arity);
  end;
  do return self._string end
end
__blub_prolog_PredicateIndicator.prototype._term= nil;
__blub_prolog_PredicateIndicator.prototype.get_term = function(self) 
  if (self._term == nil) then 
    self._term = __blub_prolog_terms_Structure.new(__blub_prolog_PredicateIndicator.SLASH, _hx_tab_array({[0]=self.name, __blub_prolog_terms_NumberTerm.new(self.arity)}, 2));
  end;
  do return self._term end
end

__blub_prolog_PredicateIndicator.prototype.__class__ =  __blub_prolog_PredicateIndicator

__blub_prolog_PredicateIndicator.prototype.__properties__ =  {get_term="get_term"}

__blub_prolog_Predicate.new = function(database,indicator,isDynamic) 
  local self = _hx_new(__blub_prolog_Predicate.prototype)
  __blub_prolog_Predicate.super(self,database,indicator,isDynamic)
  return self
end
__blub_prolog_Predicate.super = function(self,database,indicator,isDynamic) 
  self.database = database;
  self.indicator = indicator;
  self.isDynamic = isDynamic;
  self.isBuiltin = false;
  self.listeners = __blub_prolog_Listeners.new();
  self.clauseList = Array.new();
end
_hxClasses["blub.prolog.Predicate"] = __blub_prolog_Predicate
__blub_prolog_Predicate.__name__ = "blub.prolog.Predicate"
__blub_prolog_Predicate.prototype = _hx_e();
__blub_prolog_Predicate.prototype.database= nil;
__blub_prolog_Predicate.prototype.isDynamic= nil;
__blub_prolog_Predicate.prototype.isBuiltin= nil;
__blub_prolog_Predicate.prototype.indicator= nil;
__blub_prolog_Predicate.prototype.listeners= nil;
__blub_prolog_Predicate.prototype.builtin= nil;
__blub_prolog_Predicate.prototype.code= nil;
__blub_prolog_Predicate.prototype.clauseList= nil;
__blub_prolog_Predicate.prototype.findMatchingClauses = function(self,args) 
  if (self.indicator.arity == 0) then 
    do return self.clauseList end;
  end;
  local result = Array.new();
  local _g = 0;
  local _g1 = self.clauseList;
  while (_g < _g1.length) do 
    local c = _g1[_g];
    _g = _g + 1;
    if (c:possibleMatch(args)) then 
      result:push(c);
    end;
  end;
  do return result end
end
__blub_prolog_Predicate.prototype.appendClause = function(self,clause) 
  if (self.isBuiltin) then 
    _G.error(__haxe_Exception.thrown(Std.string("cannot add clauses to a built-in predicate: ") .. Std.string(self.indicator:toString())),0);
  end;
  local c = __blub_prolog_Clause.new(self, clause);
  self.clauseList:push(c);
  local lis = self.listeners:iterator();
  while (lis:hasNext()) do 
    local lis = lis:next();
    lis:clauseAsserted(c, false);
  end;
  do return c end
end
__blub_prolog_Predicate.prototype.prependClause = function(self,clause) 
  if (self.isBuiltin) then 
    _G.error(__haxe_Exception.thrown(Std.string("cannot add clauses to a built-in predicate: ") .. Std.string(self.indicator:toString())),0);
  end;
  local c = __blub_prolog_Clause.new(self, clause);
  self.clauseList:unshift(c);
  local lis = self.listeners:iterator();
  while (lis:hasNext()) do 
    local lis = lis:next();
    lis:clauseAsserted(c, true);
  end;
  do return c end
end
__blub_prolog_Predicate.prototype.retractClause = function(self,clause) 
  self.clauseList:remove(clause);
  clause:isRetracted();
end
__blub_prolog_Predicate.prototype.clauseAt = function(self,index) 
  do return self.clauseList[index] end
end
__blub_prolog_Predicate.prototype.clauseCount = function(self) 
  do return self.clauseList.length end
end
__blub_prolog_Predicate.prototype.clauses = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self.clauseList) end
end
__blub_prolog_Predicate.prototype.compile = function(self) 
  if (self.isBuiltin) then 
    do return end;
  end;
  local _g = 0;
  local _g1 = self.clauseList;
  while (_g < _g1.length) do 
    local clause = _g1[_g];
    _g = _g + 1;
    clause:compile();
  end;
  self.code = __blub_prolog_compiler_PredicateCompiler.new(self.database):compile(self);
end
__blub_prolog_Predicate.prototype.toString = function(self) 
  do return self.indicator:toString() end
end
__blub_prolog_Predicate.prototype.setBuiltin = function(self,builtin) 
  self.builtin = builtin;
  self.isBuiltin = true;
end
__blub_prolog_Predicate.prototype.abolish = function(self) 
  self.database:abolish(self.indicator);
end
__blub_prolog_Predicate.prototype.isAbolished = function(self) 
  local _g = 0;
  local _g1 = self.clauseList;
  while (_g < _g1.length) do 
    local clause = _g1[_g];
    _g = _g + 1;
    clause:isRetracted();
  end;
end
__blub_prolog_Predicate.prototype.listing = function(self,logger) 
  local _g = 0;
  local _g1 = self.clauseList;
  while (_g < _g1.length) do 
    local clause = _g1[_g];
    _g = _g + 1;
    logger(clause.term:toString());
  end;
end

__blub_prolog_Predicate.prototype.__class__ =  __blub_prolog_Predicate

__blub_prolog_Preprocessor.new = function(macroDatabase) 
  local self = _hx_new(__blub_prolog_Preprocessor.prototype)
  __blub_prolog_Preprocessor.super(self,macroDatabase)
  return self
end
__blub_prolog_Preprocessor.super = function(self,macroDatabase) 
  self.macroDatabase = macroDatabase;
end
_hxClasses["blub.prolog.Preprocessor"] = __blub_prolog_Preprocessor
__blub_prolog_Preprocessor.__name__ = "blub.prolog.Preprocessor"
__blub_prolog_Preprocessor.nullPreprocessor = nil
__blub_prolog_Preprocessor.getAStandardPreprocessor = function() 
  local standardPreprocessor = __blub_prolog_Preprocessor.new(__blub_prolog_Database.new(__blub_prolog_AtomContext.GLOBALS));
  standardPreprocessor:loadStandardTheories();
  do return standardPreprocessor end;
end
__blub_prolog_Preprocessor.getNullPreprocessor = function() 
  if (__blub_prolog_Preprocessor.nullPreprocessor == nil) then 
    __blub_prolog_Preprocessor.nullPreprocessor = __blub_prolog_Preprocessor.new(nil);
  end;
  do return __blub_prolog_Preprocessor.nullPreprocessor end;
end
__blub_prolog_Preprocessor.prototype = _hx_e();
__blub_prolog_Preprocessor.prototype.macroDatabase= nil;
__blub_prolog_Preprocessor.prototype.preprocessorPredicates= nil;
__blub_prolog_Preprocessor.prototype.loadStandardTheories = function(self) 
  local _g = 0;
  local _g1 = __blub_prolog_Preprocessor.THEORIES;
  while (_g < _g1.length) do 
    local theory = _g1[_g];
    _g = _g + 1;
    local source = __haxe_Resource.getString(theory);
    self.macroDatabase:loadString(source, true, theory, __blub_prolog_Preprocessor.getNullPreprocessor());
  end;
end
__blub_prolog_Preprocessor.prototype.getPreprocessorNames = function(self) 
  if (self.preprocessorPredicates == nil) then 
    local preprocAtom = self.macroDatabase.context:getAtom("preprocessor");
    self.preprocessorPredicates = _hx_tab_array({}, 0);
    if (self.macroDatabase:lookup(__blub_prolog_PredicateIndicator.new(preprocAtom, 1)) == nil) then 
      do return self.preprocessorPredicates end;
    end;
    local nameVar = "Name";
    local query = __blub_prolog_Query.new(self.macroDatabase, __blub_prolog_terms_Structure.make(preprocAtom, __blub_prolog_terms_Variable.new(nameVar)));
    local bindings = query:allBindings();
    if (bindings ~= nil) then 
      local _g = 0;
      while (_g < bindings.length) do 
        local binding = bindings[_g];
        _g = _g + 1;
        local ret = binding.h[nameVar];
        if (ret == __haxe_ds_StringMap.tnull) then 
          ret = nil;
        end;
        local name = ret:asAtom();
        if (name ~= nil) then 
          self.preprocessorPredicates:push(name.text);
        end;
      end;
    end;
  end;
  do return self.preprocessorPredicates end
end
__blub_prolog_Preprocessor.prototype.process = function(self,db,clause) 
  if (self.macroDatabase == nil) then 
    do return _hx_tab_array({[0]=clause}, 1) end;
  end;
  local procNames = self:getPreprocessorNames();
  if (procNames.length == 0) then 
    do return _hx_tab_array({[0]=clause}, 1) end;
  end;
  local dbWrapper = __blub_prolog_Marshal.valueToTerm(db);
  if (clause:asStructure() ~= nil) then 
    clause = clause:asStructure():varsToReferences();
  end;
  local termQ = _hx_tab_array({[0]=clause}, 1);
  local _g = 0;
  while (_g < procNames.length) do 
    local procName = procNames[_g];
    _g = _g + 1;
    local outQ = _hx_tab_array({}, 0);
    local _g = 0;
    while (_g < termQ.length) do 
      local c = termQ[_g];
      _g = _g + 1;
      local clausesOut = self:callPreprocessor(procName, dbWrapper, c);
      local _g = 0;
      while (_g < clausesOut.length) do 
        local out = clausesOut[_g];
        _g = _g + 1;
        outQ:push(out);
      end;
    end;
    termQ = outQ;
  end;
  local results = _hx_tab_array({}, 0);
  local _g = 0;
  while (_g < termQ.length) do 
    local t = termQ[_g];
    _g = _g + 1;
    local stru = t:asStructure();
    if (stru ~= nil) then 
      results:push(stru:variablize());
    else
      results:push(t);
    end;
  end;
  do return results end
end
__blub_prolog_Preprocessor.prototype.callPreprocessor = function(self,name,dbWrapper,clause) 
  local varOut = __blub_prolog_terms_Variable.new();
  local queryTerm = __blub_prolog_terms_Structure.new(self.macroDatabase.context:getAtom(name), _hx_tab_array({[0]=dbWrapper, clause, varOut}, 3));
  local query = __blub_prolog_Query.new(self.macroDatabase, queryTerm);
  if (not query:get_engine():findSolution()) then 
    do return _hx_tab_array({[0]=clause}, 1) end;
  end;
  local result = query.environment[varOut.index]:dereference();
  if (result:asReference() ~= nil) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local list = result:asStructure();
  if (list == nil) then 
    do return _hx_tab_array({[0]=result}, 1) end;
  end;
  do return list:commaList() end
end

__blub_prolog_Preprocessor.prototype.__class__ =  __blub_prolog_Preprocessor

__blub_prolog_PrologError.new = function(msg) 
  local self = _hx_new(__blub_prolog_PrologError.prototype)
  __blub_prolog_PrologError.super(self,msg)
  return self
end
__blub_prolog_PrologError.super = function(self,msg) 
  self.message = msg;
end
_hxClasses["blub.prolog.PrologError"] = __blub_prolog_PrologError
__blub_prolog_PrologError.__name__ = "blub.prolog.PrologError"
__blub_prolog_PrologError.prototype = _hx_e();
__blub_prolog_PrologError.prototype.message= nil;
__blub_prolog_PrologError.prototype.toString = function(self) 
  do return self.message end
end

__blub_prolog_PrologError.prototype.__class__ =  __blub_prolog_PrologError

__blub_prolog_PrologException.new = function(errorTerm,context) 
  local self = _hx_new(__blub_prolog_PrologException.prototype)
  __blub_prolog_PrologException.super(self,errorTerm,context)
  return self
end
__blub_prolog_PrologException.super = function(self,errorTerm,context) 
  __blub_prolog_PrologError.super(self,errorTerm:toString());
  self.errorTerm = errorTerm;
  self.context = context;
end
_hxClasses["blub.prolog.PrologException"] = __blub_prolog_PrologException
__blub_prolog_PrologException.__name__ = "blub.prolog.PrologException"
__blub_prolog_PrologException.prototype = _hx_e();
__blub_prolog_PrologException.prototype.context= nil;
__blub_prolog_PrologException.prototype.errorTerm= nil;

__blub_prolog_PrologException.prototype.__class__ =  __blub_prolog_PrologException
__blub_prolog_PrologException.__super__ = __blub_prolog_PrologError
setmetatable(__blub_prolog_PrologException.prototype,{__index=__blub_prolog_PrologError.prototype})

__blub_prolog_RuntimeError.new = function(term,context) 
  local self = _hx_new(__blub_prolog_RuntimeError.prototype)
  __blub_prolog_RuntimeError.super(self,term,context)
  return self
end
__blub_prolog_RuntimeError.super = function(self,term,context) 
  __blub_prolog_PrologException.super(self,__blub_prolog_terms_Structure.new(__blub_prolog_RuntimeError.ERROR, _hx_tab_array({[0]=term, __blub_prolog_terms_Structure.new(__blub_prolog_RuntimeError.CONTEXT, _hx_tab_array({[0]=(function() 
    local _hx_1
    if (context ~= nil) then 
    _hx_1 = context.head; else 
    _hx_1 = __blub_prolog_RuntimeError.NONE; end
    return _hx_1
  end )()}, 1))}, 2)),context);
end
_hxClasses["blub.prolog.RuntimeError"] = __blub_prolog_RuntimeError
__blub_prolog_RuntimeError.__name__ = "blub.prolog.RuntimeError"
__blub_prolog_RuntimeError.instantiationError = function(context) 
  do return __blub_prolog_RuntimeError.new(__blub_prolog_RuntimeError.INSTANTIATION_ERROR, context) end;
end
__blub_prolog_RuntimeError.existenceError = function(type,culprit,context) 
  local tmp;
  local tmp1 = type[1];
  if (tmp1) == 0 then 
    tmp = __blub_prolog_RuntimeError.EXIST_PROCEDURE;
  elseif (tmp1) == 1 then 
    tmp = __blub_prolog_RuntimeError.EXIST_SRC_SINK;
  elseif (tmp1) == 2 then 
    tmp = __blub_prolog_RuntimeError.EXIST_STREAM; end;
  do return __blub_prolog_RuntimeError.new(__blub_prolog_terms_Structure.new(__blub_prolog_RuntimeError.EXISTENCE_ERROR, _hx_tab_array({[0]=tmp, culprit}, 2)), context) end;
end
__blub_prolog_RuntimeError.typeError = function(validType,culprit,context) 
  do return __blub_prolog_RuntimeError.new(__blub_prolog_terms_Structure.new(__blub_prolog_RuntimeError.TYPE_ERROR, _hx_tab_array({[0]=validType, culprit}, 2)), context) end;
end
__blub_prolog_RuntimeError.domainError = function(msg,culprit,context) 
  do return __blub_prolog_RuntimeError.new(__blub_prolog_terms_Structure.new(__blub_prolog_RuntimeError.DOMAIN_ERROR, _hx_tab_array({[0]=__blub_prolog_terms_Atom.unregisteredAtom(msg), culprit}, 2)), context) end;
end
__blub_prolog_RuntimeError.prototype = _hx_e();

__blub_prolog_RuntimeError.prototype.__class__ =  __blub_prolog_RuntimeError
__blub_prolog_RuntimeError.__super__ = __blub_prolog_PrologException
setmetatable(__blub_prolog_RuntimeError.prototype,{__index=__blub_prolog_PrologException.prototype})
_hxClasses["blub.prolog.ExistenceError"] = __blub_prolog_ExistenceError;
_hxClasses["blub.prolog.ExistenceError"] = { __ename__ = "blub.prolog.ExistenceError", __constructs__ = _hx_tab_array({[0]="ee_procedure","ee_source_sink","ee_stream"},3)}
__blub_prolog_ExistenceError = _hxClasses["blub.prolog.ExistenceError"];
__blub_prolog_ExistenceError.ee_procedure = _hx_tab_array({[0]="ee_procedure",0,__enum__ = __blub_prolog_ExistenceError},2)

__blub_prolog_ExistenceError.ee_source_sink = _hx_tab_array({[0]="ee_source_sink",1,__enum__ = __blub_prolog_ExistenceError},2)

__blub_prolog_ExistenceError.ee_stream = _hx_tab_array({[0]="ee_stream",2,__enum__ = __blub_prolog_ExistenceError},2)

__blub_prolog_ExistenceError.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_ExistenceError.ee_procedure,__blub_prolog_ExistenceError.ee_source_sink,__blub_prolog_ExistenceError.ee_stream}, 3)

__blub_prolog_TypeError.new = function(term,context) 
  local self = _hx_new(__blub_prolog_TypeError.prototype)
  __blub_prolog_TypeError.super(self,term,context)
  return self
end
__blub_prolog_TypeError.super = function(self,term,context) 
  __blub_prolog_RuntimeError.super(self,term,context);
end
_hxClasses["blub.prolog.TypeError"] = __blub_prolog_TypeError
__blub_prolog_TypeError.__name__ = "blub.prolog.TypeError"
__blub_prolog_TypeError.prototype = _hx_e();

__blub_prolog_TypeError.prototype.__class__ =  __blub_prolog_TypeError
__blub_prolog_TypeError.__super__ = __blub_prolog_RuntimeError
setmetatable(__blub_prolog_TypeError.prototype,{__index=__blub_prolog_RuntimeError.prototype})

__blub_prolog_Query.new = function(database,term,autocommit) 
  local self = _hx_new(__blub_prolog_Query.prototype)
  __blub_prolog_Query.super(self,database,term,autocommit)
  return self
end
__blub_prolog_Query.super = function(self,database,term,autocommit) 
  if (autocommit == nil) then 
    autocommit = true;
  end;
  self.database = database;
  self.term = term;
  self.autocommit = autocommit;
  self.variableContext = (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(term, __blub_prolog_terms_Structure)) then 
    _hx_1 = (__lua_Boot.__cast(term , __blub_prolog_terms_Structure)):get_variableContext(); else 
    _hx_1 = __blub_prolog_terms_VariableContext.EMPTY; end
    return _hx_1
  end )();
end
_hx_exports["blub"]["prolog"]["Query"] = __blub_prolog_Query
_hxClasses["blub.prolog.Query"] = __blub_prolog_Query
__blub_prolog_Query.__name__ = "blub.prolog.Query"
__blub_prolog_Query.timestamp = function() 
  do return Sys.time() end;
end
__blub_prolog_Query.prototype = _hx_e();
__blub_prolog_Query.prototype.autocommit= nil;
__blub_prolog_Query.prototype.committed= nil;
__blub_prolog_Query.prototype.hadResults= nil;
__blub_prolog_Query.prototype.database= nil;
__blub_prolog_Query.prototype.term= nil;
__blub_prolog_Query.prototype.nextResult= nil;
__blub_prolog_Query.prototype._code= nil;
__blub_prolog_Query.prototype.code= nil;
__blub_prolog_Query.prototype.environment= nil;
__blub_prolog_Query.prototype.variableContext= nil;
__blub_prolog_Query.prototype._engine= nil;
__blub_prolog_Query.prototype.engine= nil;
__blub_prolog_Query.prototype.setCode = function(self,code) 
  self._code = code;
  self._engine = nil;
end
__blub_prolog_Query.prototype.get_code = function(self) 
  if (self._code == nil) then 
    self._code = __blub_prolog_compiler_QueryCompiler.new(self.database):compile(self.term);
  end;
  do return self._code end
end
__blub_prolog_Query.prototype.get_engine = function(self) 
  if (self._engine == nil) then 
    self._engine = __blub_prolog_engine_QueryEngine.new(self.database, self:get_code());
    local _this = self._engine;
    local size = self.variableContext:get_count();
    _this.environment = Array.new();
    local _g = 0;
    local _g1 = size;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      _this.environment:push(__blub_prolog_terms_Reference.new());
    end;
    self.environment = self._engine.environment;
  end;
  do return self._engine end
end
__blub_prolog_Query.prototype.iterator = function(self) 
  do return self end
end
__blub_prolog_Query.prototype.putBack = function(self,solution) 
  self.nextResult = solution;
end
__blub_prolog_Query.prototype.hasNext = function(self) 
  if (self.nextResult ~= nil) then 
    do return true end;
  end;
  self.nextResult = self:nextSolution();
  if (self.nextResult ~= nil) then 
    do return true end;
  end;
  do return false end
end
__blub_prolog_Query.prototype.next = function(self) 
  if (self.nextResult ~= nil) then 
    local result = self.nextResult;
    self.nextResult = nil;
    do return result end;
  end;
  do return self:nextSolution() end
end
__blub_prolog_Query.prototype.complete = function(self) 
  while (self:nextSolution() ~= nil) do 
  end;
end
__blub_prolog_Query.prototype.allResults = function(self) 
  local res = Array.new();
  local result;
  while (true) do 
    result = self:nextSolution();
    if (not (result ~= nil)) then 
      break;
    end;
    res:push(result);
  end;
  do return res end
end
__blub_prolog_Query.prototype.commit = function(self) 
  self:complete();
  self:_commit();
end
__blub_prolog_Query.prototype.allSolutions = function(self) 
  local res = Array.new();
  local result;
  while (true) do 
    result = self:nextSolution();
    if (not (result ~= nil)) then 
      break;
    end;
    if (not __blub_prolog_ResultUtil.isSuccess(result)) then 
      break;
    end;
    res:push(result);
  end;
  do return res end
end
__blub_prolog_Query.prototype.allBindings = function(self) 
  local res = Array.new();
  local result;
  while (true) do 
    result = self:nextSolution();
    if (not (result ~= nil)) then 
      break;
    end;
    if (not __blub_prolog_ResultUtil.isSuccess(result)) then 
      do return nil end;
    end;
    local binds = __blub_prolog_ResultUtil.getBindings(result);
    if (binds == nil) then 
      do return res end;
    end;
    res:push(binds);
  end;
  do return res end
end
__blub_prolog_Query.prototype.nextSolution = function(self) 
  if (self.nextResult ~= nil) then 
    local r = self.nextResult;
    self.nextResult = nil;
    do return r end;
  end;
  local result;
  if (not self:get_engine():findSolution()) then 
    if (self.autocommit) then 
      self:_commit();
    end;
    if (self.hadResults) then 
      do return nil end;
    end;
    result = __blub_prolog_Result.failure;
  else
    result = self:grabCurrentSolution();
  end;
  self.hadResults = true;
  do return result end
end
__blub_prolog_Query.prototype.grabCurrentSolution = function(self) 
  if (self.variableContext:get_count() == 0) then 
    do return __blub_prolog_Result.success end;
  else
    local binds = self:makeBindings();
    do return __blub_prolog_Result.bindings(binds) end;
  end;
end
__blub_prolog_Query.prototype.makeBindings = function(self) 
  if (self.variableContext:get_count() == 0) then 
    do return nil end;
  end;
  local binds = __haxe_ds_StringMap.new();
  local refVars = __haxe_ds_ObjectMap.new();
  local v = self.variableContext:variables();
  while (v:hasNext()) do 
    local v = v:next();
    local value = self.environment[v.index]:dereference();
    local ref = value:asReference();
    if (ref ~= nil) then 
      local v = refVars.h[ref];
      if (v == nil) then 
        v = __blub_prolog_terms_Variable.new();
        refVars.h[ref] = v;
        refVars.k[ref] = true;
      end;
      value = v;
    end;
    local s = value:asStructure();
    if ((s ~= nil) and s:hasReferences()) then 
      value = s:variablize(refVars);
    end;
    local key = v:get_name();
    if (value == nil) then 
      binds.h[key] = __haxe_ds_StringMap.tnull;
    else
      binds.h[key] = value;
    end;
  end;
  do return binds end
end
__blub_prolog_Query.prototype._commit = function(self) 
  if (self.committed) then 
    do return end;
  end;
  if (self._engine.transaction ~= nil) then 
    self._engine.transaction:commit();
  end;
  self.committed = true;
end

__blub_prolog_Query.prototype.__class__ =  __blub_prolog_Query

__blub_prolog_Query.prototype.__properties__ =  {get_engine="get_engine",get_code="get_code"}
_hxClasses["blub.prolog.Result"] = __blub_prolog_Result;
_hxClasses["blub.prolog.Result"] = { __ename__ = "blub.prolog.Result", __constructs__ = _hx_tab_array({[0]="failure","success","bindings"},3)}
__blub_prolog_Result = _hxClasses["blub.prolog.Result"];
__blub_prolog_Result.failure = _hx_tab_array({[0]="failure",0,__enum__ = __blub_prolog_Result},2)

__blub_prolog_Result.success = _hx_tab_array({[0]="success",1,__enum__ = __blub_prolog_Result},2)

__blub_prolog_Result.bindings = function(binds) local _x = _hx_tab_array({[0]="bindings",2,binds,__enum__=__blub_prolog_Result}, 3); return _x; end 
__blub_prolog_Result.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_Result.failure,__blub_prolog_Result.success}, 2)

__blub_prolog_ResultUtil.new = {}
_hx_exports["blub"]["prolog"]["ResultUtil"] = __blub_prolog_ResultUtil
_hxClasses["blub.prolog.ResultUtil"] = __blub_prolog_ResultUtil
__blub_prolog_ResultUtil.__name__ = "blub.prolog.ResultUtil"
__blub_prolog_ResultUtil.toString = function(result) 
  local tmp = result[1];
  if (tmp) == 0 then 
    do return "false" end;
  elseif (tmp) == 1 then 
    do return "true" end;
  elseif (tmp) == 2 then 
    local b = result[2];
    do return __blub_prolog_ResultUtil.bindingsToString(b) end; end;
end
__blub_prolog_ResultUtil.bindingsToString = function(bindings) 
  if (bindings == nil) then 
    do return "{null}" end;
  end;
  local s = "{ ";
  local first = true;
  local key = bindings:keys();
  while (key:hasNext()) do 
    local key = key:next();
    if (first) then 
      first = false;
    else
      s = Std.string(s) .. Std.string(", ");
    end;
    local ret = bindings.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local t = ret;
    s = Std.string(s) .. Std.string((Std.string(Std.string(key) .. Std.string("=")) .. Std.string(((function() 
      local _hx_1
      if (t ~= nil) then 
      _hx_1 = t:toString(); else 
      _hx_1 = "<null>"; end
      return _hx_1
    end )()))));
  end;
  s = Std.string(s) .. Std.string(" }");
  do return s end;
end
__blub_prolog_ResultUtil.getBindings = function(result) 
  local tmp = result[1];
  if (tmp) == 0 then 
    do return nil end;
  elseif (tmp) == 1 then 
    do return nil end;
  elseif (tmp) == 2 then 
    local b = result[2];
    do return b end; end;
end
__blub_prolog_ResultUtil.isSuccess = function(result) 
  local tmp = result[1];
  if (tmp) == 0 then 
    do return false end;
  elseif (tmp) == 1 then 
    do return true end;
  elseif (tmp) == 2 then 
    local _g = result[2];
    do return true end; end;
end
__blub_prolog_ResultUtil.equals = function(r1,r2) 
  local binds1;
  local binds2;
  local tmp = r1[1];
  if (tmp) == 0 then 
    if (r2[1] == 0) then 
      do return true end;
    else
      do return false end;
    end;
  elseif (tmp) == 1 then 
    if (r2[1] == 1) then 
      do return true end;
    else
      do return false end;
    end;
  elseif (tmp) == 2 then 
    local b1 = r1[2];
    if (r2[1] == 2) then 
      local b2 = r2[2];
      binds1 = b1;
      binds2 = b2;
    else
      do return false end;
    end; end;
  do return __blub_prolog_ResultUtil.compareBindings(binds1, binds2) end;
end
__blub_prolog_ResultUtil.equalsBindings = function(result,binds) 
  local tmp = result[1];
  if (tmp) == 0 then 
    do return false end;
  elseif (tmp) == 1 then 
    do return false end;
  elseif (tmp) == 2 then 
    local b1 = result[2];
    do return __blub_prolog_ResultUtil.compareBindings(b1, binds) end; end;
end
__blub_prolog_ResultUtil.compareBindings = function(binds1,binds2) 
  local key = binds2:keys();
  while (key:hasNext()) do 
    local key = key:next();
    local ret = binds2.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local val = ret;
    if (val == nil) then 
      do return false end;
    end;
    local ret = binds1.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local bind = ret;
    if ((bind == nil) or not bind:equals(val)) then 
      do return false end;
    end;
  end;
  local key = binds1:keys();
  while (key:hasNext()) do 
    local key = key:next();
    local ret = binds1.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local bind = ret;
    local ret = binds2.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local val = ret;
    if (val == nil) then 
      do return false end;
    end;
    if (not bind:equals(val)) then 
      do return false end;
    end;
  end;
  do return true end;
end

__blub_prolog_async_AsyncQuery.new = function(database,term,autocommit) 
  local self = _hx_new(__blub_prolog_async_AsyncQuery.prototype)
  __blub_prolog_async_AsyncQuery.super(self,database,term,autocommit)
  return self
end
__blub_prolog_async_AsyncQuery.super = function(self,database,term,autocommit) 
  if (autocommit == nil) then 
    autocommit = true;
  end;
  __blub_prolog_Query.super(self,database,term,autocommit);
end
_hxClasses["blub.prolog.async.AsyncQuery"] = __blub_prolog_async_AsyncQuery
__blub_prolog_async_AsyncQuery.__name__ = "blub.prolog.async.AsyncQuery"
__blub_prolog_async_AsyncQuery.prototype = _hx_e();
__blub_prolog_async_AsyncQuery.prototype.execute = function(self,resultCallback) 
  local _gthis = self;
  if (resultCallback == nil) then 
    self:get_engine():executeAsync();
    do return end;
  end;
  self:get_engine():executeAsync(function(eng,type) 
    local tmp = type[1];
    if (tmp) == 0 then 
      if (not _gthis:get_engine().solutionFound) then 
        resultCallback:asyncFail(_gthis);
      else
        resultCallback:asyncSolution(_gthis, _gthis:makeBindings());
      end;
    elseif (tmp) == 1 then 
      resultCallback:asyncDone(_gthis);
    elseif (tmp) == 2 then 
      resultCallback:asyncHalt(_gthis);
    elseif (tmp) == 3 then 
      resultCallback:asyncOperation(_gthis); end;
  end);
end

__blub_prolog_async_AsyncQuery.prototype.__class__ =  __blub_prolog_async_AsyncQuery
__blub_prolog_async_AsyncQuery.__super__ = __blub_prolog_Query
setmetatable(__blub_prolog_async_AsyncQuery.prototype,{__index=__blub_prolog_Query.prototype})
setmetatable(__blub_prolog_async_AsyncQuery.prototype.__properties__,{__index=__blub_prolog_Query.prototype.__properties__})

__blub_prolog_async_AsyncResults.new = {}
_hxClasses["blub.prolog.async.AsyncResults"] = __blub_prolog_async_AsyncResults
__blub_prolog_async_AsyncResults.__name__ = "blub.prolog.async.AsyncResults"
__blub_prolog_async_AsyncResults.prototype = _hx_e();
__blub_prolog_async_AsyncResults.prototype.asyncSolution= nil;
__blub_prolog_async_AsyncResults.prototype.asyncFail= nil;
__blub_prolog_async_AsyncResults.prototype.asyncDone= nil;
__blub_prolog_async_AsyncResults.prototype.asyncOperation= nil;
__blub_prolog_async_AsyncResults.prototype.asyncHalt= nil;

__blub_prolog_async_AsyncResults.prototype.__class__ =  __blub_prolog_async_AsyncResults

__blub_prolog_async_AsyncResultsImpl.new = function() 
  local self = _hx_new(__blub_prolog_async_AsyncResultsImpl.prototype)
  __blub_prolog_async_AsyncResultsImpl.super(self)
  return self
end
__blub_prolog_async_AsyncResultsImpl.super = function(self) 
end
_hxClasses["blub.prolog.async.AsyncResultsImpl"] = __blub_prolog_async_AsyncResultsImpl
__blub_prolog_async_AsyncResultsImpl.__name__ = "blub.prolog.async.AsyncResultsImpl"
__blub_prolog_async_AsyncResultsImpl.__interfaces__ = {__blub_prolog_async_AsyncResults}
__blub_prolog_async_AsyncResultsImpl.prototype = _hx_e();
__blub_prolog_async_AsyncResultsImpl.prototype.asyncSolution = function(self,query,bindings) 
end
__blub_prolog_async_AsyncResultsImpl.prototype.asyncFail = function(self,query) 
end
__blub_prolog_async_AsyncResultsImpl.prototype.asyncDone = function(self,query) 
  self:doneOrHalted(query);
end
__blub_prolog_async_AsyncResultsImpl.prototype.asyncOperation = function(self,query) 
end
__blub_prolog_async_AsyncResultsImpl.prototype.asyncHalt = function(self,query) 
  self:doneOrHalted(query);
end
__blub_prolog_async_AsyncResultsImpl.prototype.doneOrHalted = function(self,query) 
end

__blub_prolog_async_AsyncResultsImpl.prototype.__class__ =  __blub_prolog_async_AsyncResultsImpl

__blub_prolog_builtins_BuiltinPredicate.new = function(name,arity) 
  local self = _hx_new(__blub_prolog_builtins_BuiltinPredicate.prototype)
  __blub_prolog_builtins_BuiltinPredicate.super(self,name,arity)
  return self
end
__blub_prolog_builtins_BuiltinPredicate.super = function(self,name,arity) 
  self.arity = arity;
  self.name = name;
end
_hxClasses["blub.prolog.builtins.BuiltinPredicate"] = __blub_prolog_builtins_BuiltinPredicate
__blub_prolog_builtins_BuiltinPredicate.__name__ = "blub.prolog.builtins.BuiltinPredicate"
__blub_prolog_builtins_BuiltinPredicate.prototype = _hx_e();
__blub_prolog_builtins_BuiltinPredicate.prototype.name= nil;
__blub_prolog_builtins_BuiltinPredicate.prototype.arity= nil;
__blub_prolog_builtins_BuiltinPredicate.prototype.register = function(self,database) 
  local nameAtom = database.context:getAtom(self.name);
  local pred = database:addPredicate(__blub_prolog_PredicateIndicator.new(nameAtom, self.arity), false);
  pred:setBuiltin(self);
end
__blub_prolog_builtins_BuiltinPredicate.prototype.compile = function(self,compiler,pred,term) 
  local stru = term:asStructure();
  local args = (function() 
    local _hx_1
    if (stru ~= nil) then 
    _hx_1 = stru:getArgs(); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  compiler:add(__blub_prolog_compiler_Instruction.call_builtin(pred.indicator:toString(), args));
end
__blub_prolog_builtins_BuiltinPredicate.prototype.execute = function(self,engine,args) 
end

__blub_prolog_builtins_BuiltinPredicate.prototype.__class__ =  __blub_prolog_builtins_BuiltinPredicate

__blub_prolog_builtins_Abolish.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Abolish.prototype)
  __blub_prolog_builtins_Abolish.super(self)
  return self
end
__blub_prolog_builtins_Abolish.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"abolish",1);
end
_hxClasses["blub.prolog.builtins.Abolish"] = __blub_prolog_builtins_Abolish
__blub_prolog_builtins_Abolish.__name__ = "blub.prolog.builtins.Abolish"
__blub_prolog_builtins_Abolish.prototype = _hx_e();
__blub_prolog_builtins_Abolish.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local term = args[0]:toValue(env):dereference();
  local stru = term:asStructure();
  local indicator = __blub_prolog_PredicateIndicator.fromTerm(term, engine.context);
  local predicate = engine.database:lookup(indicator);
  if (predicate == nil) then 
    do return end;
  end;
  engine:makeTransaction():abolish(predicate);
end

__blub_prolog_builtins_Abolish.prototype.__class__ =  __blub_prolog_builtins_Abolish
__blub_prolog_builtins_Abolish.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Abolish.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Arg.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Arg.prototype)
  __blub_prolog_builtins_Arg.super(self)
  return self
end
__blub_prolog_builtins_Arg.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"arg",3);
end
_hxClasses["blub.prolog.builtins.Arg"] = __blub_prolog_builtins_Arg
__blub_prolog_builtins_Arg.__name__ = "blub.prolog.builtins.Arg"
__blub_prolog_builtins_Arg.prototype = _hx_e();
__blub_prolog_builtins_Arg.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local arg = args[0]:toValue(env);
  local term = args[1]:toValue(env);
  local value = args[2]:toValue(env);
  local atom = term:asAtom();
  if (atom ~= nil) then 
    engine:fail();
    do return end;
  end;
  local stru = term:asStructure();
  if (stru == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_compound, term, engine.context));
    do return end;
  end;
  local argNum = arg:asNumber();
  if (argNum ~= nil) then 
    self:executeIndex(engine, argNum, stru, value);
    do return end;
  end;
  local argRef = arg:asReference();
  if (argRef == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_variable, arg, engine.context));
    do return end;
  end;
  self:executeChoices(engine, argRef, stru, value);
end
__blub_prolog_builtins_Arg.prototype.executeChoices = function(self,engine,argRef,stru,value) 
  local arity = stru:getArity();
  local _g = 0;
  local _g1 = arity;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local arg = stru:argAt(i):asValueTerm();
    local binds = engine.bindings;
    if (arg:unify(value, engine)) then 
      argRef:unify(__blub_prolog_terms_NumberTerm.new(i + 1), engine);
      if (i < (arity - 1)) then 
        local cp = __blub_prolog_builtins_ArgChoicePoint.new(engine, i + 1, argRef, stru, value);
        cp.bindings = binds;
      end;
      do return end;
    end;
  end;
  engine:fail();
end
__blub_prolog_builtins_Arg.prototype.executeIndex = function(self,engine,argNum,stru,value) 
  local index = Std.int(argNum.value);
  if (index < 0) then 
    engine:raiseException(__blub_prolog_RuntimeError.domainError("not_less_than_zero", argNum, engine.context));
    do return end;
  end;
  if ((index == 0) or (index > stru:getArity())) then 
    engine:fail();
    do return end;
  end;
  local arg = stru:argAt(index - 1):asValueTerm();
  engine:unify(arg, value);
end

__blub_prolog_builtins_Arg.prototype.__class__ =  __blub_prolog_builtins_Arg
__blub_prolog_builtins_Arg.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Arg.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_engine_parts_ChoicePoint.new = function(eng,frame) 
  local self = _hx_new(__blub_prolog_engine_parts_ChoicePoint.prototype)
  __blub_prolog_engine_parts_ChoicePoint.super(self,eng,frame)
  return self
end
__blub_prolog_engine_parts_ChoicePoint.super = function(self,eng,frame) 
  self.frame = (function() 
    local _hx_1
    if (frame ~= nil) then 
    _hx_1 = frame; else 
    _hx_1 = __blub_prolog_engine_parts_CodeFrame.new(eng); end
    return _hx_1
  end )();
  self.bindings = eng.bindings;
  self.prev = eng.choiceStack;
  eng.choiceStack = self;
  self.engine = eng;
end
_hxClasses["blub.prolog.engine.parts.ChoicePoint"] = __blub_prolog_engine_parts_ChoicePoint
__blub_prolog_engine_parts_ChoicePoint.__name__ = "blub.prolog.engine.parts.ChoicePoint"
__blub_prolog_engine_parts_ChoicePoint.prototype = _hx_e();
__blub_prolog_engine_parts_ChoicePoint.prototype.bindings= nil;
__blub_prolog_engine_parts_ChoicePoint.prototype.frame= nil;
__blub_prolog_engine_parts_ChoicePoint.prototype.prev= nil;
__blub_prolog_engine_parts_ChoicePoint.prototype.engine= nil;
__blub_prolog_engine_parts_ChoicePoint.prototype.nextChoice = function(self) 
  self.frame:restore();
  self:popThisChoicePoint();
  do return true end
end
__blub_prolog_engine_parts_ChoicePoint.prototype.undoBindings = function(self) 
  local _this = self.engine;
  local prevBind = self.bindings;
  local bind = _this.bindings;
  while ((bind ~= nil) and (bind ~= prevBind)) do 
    bind.ref:unbind(bind.old);
    bind = bind.next;
  end;
  _this.bindings = prevBind;
end
__blub_prolog_engine_parts_ChoicePoint.prototype.popThisChoicePoint = function(self) 
  self.engine.choiceStack = self.prev;
end
__blub_prolog_engine_parts_ChoicePoint.prototype.halt = function(self) 
end
__blub_prolog_engine_parts_ChoicePoint.prototype.toString = function(self) 
  do return Std.string("Choicepoint: ") .. Std.string(Std.string(self.frame)) end
end
__blub_prolog_engine_parts_ChoicePoint.prototype.getId = function(self) 
  if (self._id < 1) then 
    self._id = (function() 
    local _hx_obj = __blub_prolog_engine_parts_ChoicePoint;
    local _hx_fld = 'ID';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
  end;
  do return self._id end
end
__blub_prolog_engine_parts_ChoicePoint.prototype._id= nil;

__blub_prolog_engine_parts_ChoicePoint.prototype.__class__ =  __blub_prolog_engine_parts_ChoicePoint

__blub_prolog_builtins_ArgChoicePoint.new = function(eng,index,argRef,stru,value) 
  local self = _hx_new(__blub_prolog_builtins_ArgChoicePoint.prototype)
  __blub_prolog_builtins_ArgChoicePoint.super(self,eng,index,argRef,stru,value)
  return self
end
__blub_prolog_builtins_ArgChoicePoint.super = function(self,eng,index,argRef,stru,value) 
  __blub_prolog_engine_parts_ChoicePoint.super(self,eng,eng.codeStack);
  self.index = index;
  self.argRef = argRef;
  self.stru = stru;
  self.value = value;
end
_hxClasses["blub.prolog.builtins.ArgChoicePoint"] = __blub_prolog_builtins_ArgChoicePoint
__blub_prolog_builtins_ArgChoicePoint.__name__ = "blub.prolog.builtins.ArgChoicePoint"
__blub_prolog_builtins_ArgChoicePoint.prototype = _hx_e();
__blub_prolog_builtins_ArgChoicePoint.prototype.index= nil;
__blub_prolog_builtins_ArgChoicePoint.prototype.argRef= nil;
__blub_prolog_builtins_ArgChoicePoint.prototype.stru= nil;
__blub_prolog_builtins_ArgChoicePoint.prototype.value= nil;
__blub_prolog_builtins_ArgChoicePoint.prototype.nextChoice = function(self) 
  self.frame:restore();
  local arity = self.stru:getArity();
  local _g = self.index;
  local _g1 = arity;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local arg = self.stru:argAt(i):asValueTerm();
    if (arg:unify(self.value, self.engine)) then 
      self.argRef:unify(__blub_prolog_terms_NumberTerm.new(i + 1), self.engine);
      if (i == (arity - 1)) then 
        self:popThisChoicePoint();
      else
        self.index = i + 1;
      end;
      do return true end;
    end;
  end;
  self:popThisChoicePoint();
  do return false end
end
__blub_prolog_builtins_ArgChoicePoint.prototype.toString = function(self) 
  do return Std.string("arg/3: ") .. Std.string(Std.string(self.frame)) end
end

__blub_prolog_builtins_ArgChoicePoint.prototype.__class__ =  __blub_prolog_builtins_ArgChoicePoint
__blub_prolog_builtins_ArgChoicePoint.__super__ = __blub_prolog_engine_parts_ChoicePoint
setmetatable(__blub_prolog_builtins_ArgChoicePoint.prototype,{__index=__blub_prolog_engine_parts_ChoicePoint.prototype})

__blub_prolog_builtins_AssertA.new = function() 
  local self = _hx_new(__blub_prolog_builtins_AssertA.prototype)
  __blub_prolog_builtins_AssertA.super(self)
  return self
end
__blub_prolog_builtins_AssertA.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"asserta",1);
end
_hxClasses["blub.prolog.builtins.AssertA"] = __blub_prolog_builtins_AssertA
__blub_prolog_builtins_AssertA.__name__ = "blub.prolog.builtins.AssertA"
__blub_prolog_builtins_AssertA.prototype = _hx_e();
__blub_prolog_builtins_AssertA.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local term = args[0]:toValue(env):dereference();
  if (not __lua_Boot.__instanceof(term, __blub_prolog_terms_ClauseTerm)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, term, engine.context));
    do return end;
  end;
  local clauseTerm = term;
  local stru = clauseTerm:asStructure();
  if (stru ~= nil) then 
    clauseTerm = stru:variablize();
  end;
  engine:makeTransaction():preAssert(clauseTerm);
end

__blub_prolog_builtins_AssertA.prototype.__class__ =  __blub_prolog_builtins_AssertA
__blub_prolog_builtins_AssertA.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_AssertA.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_AssertZ.new = function() 
  local self = _hx_new(__blub_prolog_builtins_AssertZ.prototype)
  __blub_prolog_builtins_AssertZ.super(self)
  return self
end
__blub_prolog_builtins_AssertZ.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"assertz",1);
end
_hxClasses["blub.prolog.builtins.AssertZ"] = __blub_prolog_builtins_AssertZ
__blub_prolog_builtins_AssertZ.__name__ = "blub.prolog.builtins.AssertZ"
__blub_prolog_builtins_AssertZ.prototype = _hx_e();
__blub_prolog_builtins_AssertZ.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local term = args[0]:toValue(env):dereference();
  if (not __lua_Boot.__instanceof(term, __blub_prolog_terms_ClauseTerm)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, term, engine.context));
    do return end;
  end;
  local clauseTerm = term;
  local stru = clauseTerm:asStructure();
  if (stru ~= nil) then 
    clauseTerm = stru:variablize();
  end;
  engine:makeTransaction():postAssert(clauseTerm);
end

__blub_prolog_builtins_AssertZ.prototype.__class__ =  __blub_prolog_builtins_AssertZ
__blub_prolog_builtins_AssertZ.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_AssertZ.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_AtomCodes.new = function() 
  local self = _hx_new(__blub_prolog_builtins_AtomCodes.prototype)
  __blub_prolog_builtins_AtomCodes.super(self)
  return self
end
__blub_prolog_builtins_AtomCodes.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"atom_codes",2);
end
_hxClasses["blub.prolog.builtins.AtomCodes"] = __blub_prolog_builtins_AtomCodes
__blub_prolog_builtins_AtomCodes.__name__ = "blub.prolog.builtins.AtomCodes"
__blub_prolog_builtins_AtomCodes.prototype = _hx_e();
__blub_prolog_builtins_AtomCodes.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local atomArg = args[0]:toValue(env);
  local stringArg = args[1]:toValue(env);
  local atom = atomArg:asAtom();
  if (atom ~= nil) then 
    local text = atom.text;
    local len = __lua_lib_luautf8_Utf8.len(text);
    local codes = Array.new();
    local _g = 0;
    local _g1 = len;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      codes:push(__blub_prolog_terms_NumberTerm.new(__lua_lib_luautf8_Utf8.byte(text, i + 1)));
    end;
    engine:unify(__blub_prolog_terms_Structure.makeList(codes), stringArg);
    do return end;
  end;
  local atomRef = atomArg:asReference();
  if (atomRef == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_atom, atomArg, engine.context));
    do return end;
  end;
  local codeList = stringArg:asStructure();
  if (codeList == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_list, stringArg, engine.context));
    do return end;
  end;
  local codes = codeList:toArray();
  if (codes == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_list, codeList, engine.context));
    do return end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  local _g = 0;
  while (_g < codes.length) do 
    local t = codes[_g];
    _g = _g + 1;
    local code = t:asNumber();
    if (code == nil) then 
      engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_number, t, engine.context));
      do return end;
    end;
    _G.table.insert(buf_b, __lua_lib_luautf8_Utf8.char(Std.int(code.value)));
    buf_length = buf_length + 1;
  end;
  engine:unify(__blub_prolog_terms_Atom.unregisteredAtom(_G.table.concat(buf_b)), atomRef);
end

__blub_prolog_builtins_AtomCodes.prototype.__class__ =  __blub_prolog_builtins_AtomCodes
__blub_prolog_builtins_AtomCodes.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_AtomCodes.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_BinaryArithmeticPred.new = function(functor,fn) 
  local self = _hx_new(__blub_prolog_builtins_BinaryArithmeticPred.prototype)
  __blub_prolog_builtins_BinaryArithmeticPred.super(self,functor,fn)
  return self
end
__blub_prolog_builtins_BinaryArithmeticPred.super = function(self,functor,fn) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,functor,2);
  self.fn = _hx_funcToField(fn);
end
_hxClasses["blub.prolog.builtins.BinaryArithmeticPred"] = __blub_prolog_builtins_BinaryArithmeticPred
__blub_prolog_builtins_BinaryArithmeticPred.__name__ = "blub.prolog.builtins.BinaryArithmeticPred"
__blub_prolog_builtins_BinaryArithmeticPred.get = function() 
  do return _hx_tab_array({[0]=__blub_prolog_builtins_BinaryArithmeticPred.new("=:=", function(a,b) 
    do return a == b end;
  end), __blub_prolog_builtins_BinaryArithmeticPred.new("=\\=", function(a,b) 
    do return a ~= b end;
  end), __blub_prolog_builtins_BinaryArithmeticPred.new(">", function(a,b) 
    do return a > b end;
  end), __blub_prolog_builtins_BinaryArithmeticPred.new("<", function(a,b) 
    do return a < b end;
  end), __blub_prolog_builtins_BinaryArithmeticPred.new(">=", function(a,b) 
    do return a >= b end;
  end), __blub_prolog_builtins_BinaryArithmeticPred.new("=<", function(a,b) 
    do return a <= b end;
  end)}, 6) end;
end
__blub_prolog_builtins_BinaryArithmeticPred.prototype = _hx_e();
__blub_prolog_builtins_BinaryArithmeticPred.prototype.fn= nil;
__blub_prolog_builtins_BinaryArithmeticPred.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env);
  local b = args[1]:toValue(env);
  local numA = a:asNumber();
  local numB = b:asNumber();
  local valA = (function() 
    local _hx_1
    if (numA == nil) then 
    _hx_1 = engine:get_arithmetic():evaluate(a); else 
    _hx_1 = numA.value; end
    return _hx_1
  end )();
  local valB = (function() 
    local _hx_2
    if (numB == nil) then 
    _hx_2 = engine:get_arithmetic():evaluate(b); else 
    _hx_2 = numB.value; end
    return _hx_2
  end )();
  if (not self:fn(valA, valB)) then 
    engine:fail();
  end;
end

__blub_prolog_builtins_BinaryArithmeticPred.prototype.__class__ =  __blub_prolog_builtins_BinaryArithmeticPred
__blub_prolog_builtins_BinaryArithmeticPred.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_BinaryArithmeticPred.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Breakpoint.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Breakpoint.prototype)
  __blub_prolog_builtins_Breakpoint.super(self)
  return self
end
__blub_prolog_builtins_Breakpoint.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"break",0);
end
_hxClasses["blub.prolog.builtins.Breakpoint"] = __blub_prolog_builtins_Breakpoint
__blub_prolog_builtins_Breakpoint.__name__ = "blub.prolog.builtins.Breakpoint"
__blub_prolog_builtins_Breakpoint.prototype = _hx_e();
__blub_prolog_builtins_Breakpoint.prototype.execute = function(self,engine,args) 
  engine:breakpoint();
end

__blub_prolog_builtins_Breakpoint.prototype.__class__ =  __blub_prolog_builtins_Breakpoint
__blub_prolog_builtins_Breakpoint.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Breakpoint.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_True.new = function() 
  local self = _hx_new(__blub_prolog_builtins_True.prototype)
  __blub_prolog_builtins_True.super(self)
  return self
end
__blub_prolog_builtins_True.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"true",0);
end
_hxClasses["blub.prolog.builtins.True"] = __blub_prolog_builtins_True
__blub_prolog_builtins_True.__name__ = "blub.prolog.builtins.True"
__blub_prolog_builtins_True.prototype = _hx_e();
__blub_prolog_builtins_True.prototype.execute = function(self,engine,args) 
end

__blub_prolog_builtins_True.prototype.__class__ =  __blub_prolog_builtins_True
__blub_prolog_builtins_True.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_True.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Fail.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Fail.prototype)
  __blub_prolog_builtins_Fail.super(self)
  return self
end
__blub_prolog_builtins_Fail.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"fail",0);
end
_hxClasses["blub.prolog.builtins.Fail"] = __blub_prolog_builtins_Fail
__blub_prolog_builtins_Fail.__name__ = "blub.prolog.builtins.Fail"
__blub_prolog_builtins_Fail.prototype = _hx_e();
__blub_prolog_builtins_Fail.prototype.execute = function(self,engine,args) 
  engine:fail();
end

__blub_prolog_builtins_Fail.prototype.__class__ =  __blub_prolog_builtins_Fail
__blub_prolog_builtins_Fail.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Fail.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Repeat.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Repeat.prototype)
  __blub_prolog_builtins_Repeat.super(self)
  return self
end
__blub_prolog_builtins_Repeat.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"repeat",0);
end
_hxClasses["blub.prolog.builtins.Repeat"] = __blub_prolog_builtins_Repeat
__blub_prolog_builtins_Repeat.__name__ = "blub.prolog.builtins.Repeat"
__blub_prolog_builtins_Repeat.prototype = _hx_e();
__blub_prolog_builtins_Repeat.prototype.execute = function(self,engine,args) 
  __blub_prolog_engine_parts_RepeatingChoicePoint.new(engine);
end

__blub_prolog_builtins_Repeat.prototype.__class__ =  __blub_prolog_builtins_Repeat
__blub_prolog_builtins_Repeat.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Repeat.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Is.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Is.prototype)
  __blub_prolog_builtins_Is.super(self)
  return self
end
__blub_prolog_builtins_Is.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"is",2);
end
_hxClasses["blub.prolog.builtins.Is"] = __blub_prolog_builtins_Is
__blub_prolog_builtins_Is.__name__ = "blub.prolog.builtins.Is"
__blub_prolog_builtins_Is.prototype = _hx_e();
__blub_prolog_builtins_Is.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env);
  local b = args[1]:toValue(env);
  local num = b:asNumber();
  if (num == nil) then 
    num = __blub_prolog_terms_NumberTerm.new(engine:get_arithmetic():evaluate(b));
  end;
  engine:unify(a, num);
end

__blub_prolog_builtins_Is.prototype.__class__ =  __blub_prolog_builtins_Is
__blub_prolog_builtins_Is.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Is.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Unify.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Unify.prototype)
  __blub_prolog_builtins_Unify.super(self)
  return self
end
__blub_prolog_builtins_Unify.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"=",2);
end
_hxClasses["blub.prolog.builtins.Unify"] = __blub_prolog_builtins_Unify
__blub_prolog_builtins_Unify.__name__ = "blub.prolog.builtins.Unify"
__blub_prolog_builtins_Unify.prototype = _hx_e();
__blub_prolog_builtins_Unify.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  engine:unify(args[0]:toValue(env), args[1]:toValue(env));
end

__blub_prolog_builtins_Unify.prototype.__class__ =  __blub_prolog_builtins_Unify
__blub_prolog_builtins_Unify.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Unify.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Identical.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Identical.prototype)
  __blub_prolog_builtins_Identical.super(self)
  return self
end
__blub_prolog_builtins_Identical.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"==",2);
end
_hxClasses["blub.prolog.builtins.Identical"] = __blub_prolog_builtins_Identical
__blub_prolog_builtins_Identical.__name__ = "blub.prolog.builtins.Identical"
__blub_prolog_builtins_Identical.prototype = _hx_e();
__blub_prolog_builtins_Identical.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  if (not args[0]:toValue(env):equals(args[1]:toValue(env))) then 
    engine:fail();
  end;
end

__blub_prolog_builtins_Identical.prototype.__class__ =  __blub_prolog_builtins_Identical
__blub_prolog_builtins_Identical.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Identical.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_NotIdentical.new = function() 
  local self = _hx_new(__blub_prolog_builtins_NotIdentical.prototype)
  __blub_prolog_builtins_NotIdentical.super(self)
  return self
end
__blub_prolog_builtins_NotIdentical.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"\\==",2);
end
_hxClasses["blub.prolog.builtins.NotIdentical"] = __blub_prolog_builtins_NotIdentical
__blub_prolog_builtins_NotIdentical.__name__ = "blub.prolog.builtins.NotIdentical"
__blub_prolog_builtins_NotIdentical.prototype = _hx_e();
__blub_prolog_builtins_NotIdentical.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  if (args[0]:toValue(env):equals(args[1]:toValue(env))) then 
    engine:fail();
  end;
end

__blub_prolog_builtins_NotIdentical.prototype.__class__ =  __blub_prolog_builtins_NotIdentical
__blub_prolog_builtins_NotIdentical.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_NotIdentical.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Cut.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Cut.prototype)
  __blub_prolog_builtins_Cut.super(self)
  return self
end
__blub_prolog_builtins_Cut.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"!",0);
end
_hxClasses["blub.prolog.builtins.Cut"] = __blub_prolog_builtins_Cut
__blub_prolog_builtins_Cut.__name__ = "blub.prolog.builtins.Cut"
__blub_prolog_builtins_Cut.prototype = _hx_e();
__blub_prolog_builtins_Cut.prototype.execute = function(self,engine,args) 
  engine:cut();
end

__blub_prolog_builtins_Cut.prototype.__class__ =  __blub_prolog_builtins_Cut
__blub_prolog_builtins_Cut.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Cut.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Call.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Call.prototype)
  __blub_prolog_builtins_Call.super(self)
  return self
end
__blub_prolog_builtins_Call.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"call",1);
end
_hxClasses["blub.prolog.builtins.Call"] = __blub_prolog_builtins_Call
__blub_prolog_builtins_Call.__name__ = "blub.prolog.builtins.Call"
__blub_prolog_builtins_Call.prototype = _hx_e();
__blub_prolog_builtins_Call.prototype.execute = function(self,engine,args) 
  local goal = args[0]:toValue(engine.environment):dereference();
  local _hx_status, _hx_result = pcall(function() 
  
      local instruction = __blub_prolog_builtins_CallCompiler.new(engine):compileCall(goal);
      engine.codeStack = __blub_prolog_engine_parts_CodeFrame.new(engine);
      local cp = __blub_prolog_engine_parts_CutPoint.new(engine);
      engine.cutBarrier = _hx_o({__fields__={prev=true,choice=true},prev=engine.cutBarrier,choice=cp});
      engine.codePointer = instruction;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    local _g1 = __haxe_Exception.caught(_g):unwrap();
    if (__lua_Boot.__instanceof(_g1, __blub_prolog_builtins_NotCallable)) then 
      local ex = _g1;
      engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, ex.culprit, engine.context));
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end

__blub_prolog_builtins_Call.prototype.__class__ =  __blub_prolog_builtins_Call
__blub_prolog_builtins_Call.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Call.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Once.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Once.prototype)
  __blub_prolog_builtins_Once.super(self)
  return self
end
__blub_prolog_builtins_Once.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"once",1);
end
_hxClasses["blub.prolog.builtins.Once"] = __blub_prolog_builtins_Once
__blub_prolog_builtins_Once.__name__ = "blub.prolog.builtins.Once"
__blub_prolog_builtins_Once.prototype = _hx_e();
__blub_prolog_builtins_Once.prototype.compile = function(self,compiler,pred,term) 
  local call = compiler.database:lookup(__blub_prolog_builtins_Call.INDICATOR);
  compiler:add(__blub_prolog_compiler_Instruction.cut_point);
  compiler:add(__blub_prolog_compiler_Instruction.call_builtin("call/1", term:asStructure():getArgs()));
  compiler:add(__blub_prolog_compiler_Instruction.cut);
end

__blub_prolog_builtins_Once.prototype.__class__ =  __blub_prolog_builtins_Once
__blub_prolog_builtins_Once.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Once.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_NotUnifiable.new = function() 
  local self = _hx_new(__blub_prolog_builtins_NotUnifiable.prototype)
  __blub_prolog_builtins_NotUnifiable.super(self)
  return self
end
__blub_prolog_builtins_NotUnifiable.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"\\=",2);
end
_hxClasses["blub.prolog.builtins.NotUnifiable"] = __blub_prolog_builtins_NotUnifiable
__blub_prolog_builtins_NotUnifiable.__name__ = "blub.prolog.builtins.NotUnifiable"
__blub_prolog_builtins_NotUnifiable.prototype = _hx_e();
__blub_prolog_builtins_NotUnifiable.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env);
  local b = args[1]:toValue(env);
  if (a:unify(b, engine)) then 
    engine:fail();
  end;
end

__blub_prolog_builtins_NotUnifiable.prototype.__class__ =  __blub_prolog_builtins_NotUnifiable
__blub_prolog_builtins_NotUnifiable.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_NotUnifiable.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_NotProvable.new = function() 
  local self = _hx_new(__blub_prolog_builtins_NotProvable.prototype)
  __blub_prolog_builtins_NotProvable.super(self)
  return self
end
__blub_prolog_builtins_NotProvable.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"\\+",1);
end
_hxClasses["blub.prolog.builtins.NotProvable"] = __blub_prolog_builtins_NotProvable
__blub_prolog_builtins_NotProvable.__name__ = "blub.prolog.builtins.NotProvable"
__blub_prolog_builtins_NotProvable.prototype = _hx_e();
__blub_prolog_builtins_NotProvable.prototype.compile = function(self,compiler,pred,term) 
  local atoms = compiler.database.context;
  local trueAtom = atoms:getAtom("true");
  local failAtom = atoms:getAtom("fail");
  local cutAtom = atoms:getAtom("!");
  local conjunc2 = __blub_prolog_terms_Structure.new(atoms:getAtom(","));
  conjunc2:addArg(cutAtom);
  conjunc2:addArg(failAtom);
  local conjunc1 = __blub_prolog_terms_Structure.new(atoms:getAtom(","));
  conjunc1:addArg(term:asStructure():argAt(0));
  conjunc1:addArg(conjunc2);
  local disjunc = __blub_prolog_terms_Structure.new(atoms:getAtom(";"));
  disjunc:addArg(conjunc1);
  disjunc:addArg(trueAtom);
  compiler:compileNestedTerm(disjunc, true);
end

__blub_prolog_builtins_NotProvable.prototype.__class__ =  __blub_prolog_builtins_NotProvable
__blub_prolog_builtins_NotProvable.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_NotProvable.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_IfThen.new = function() 
  local self = _hx_new(__blub_prolog_builtins_IfThen.prototype)
  __blub_prolog_builtins_IfThen.super(self)
  return self
end
__blub_prolog_builtins_IfThen.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"->",2);
end
_hxClasses["blub.prolog.builtins.IfThen"] = __blub_prolog_builtins_IfThen
__blub_prolog_builtins_IfThen.__name__ = "blub.prolog.builtins.IfThen"
__blub_prolog_builtins_IfThen.prototype = _hx_e();
__blub_prolog_builtins_IfThen.prototype.compile = function(self,compiler,pred,term) 
  local ifThen = term:asStructure();
  local ifTerm = compiler:clauseTerm(ifThen:argAt(0));
  local thenTerm = compiler:clauseTerm(ifThen:argAt(1));
  compiler:add(__blub_prolog_compiler_Instruction.cut_point);
  compiler:compileTerm(ifTerm);
  compiler:add(__blub_prolog_compiler_Instruction.cut);
  compiler:compileTerm(thenTerm);
end

__blub_prolog_builtins_IfThen.prototype.__class__ =  __blub_prolog_builtins_IfThen
__blub_prolog_builtins_IfThen.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_IfThen.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_IfThenElse.new = function() 
  local self = _hx_new(__blub_prolog_builtins_IfThenElse.prototype)
  __blub_prolog_builtins_IfThenElse.super(self)
  return self
end
__blub_prolog_builtins_IfThenElse.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"#if_then_else",3);
end
_hxClasses["blub.prolog.builtins.IfThenElse"] = __blub_prolog_builtins_IfThenElse
__blub_prolog_builtins_IfThenElse.__name__ = "blub.prolog.builtins.IfThenElse"
__blub_prolog_builtins_IfThenElse.prototype = _hx_e();
__blub_prolog_builtins_IfThenElse.prototype.compile = function(self,compiler,pred,term) 
  local ifThen = term:asStructure();
  local ifTerm = ifThen:argAt(0);
  local thenTerm = ifThen:argAt(1);
  local elseTerm = ifThen:argAt(2);
  local atoms = compiler.database.context;
  local cutAtom = atoms:getAtom("!");
  local conjunc2 = __blub_prolog_terms_Structure.new(atoms:getAtom(","));
  conjunc2:addArg(cutAtom);
  conjunc2:addArg(thenTerm);
  local conjunc1 = __blub_prolog_terms_Structure.new(atoms:getAtom(","));
  conjunc1:addArg(ifTerm);
  conjunc1:addArg(conjunc2);
  local disjunc = __blub_prolog_terms_Structure.new(atoms:getAtom(";"));
  disjunc:addArg(conjunc1);
  disjunc:addArg(elseTerm);
  compiler:compileNestedTerm(disjunc, true);
end

__blub_prolog_builtins_IfThenElse.prototype.__class__ =  __blub_prolog_builtins_IfThenElse
__blub_prolog_builtins_IfThenElse.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_IfThenElse.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Retract.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Retract.prototype)
  __blub_prolog_builtins_Retract.super(self)
  return self
end
__blub_prolog_builtins_Retract.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"retract",1);
end
_hxClasses["blub.prolog.builtins.Retract"] = __blub_prolog_builtins_Retract
__blub_prolog_builtins_Retract.__name__ = "blub.prolog.builtins.Retract"
__blub_prolog_builtins_Retract.prototype = _hx_e();
__blub_prolog_builtins_Retract.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local term = args[0]:toValue(env):dereference();
  if (not __lua_Boot.__instanceof(term, __blub_prolog_terms_ClauseTerm)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, term, engine.context));
    do return end;
  end;
  local ct = term;
  local functor = ct:getIndicator();
  local predicate = engine.database:lookup(functor);
  if (predicate == nil) then 
    do return end;
  end;
  local clause = predicate:clauses();
  while (clause:hasNext()) do 
    local clause = clause:next();
    local cterm = clause.term;
    local env = clause.variableContext:createEnvironment();
    local vterm = cterm:toValue(env);
    if (vterm:unify(term, nil)) then 
      engine:makeTransaction():retract(clause);
      do return end;
    end;
  end;
end

__blub_prolog_builtins_Retract.prototype.__class__ =  __blub_prolog_builtins_Retract
__blub_prolog_builtins_Retract.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Retract.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Timestamp.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Timestamp.prototype)
  __blub_prolog_builtins_Timestamp.super(self)
  return self
end
__blub_prolog_builtins_Timestamp.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"timestamp",1);
end
_hxClasses["blub.prolog.builtins.Timestamp"] = __blub_prolog_builtins_Timestamp
__blub_prolog_builtins_Timestamp.__name__ = "blub.prolog.builtins.Timestamp"
__blub_prolog_builtins_Timestamp.prototype = _hx_e();
__blub_prolog_builtins_Timestamp.prototype.execute = function(self,engine,args) 
  engine:unify(args[0]:toValue(engine.environment), __blub_prolog_terms_NumberTerm.new(Sys.time()));
end

__blub_prolog_builtins_Timestamp.prototype.__class__ =  __blub_prolog_builtins_Timestamp
__blub_prolog_builtins_Timestamp.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Timestamp.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Gensym.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Gensym.prototype)
  __blub_prolog_builtins_Gensym.super(self)
  return self
end
__blub_prolog_builtins_Gensym.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"gensym",2);
end
_hxClasses["blub.prolog.builtins.Gensym"] = __blub_prolog_builtins_Gensym
__blub_prolog_builtins_Gensym.__name__ = "blub.prolog.builtins.Gensym"
__blub_prolog_builtins_Gensym.prototype = _hx_e();
__blub_prolog_builtins_Gensym.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local base = args[0]:toValue(env);
  local baseAtom = base:asAtom();
  if (baseAtom == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_atom, base, engine.context));
  end;
  local tmp = args[1]:toValue(env);
  local tmp1 = Std.string(baseAtom.text) .. Std.string((function() 
  local _hx_obj = __blub_prolog_builtins_Gensym;
  local _hx_fld = 'count';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)());
  engine:unify(tmp, __blub_prolog_terms_Atom.unregisteredAtom(tmp1));
end

__blub_prolog_builtins_Gensym.prototype.__class__ =  __blub_prolog_builtins_Gensym
__blub_prolog_builtins_Gensym.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Gensym.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Univ.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Univ.prototype)
  __blub_prolog_builtins_Univ.super(self)
  return self
end
__blub_prolog_builtins_Univ.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"=..",2);
end
_hxClasses["blub.prolog.builtins.Univ"] = __blub_prolog_builtins_Univ
__blub_prolog_builtins_Univ.__name__ = "blub.prolog.builtins.Univ"
__blub_prolog_builtins_Univ.prototype = _hx_e();
__blub_prolog_builtins_Univ.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env);
  local b = args[1]:toValue(env);
  local refA = a:asReference();
  local refB = b:asReference();
  if ((refA ~= nil) and (refB ~= nil)) then 
    engine:raiseException(__blub_prolog_RuntimeError.instantiationError(engine.context));
    do return end;
  end;
  if (refA ~= nil) then 
    local struB = b:asStructure();
    if ((struB == nil) or (struB:getName() ~= __blub_prolog_terms_Structure.CONS_LIST)) then 
      engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_list, b, engine.context));
      do return end;
    end;
    local args = _hx_tab_array({}, 0);
    local s = struB;
    while (s ~= nil) do 
      local tail = s:argAt(1);
      if (tail == __blub_prolog_terms_Structure.EMPTY_LIST) then 
        break;
      end;
      local tailStru = tail:asStructure();
      if ((tailStru == nil) or (tailStru:getName() ~= __blub_prolog_terms_Structure.CONS_LIST)) then 
        engine:raiseException(__blub_prolog_RuntimeError.instantiationError(engine.context));
        do return end;
      end;
      args:push(tailStru:argAt(0));
      s = tailStru;
    end;
    if (args.length == 0) then 
      engine:unify(refA, struB:argAt(0));
      do return end;
    end;
    local name = struB:argAt(0):asAtom();
    if (name == nil) then 
      engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_atom, struB:argAt(0), engine.context));
      do return end;
    end;
    local newStru = __blub_prolog_terms_Structure.new(name, args);
    engine:unify(refA, newStru);
    do return end;
  end;
  local lhsList = nil;
  local lhsAtom = a:asAtom();
  if (lhsAtom ~= nil) then 
    lhsList = __blub_prolog_terms_Structure.makeList(_hx_tab_array({[0]=lhsAtom}, 1));
  else
    local lhsStru = a:asStructure();
    if (lhsStru == nil) then 
      engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_compound, a, engine.context));
      do return end;
    end;
    local elems = Array.new();
    elems:push(lhsStru:getName());
    local _g = 0;
    local _g1 = lhsStru:getArgs();
    while (_g < _g1.length) do 
      local arg = _g1[_g];
      _g = _g + 1;
      elems:push(arg);
    end;
    lhsList = __blub_prolog_terms_Structure.makeList(elems);
  end;
  engine:unify(lhsList, b);
end

__blub_prolog_builtins_Univ.prototype.__class__ =  __blub_prolog_builtins_Univ
__blub_prolog_builtins_Univ.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Univ.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Write.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Write.prototype)
  __blub_prolog_builtins_Write.super(self)
  return self
end
__blub_prolog_builtins_Write.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"write",1);
end
_hxClasses["blub.prolog.builtins.Write"] = __blub_prolog_builtins_Write
__blub_prolog_builtins_Write.__name__ = "blub.prolog.builtins.Write"
__blub_prolog_builtins_Write.prototype = _hx_e();
__blub_prolog_builtins_Write.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  __haxe_Log.trace(args[0]:toValue(env):dereference():toString(), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/blub/prolog/builtins/Write.hx",lineNumber=20,className="blub.prolog.builtins.Write",methodName="execute"}));
end

__blub_prolog_builtins_Write.prototype.__class__ =  __blub_prolog_builtins_Write
__blub_prolog_builtins_Write.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Write.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Clear.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Clear.prototype)
  __blub_prolog_builtins_Clear.super(self)
  return self
end
__blub_prolog_builtins_Clear.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"clear",0);
end
_hxClasses["blub.prolog.builtins.Clear"] = __blub_prolog_builtins_Clear
__blub_prolog_builtins_Clear.__name__ = "blub.prolog.builtins.Clear"
__blub_prolog_builtins_Clear.prototype = _hx_e();
__blub_prolog_builtins_Clear.prototype.execute = function(self,engine,args) 
end

__blub_prolog_builtins_Clear.prototype.__class__ =  __blub_prolog_builtins_Clear
__blub_prolog_builtins_Clear.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Clear.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Stop.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Stop.prototype)
  __blub_prolog_builtins_Stop.super(self)
  return self
end
__blub_prolog_builtins_Stop.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"stop",0);
end
_hxClasses["blub.prolog.builtins.Stop"] = __blub_prolog_builtins_Stop
__blub_prolog_builtins_Stop.__name__ = "blub.prolog.builtins.Stop"
__blub_prolog_builtins_Stop.prototype = _hx_e();
__blub_prolog_builtins_Stop.prototype.execute = function(self,engine,args) 
  engine:halt();
end

__blub_prolog_builtins_Stop.prototype.__class__ =  __blub_prolog_builtins_Stop
__blub_prolog_builtins_Stop.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Stop.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Functor.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Functor.prototype)
  __blub_prolog_builtins_Functor.super(self)
  return self
end
__blub_prolog_builtins_Functor.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"functor",3);
end
_hxClasses["blub.prolog.builtins.Functor"] = __blub_prolog_builtins_Functor
__blub_prolog_builtins_Functor.__name__ = "blub.prolog.builtins.Functor"
__blub_prolog_builtins_Functor.prototype = _hx_e();
__blub_prolog_builtins_Functor.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local term = args[0]:toValue(env);
  local name = args[1]:toValue(env);
  local arity = args[2]:toValue(env);
  local termVar = term:asReference();
  if (termVar ~= nil) then 
    local nameAtom = name:asAtom();
    local arityNum = arity:asNumber();
    if (((nameAtom == nil) or (arityNum == nil)) or (arityNum.value < 0)) then 
      engine:raiseException(__blub_prolog_RuntimeError.instantiationError(engine.context));
      do return end;
    end;
    local newTerm = nil;
    local arityVal = Std.int(arityNum.value);
    if (arityVal == 0) then 
      newTerm = nameAtom;
    else
      local newStru = __blub_prolog_terms_Structure.new(nameAtom);
      local _g = 0;
      local _g1 = arityVal;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        newStru:addArg(__blub_prolog_terms_Reference.new());
      end;
      newTerm = newStru;
    end;
    engine:unify(term, newTerm);
    do return end;
  end;
  local termAtom = term:asAtom();
  if (termAtom ~= nil) then 
    if (not engine:unify(name, termAtom)) then 
      do return end;
    end;
    engine:unify(arity, __blub_prolog_terms_NumberTerm.new(0));
    do return end;
  end;
  local termStru = term:asStructure();
  if (termStru ~= nil) then 
    if (not engine:unify(name, termStru:getName())) then 
      do return end;
    end;
    engine:unify(arity, __blub_prolog_terms_NumberTerm.new(termStru:getArity()));
    do return end;
  end;
  engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_compound, term, engine.context));
end

__blub_prolog_builtins_Functor.prototype.__class__ =  __blub_prolog_builtins_Functor
__blub_prolog_builtins_Functor.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Functor.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_ListSlice.new = function() 
  local self = _hx_new(__blub_prolog_builtins_ListSlice.prototype)
  __blub_prolog_builtins_ListSlice.super(self)
  return self
end
__blub_prolog_builtins_ListSlice.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"list_slice",3);
end
_hxClasses["blub.prolog.builtins.ListSlice"] = __blub_prolog_builtins_ListSlice
__blub_prolog_builtins_ListSlice.__name__ = "blub.prolog.builtins.ListSlice"
__blub_prolog_builtins_ListSlice.prototype = _hx_e();
__blub_prolog_builtins_ListSlice.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env);
  local b = args[1]:toValue(env);
  local c = args[2]:toValue(env);
  local listA = a:asStructure();
  local listB = b:asStructure();
  local listC = c:asReference();
  if (listA == nil) then 
    local emptyA = a:asAtom();
    if ((emptyA ~= nil) and (emptyA == __blub_prolog_terms_Structure.EMPTY_LIST)) then 
      engine:unify(__blub_prolog_terms_Structure.EMPTY_LIST, c);
      do return end;
    end;
  end;
  if (listB == nil) then 
    local emptyB = b:asAtom();
    if ((emptyB ~= nil) and (emptyB == __blub_prolog_terms_Structure.EMPTY_LIST)) then 
      engine:unify(a, c);
      do return end;
    end;
  end;
  if (((listA == nil) or (listB == nil)) or (listC == nil)) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom("list_slice/3 requires (In,In,Out)"), engine.context));
    do return end;
  end;
  local elems = Array.new();
  local s = listA:listStructureIterator();
  while (s:hasNext()) do 
    local s = s:next();
    if (s == listB) then 
      break;
    end;
    elems:push(s:argAt(0));
  end;
  engine:unify(__blub_prolog_terms_Structure.makeList(elems), listC);
end

__blub_prolog_builtins_ListSlice.prototype.__class__ =  __blub_prolog_builtins_ListSlice
__blub_prolog_builtins_ListSlice.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_ListSlice.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Stack.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Stack.prototype)
  __blub_prolog_builtins_Stack.super(self)
  return self
end
__blub_prolog_builtins_Stack.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"stack",2);
end
_hxClasses["blub.prolog.builtins.Stack"] = __blub_prolog_builtins_Stack
__blub_prolog_builtins_Stack.__name__ = "blub.prolog.builtins.Stack"
__blub_prolog_builtins_Stack.prototype = _hx_e();
__blub_prolog_builtins_Stack.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local h = args[0]:toValue(env);
  local t = args[1]:toValue(env);
  local headRef = h:asReference();
  local tailRef = t:asReference();
  if ((headRef == nil) or (tailRef == nil)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_variable, (function() 
      local _hx_1
      if (headRef == nil) then 
      _hx_1 = h; else 
      _hx_1 = t; end
      return _hx_1
    end )(), engine.context));
    do return end;
  end;
  local head = __blub_prolog_builtins__Stack_StackHead.new();
  local tail = __blub_prolog_builtins__Stack_StackTail.new(head);
  engine:unify(headRef, head);
  engine:unify(tailRef, tail);
end

__blub_prolog_builtins_Stack.prototype.__class__ =  __blub_prolog_builtins_Stack
__blub_prolog_builtins_Stack.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Stack.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Member.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Member.prototype)
  __blub_prolog_builtins_Member.super(self)
  return self
end
__blub_prolog_builtins_Member.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"member",2);
end
_hxClasses["blub.prolog.builtins.Member"] = __blub_prolog_builtins_Member
__blub_prolog_builtins_Member.__name__ = "blub.prolog.builtins.Member"
__blub_prolog_builtins_Member.prototype = _hx_e();
__blub_prolog_builtins_Member.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local elem = args[0]:toValue(env);
  local list = args[1]:toValue(env);
  local cp = __blub_prolog_builtins_MemberChoicePoint.new(engine, __blub_prolog_engine_parts_CodeFrame.new(engine), elem, list);
  engine:processBuiltinChoices();
end

__blub_prolog_builtins_Member.prototype.__class__ =  __blub_prolog_builtins_Member
__blub_prolog_builtins_Member.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Member.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Listing.new = function() 
  local self = _hx_new(__blub_prolog_builtins_Listing.prototype)
  __blub_prolog_builtins_Listing.super(self)
  return self
end
__blub_prolog_builtins_Listing.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"listing",0);
end
_hxClasses["blub.prolog.builtins.Listing"] = __blub_prolog_builtins_Listing
__blub_prolog_builtins_Listing.__name__ = "blub.prolog.builtins.Listing"
__blub_prolog_builtins_Listing.prototype = _hx_e();
__blub_prolog_builtins_Listing.prototype.execute = function(self,engine,args) 
  engine.database:listing(function(s) 
    __haxe_Log.trace(s, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/blub/prolog/builtins/Listing.hx",lineNumber=15,className="blub.prolog.builtins.Listing",methodName="execute"}));
  end);
end

__blub_prolog_builtins_Listing.prototype.__class__ =  __blub_prolog_builtins_Listing
__blub_prolog_builtins_Listing.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_Listing.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_ThrowUp.new = function() 
  local self = _hx_new(__blub_prolog_builtins_ThrowUp.prototype)
  __blub_prolog_builtins_ThrowUp.super(self)
  return self
end
__blub_prolog_builtins_ThrowUp.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"throw_up",1);
end
_hxClasses["blub.prolog.builtins.ThrowUp"] = __blub_prolog_builtins_ThrowUp
__blub_prolog_builtins_ThrowUp.__name__ = "blub.prolog.builtins.ThrowUp"
__blub_prolog_builtins_ThrowUp.prototype = _hx_e();
__blub_prolog_builtins_ThrowUp.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  _G.error(__haxe_Exception.thrown(__blub_prolog_PrologException.new(args[0]:toValue(env):dereference(), engine.context)),0);
end

__blub_prolog_builtins_ThrowUp.prototype.__class__ =  __blub_prolog_builtins_ThrowUp
__blub_prolog_builtins_ThrowUp.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_ThrowUp.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_TermTypes.new = function(functor,fn) 
  local self = _hx_new(__blub_prolog_builtins_TermTypes.prototype)
  __blub_prolog_builtins_TermTypes.super(self,functor,fn)
  return self
end
__blub_prolog_builtins_TermTypes.super = function(self,functor,fn) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,functor,1);
  self.fn = _hx_funcToField(fn);
end
_hxClasses["blub.prolog.builtins.TermTypes"] = __blub_prolog_builtins_TermTypes
__blub_prolog_builtins_TermTypes.__name__ = "blub.prolog.builtins.TermTypes"
__blub_prolog_builtins_TermTypes.get = function() 
  do return _hx_tab_array({[0]=__blub_prolog_builtins_TermTypes.new("var", function(t) 
    do return t:asReference() ~= nil end;
  end), __blub_prolog_builtins_TermTypes.new("nonvar", function(t) 
    do return t:asReference() == nil end;
  end), __blub_prolog_builtins_TermTypes.new("number", function(t) 
    do return t:asNumber() ~= nil end;
  end), __blub_prolog_builtins_TermTypes.new("atom", function(t) 
    do return t:asAtom() ~= nil end;
  end), __blub_prolog_builtins_TermTypes.new("atomic", function(t) 
    if (t:asAtom() == nil) then 
      do return t:asNumber() ~= nil end;
    else
      do return true end;
    end;
  end), __blub_prolog_builtins_TermTypes.new("compound", function(t) 
    do return t:asStructure() ~= nil end;
  end), __blub_prolog_builtins_TermTypes.new("callable", function(t) 
    if (t:asAtom() == nil) then 
      do return t:asStructure() ~= nil end;
    else
      do return true end;
    end;
  end), __blub_prolog_builtins_TermTypes.new("ground", function(t) 
    do return t:isGround() end;
  end), __blub_prolog_builtins_TermTypes.new("integer", function(t) 
    local num = t:asNumber();
    if (num == nil) then 
      do return false end;
    end;
    do return __lua_Boot.__instanceof(num.value, Int) end;
  end), __blub_prolog_builtins_TermTypes.new("is_list", function(t) 
    local empty = t:asAtom();
    if (empty ~= nil) then 
      do return empty:isList() end;
    end;
    local str = t:asStructure();
    if (str == nil) then 
      do return false end;
    end;
    do return str:isList() end;
  end), __blub_prolog_builtins_TermTypes.new("float", function(t) 
    local num = t:asNumber();
    if (num == nil) then 
      do return false end;
    end;
    do return not __lua_Boot.__instanceof(num.value, Int) end;
  end)}, 11) end;
end
__blub_prolog_builtins_TermTypes.prototype = _hx_e();
__blub_prolog_builtins_TermTypes.prototype.fn= nil;
__blub_prolog_builtins_TermTypes.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local term = args[0]:toValue(env):dereference();
  if (not self:fn(term)) then 
    engine:fail();
  end;
end

__blub_prolog_builtins_TermTypes.prototype.__class__ =  __blub_prolog_builtins_TermTypes
__blub_prolog_builtins_TermTypes.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_TermTypes.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__lua_Boot.new = {}
_hxClasses["lua.Boot"] = __lua_Boot
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot._ = nil
__lua_Boot.__unhtml = function(s) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("&") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(s, "&", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("&");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
      idx = nil;
    end;
  end;
  local _this = ret:join("&amp;");
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("<") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, "<", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("<");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  local _this = ret:join("&lt;");
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(">") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, ">", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(">");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  do return ret:join("&gt;") end;
end
__lua_Boot.isClass = function(o) 
  if (_G.type(o) ~= "table") then 
    do return false end;
  else
    do return o.__name__ end;
  end;
end
__lua_Boot.isEnum = function(e) 
  if (_G.type(e) ~= "table") then 
    do return false end;
  else
    do return e.__ename__ end;
  end;
end
__lua_Boot.getClass = function(o) 
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.inheritsFrom = function(o,cl) 
  while ((_G.getmetatable(o) ~= nil) and (_G.getmetatable(o).__index ~= nil)) do 
    if (_G.getmetatable(o).__index == cl.prototype) then 
      do return true end;
    end;
    o = _G.getmetatable(o).__index;
  end;
  do return false end;
end
__lua_Boot.__cast = function(o,t) 
  if ((o == nil) or __lua_Boot.__instanceof(o, t)) then 
    do return o end;
  else
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Cannot cast ") .. Std.string(Std.string(o))) .. Std.string(" to ")) .. Std.string(Std.string(t))),0);
  end;
end
__lua_Boot.defArray = function(tab,length) 
  if (length == nil) then 
    length = _hx_table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      _G.table.remove(tab, 1);
      tab[0] = head;
      do return _hx_tab_array(tab, length) end;
    else
      do return _hx_tab_array({}, 0) end;
    end;
  else
    do return _hx_tab_array(tab, length) end;
  end;
end
__lua_Boot.tableToObject = function(t) 
  do return _hx_o(t) end;
end
__lua_Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(date:getFullYear()) .. Std.string("-")) .. Std.string(((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = Std.string("0") .. Std.string(m); else 
    _hx_1 = Std.string("") .. Std.string(m); end
    return _hx_1
  end )()))) .. Std.string("-")) .. Std.string(((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = Std.string("0") .. Std.string(d); else 
    _hx_2 = Std.string("") .. Std.string(d); end
    return _hx_2
  end )()))) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = Std.string("0") .. Std.string(h); else 
    _hx_3 = Std.string("") .. Std.string(h); end
    return _hx_3
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = Std.string("0") .. Std.string(mi); else 
    _hx_4 = Std.string("") .. Std.string(mi); end
    return _hx_4
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = Std.string("0") .. Std.string(s); else 
    _hx_5 = Std.string("") .. Std.string(s); end
    return _hx_5
  end )())) end;
end
__lua_Boot.clampInt32 = function(x) 
  do return _hx_bit_clamp(x) end;
end
__lua_Boot.strDate = function(s) 
  local _g = __lua_lib_luautf8_Utf8.len(s);
  if (_g) == 8 then 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(s, ":", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len(":");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
        idx = nil;
      end;
    end;
    local k = ret;
    local t = ((_G.tonumber(k[0]) * 3600000.) + (_G.tonumber(k[1]) * 60000.)) + (_G.tonumber(k[2]) * 1000.);
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    do return d end;
  elseif (_g) == 10 then 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len("-") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(s, "-", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len("-");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
        idx = nil;
      end;
    end;
    local k = ret;
    do return Date.new(_G.tonumber(k[0]), _G.tonumber(k[1]) - 1, _G.tonumber(k[2]), 0, 0, 0) end;
  elseif (_g) == 19 then 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len(" ") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(s, " ", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len(" ");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
        idx = nil;
      end;
    end;
    local k = ret;
    local _this = k[0];
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len("-") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(_this, "-", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len("-");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
        idx = nil;
      end;
    end;
    local y = ret;
    local _this = k[1];
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(_this, ":", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len(":");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
        idx = nil;
      end;
    end;
    local t = ret;
    do return Date.new(_G.tonumber(y[0]), _G.tonumber(y[1]) - 1, _G.tonumber(y[2]), _G.tonumber(t[0]), _G.tonumber(t[1]), _G.tonumber(t[2])) end;else
  _G.error(__haxe_Exception.thrown(Std.string("Invalid date format : ") .. Std.string(s)),0); end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end
__lua_Boot.shellEscapeCmd = function(cmd,args) 
  if (args ~= nil) then 
    if (Sys.systemName() == "Windows") then 
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = _hx_tab_array({[0]=StringTools.replace(cmd, "/", "\\")}, 1):concat(args);
      while (_g1 < _g2.length) do 
        local a = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(__haxe_SysTools.quoteWinArg(a, true));
      end;
      cmd = _g:join(" ");
    else
      local f = __haxe_SysTools.quoteUnixArg;
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = _hx_tab_array({[0]=cmd}, 1):concat(args);
      while (_g1 < _g2.length) do 
        local i = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(f(i));
      end;
      cmd = _g:join(" ");
    end;
  end;
  do return cmd end;
end
__lua_Boot.tempFile = function() 
  if (Sys.systemName() == "Windows") then 
    do return __haxe_io_Path.join(_hx_tab_array({[0]=_G.os.getenv("TMP"), _G.os.tmpname()}, 2)) end;
  else
    do return _G.os.tmpname() end;
  end;
end
__lua_Boot.systemName = function() 
  local os = nil;
  if ((jit ~= nil) and (jit.os ~= nil)) then 
    os = jit.os;
    os = __lua_lib_luautf8_Utf8.lower(os);
  else
    local popen_status = false;
    local popen_result = nil;
    popen_status, popen_result = pcall(_G.io.popen, '');
    if (popen_status) then 
      popen_result:close();
      os = __lua_lib_luautf8_Utf8.lower(_G.io.popen("uname -s", "r"):read("*l"));
    else
      os = __lua_lib_luautf8_Utf8.lower(_G.os.getenv("OS"));
    end;
  end;
  local k = __lua_Boot.os_patterns:keys();
  while (k:hasNext()) do 
    local k = k:next();
    local _g = 0;
    local ret = __lua_Boot.os_patterns.h[k];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local _g1 = ret;
    while (_g < _g1.length) do 
      local p = _g1[_g];
      _g = _g + 1;
      if (_G.string.match(os, p) ~= nil) then 
        do return k end;
      end;
    end;
  end;
  do return nil end;
end

__lua_Thread.new = {}
_hxClasses["lua.Thread"] = __lua_Thread
__lua_Thread.__name__ = "lua.Thread"

__lua_UserData.new = {}
_hxClasses["lua.UserData"] = __lua_UserData
__lua_UserData.__name__ = "lua.UserData"

__blub_prolog_builtins_Globals.new = {}
_hxClasses["blub.prolog.builtins.Globals"] = __blub_prolog_builtins_Globals
__blub_prolog_builtins_Globals.__name__ = "blub.prolog.builtins.Globals"
__blub_prolog_builtins_Globals.get = function() 
  do return _hx_tab_array({[0]=__blub_prolog_builtins_GetGlobal.new(), __blub_prolog_builtins_SetGlobal.new()}, 2) end;
end

__blub_prolog_builtins_GetGlobal.new = function() 
  local self = _hx_new(__blub_prolog_builtins_GetGlobal.prototype)
  __blub_prolog_builtins_GetGlobal.super(self)
  return self
end
__blub_prolog_builtins_GetGlobal.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"from_global",2);
end
_hxClasses["blub.prolog.builtins.GetGlobal"] = __blub_prolog_builtins_GetGlobal
__blub_prolog_builtins_GetGlobal.__name__ = "blub.prolog.builtins.GetGlobal"
__blub_prolog_builtins_GetGlobal.prototype = _hx_e();
__blub_prolog_builtins_GetGlobal.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env):dereference();
  local b = args[1]:toValue(env):dereference();
  local key = b:asAtom();
  if (b == nil) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom("RHS of from_global must be atom key"), engine.context));
    do return end;
  end;
  local this1 = engine.database.globals;
  local key = b:asAtom().text;
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local value = ret;
  if (value == nil) then 
    value = __blub_prolog_AtomContext.GLOBALS:getAtom("null");
  end;
  engine:unify(a, value);
end

__blub_prolog_builtins_GetGlobal.prototype.__class__ =  __blub_prolog_builtins_GetGlobal
__blub_prolog_builtins_GetGlobal.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_GetGlobal.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_SetGlobal.new = function() 
  local self = _hx_new(__blub_prolog_builtins_SetGlobal.prototype)
  __blub_prolog_builtins_SetGlobal.super(self)
  return self
end
__blub_prolog_builtins_SetGlobal.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"to_global",2);
end
_hxClasses["blub.prolog.builtins.SetGlobal"] = __blub_prolog_builtins_SetGlobal
__blub_prolog_builtins_SetGlobal.__name__ = "blub.prolog.builtins.SetGlobal"
__blub_prolog_builtins_SetGlobal.prototype = _hx_e();
__blub_prolog_builtins_SetGlobal.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env):dereference();
  local b = args[1]:toValue(env):dereference();
  local key = b:asAtom();
  if (b == nil) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom("RHS of to_global must be atom key"), engine.context));
    do return end;
  end;
  local key = key.text;
  local _this = engine.database.globals;
  if (a == nil) then 
    _this.h[key] = __haxe_ds_StringMap.tnull;
  else
    _this.h[key] = a;
  end;
end

__blub_prolog_builtins_SetGlobal.prototype.__class__ =  __blub_prolog_builtins_SetGlobal
__blub_prolog_builtins_SetGlobal.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_SetGlobal.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_RebindVar.new = function(name) 
  local self = _hx_new(__blub_prolog_builtins_RebindVar.prototype)
  __blub_prolog_builtins_RebindVar.super(self,name)
  return self
end
__blub_prolog_builtins_RebindVar.super = function(self,name) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,name,2);
end
_hxClasses["blub.prolog.builtins.RebindVar"] = __blub_prolog_builtins_RebindVar
__blub_prolog_builtins_RebindVar.__name__ = "blub.prolog.builtins.RebindVar"
__blub_prolog_builtins_RebindVar.get = function() 
  do return _hx_tab_array({[0]=__blub_prolog_builtins_NonBacktrackingRebindVar.new(), __blub_prolog_builtins_BacktrackingRebindVar.new(), __blub_prolog_builtins_NonBacktrackingArithmeticRebind.new(), __blub_prolog_builtins_BacktrackingArithmeticRebind.new()}, 4) end;
end
__blub_prolog_builtins_RebindVar.prototype = _hx_e();
__blub_prolog_builtins_RebindVar.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local ref = args[0]:toValue(env);
  local val = args[1]:toValue(env):dereference();
  local targetRef = ref:asUnchasedReference();
  if (targetRef == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_variable, ref, engine.context));
    do return end;
  end;
  self:bind(targetRef, val, engine);
end
__blub_prolog_builtins_RebindVar.prototype.bind = function(self,targetRef,value,engine) 
  targetRef:rebindLast(value);
end

__blub_prolog_builtins_RebindVar.prototype.__class__ =  __blub_prolog_builtins_RebindVar
__blub_prolog_builtins_RebindVar.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_RebindVar.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_NonBacktrackingRebindVar.new = function() 
  local self = _hx_new(__blub_prolog_builtins_NonBacktrackingRebindVar.prototype)
  __blub_prolog_builtins_NonBacktrackingRebindVar.super(self)
  return self
end
__blub_prolog_builtins_NonBacktrackingRebindVar.super = function(self) 
  __blub_prolog_builtins_RebindVar.super(self,"<=");
end
_hxClasses["blub.prolog.builtins.NonBacktrackingRebindVar"] = __blub_prolog_builtins_NonBacktrackingRebindVar
__blub_prolog_builtins_NonBacktrackingRebindVar.__name__ = "blub.prolog.builtins.NonBacktrackingRebindVar"
__blub_prolog_builtins_NonBacktrackingRebindVar.prototype = _hx_e();

__blub_prolog_builtins_NonBacktrackingRebindVar.prototype.__class__ =  __blub_prolog_builtins_NonBacktrackingRebindVar
__blub_prolog_builtins_NonBacktrackingRebindVar.__super__ = __blub_prolog_builtins_RebindVar
setmetatable(__blub_prolog_builtins_NonBacktrackingRebindVar.prototype,{__index=__blub_prolog_builtins_RebindVar.prototype})

__blub_prolog_builtins_BacktrackingRebindVar.new = function() 
  local self = _hx_new(__blub_prolog_builtins_BacktrackingRebindVar.prototype)
  __blub_prolog_builtins_BacktrackingRebindVar.super(self)
  return self
end
__blub_prolog_builtins_BacktrackingRebindVar.super = function(self) 
  __blub_prolog_builtins_RebindVar.super(self,"<=&");
end
_hxClasses["blub.prolog.builtins.BacktrackingRebindVar"] = __blub_prolog_builtins_BacktrackingRebindVar
__blub_prolog_builtins_BacktrackingRebindVar.__name__ = "blub.prolog.builtins.BacktrackingRebindVar"
__blub_prolog_builtins_BacktrackingRebindVar.prototype = _hx_e();
__blub_prolog_builtins_BacktrackingRebindVar.prototype.bind = function(self,targetRef,value,engine) 
  targetRef:rebindLast(value, engine);
end

__blub_prolog_builtins_BacktrackingRebindVar.prototype.__class__ =  __blub_prolog_builtins_BacktrackingRebindVar
__blub_prolog_builtins_BacktrackingRebindVar.__super__ = __blub_prolog_builtins_RebindVar
setmetatable(__blub_prolog_builtins_BacktrackingRebindVar.prototype,{__index=__blub_prolog_builtins_RebindVar.prototype})

__blub_prolog_builtins_ArithmeticRebind.new = function(name) 
  local self = _hx_new(__blub_prolog_builtins_ArithmeticRebind.prototype)
  __blub_prolog_builtins_ArithmeticRebind.super(self,name)
  return self
end
__blub_prolog_builtins_ArithmeticRebind.super = function(self,name) 
  __blub_prolog_builtins_RebindVar.super(self,name);
end
_hxClasses["blub.prolog.builtins.ArithmeticRebind"] = __blub_prolog_builtins_ArithmeticRebind
__blub_prolog_builtins_ArithmeticRebind.__name__ = "blub.prolog.builtins.ArithmeticRebind"
__blub_prolog_builtins_ArithmeticRebind.prototype = _hx_e();
__blub_prolog_builtins_ArithmeticRebind.prototype.bind = function(self,targetRef,value,engine) 
  local num = value:asNumber();
  if (num == nil) then 
    num = __blub_prolog_terms_NumberTerm.new(engine:get_arithmetic():evaluate(value));
  end;
  self:bindNum(targetRef, num, engine);
end
__blub_prolog_builtins_ArithmeticRebind.prototype.bindNum = function(self,targetRef,value,engine) 
  targetRef:rebindLast(value);
end

__blub_prolog_builtins_ArithmeticRebind.prototype.__class__ =  __blub_prolog_builtins_ArithmeticRebind
__blub_prolog_builtins_ArithmeticRebind.__super__ = __blub_prolog_builtins_RebindVar
setmetatable(__blub_prolog_builtins_ArithmeticRebind.prototype,{__index=__blub_prolog_builtins_RebindVar.prototype})

__blub_prolog_builtins_NonBacktrackingArithmeticRebind.new = function() 
  local self = _hx_new(__blub_prolog_builtins_NonBacktrackingArithmeticRebind.prototype)
  __blub_prolog_builtins_NonBacktrackingArithmeticRebind.super(self)
  return self
end
__blub_prolog_builtins_NonBacktrackingArithmeticRebind.super = function(self) 
  __blub_prolog_builtins_ArithmeticRebind.super(self,"<#");
end
_hxClasses["blub.prolog.builtins.NonBacktrackingArithmeticRebind"] = __blub_prolog_builtins_NonBacktrackingArithmeticRebind
__blub_prolog_builtins_NonBacktrackingArithmeticRebind.__name__ = "blub.prolog.builtins.NonBacktrackingArithmeticRebind"
__blub_prolog_builtins_NonBacktrackingArithmeticRebind.prototype = _hx_e();

__blub_prolog_builtins_NonBacktrackingArithmeticRebind.prototype.__class__ =  __blub_prolog_builtins_NonBacktrackingArithmeticRebind
__blub_prolog_builtins_NonBacktrackingArithmeticRebind.__super__ = __blub_prolog_builtins_ArithmeticRebind
setmetatable(__blub_prolog_builtins_NonBacktrackingArithmeticRebind.prototype,{__index=__blub_prolog_builtins_ArithmeticRebind.prototype})

__blub_prolog_builtins_BacktrackingArithmeticRebind.new = function() 
  local self = _hx_new(__blub_prolog_builtins_BacktrackingArithmeticRebind.prototype)
  __blub_prolog_builtins_BacktrackingArithmeticRebind.super(self)
  return self
end
__blub_prolog_builtins_BacktrackingArithmeticRebind.super = function(self) 
  __blub_prolog_builtins_ArithmeticRebind.super(self,"<#&");
end
_hxClasses["blub.prolog.builtins.BacktrackingArithmeticRebind"] = __blub_prolog_builtins_BacktrackingArithmeticRebind
__blub_prolog_builtins_BacktrackingArithmeticRebind.__name__ = "blub.prolog.builtins.BacktrackingArithmeticRebind"
__blub_prolog_builtins_BacktrackingArithmeticRebind.prototype = _hx_e();
__blub_prolog_builtins_BacktrackingArithmeticRebind.prototype.bindNum = function(self,targetRef,value,engine) 
  targetRef:rebindLast(value, engine);
end

__blub_prolog_builtins_BacktrackingArithmeticRebind.prototype.__class__ =  __blub_prolog_builtins_BacktrackingArithmeticRebind
__blub_prolog_builtins_BacktrackingArithmeticRebind.__super__ = __blub_prolog_builtins_ArithmeticRebind
setmetatable(__blub_prolog_builtins_BacktrackingArithmeticRebind.prototype,{__index=__blub_prolog_builtins_ArithmeticRebind.prototype})

__blub_prolog_builtins_objects_ObjectBuiltins.new = {}
_hxClasses["blub.prolog.builtins.objects.ObjectBuiltins"] = __blub_prolog_builtins_objects_ObjectBuiltins
__blub_prolog_builtins_objects_ObjectBuiltins.__name__ = "blub.prolog.builtins.objects.ObjectBuiltins"
__blub_prolog_builtins_objects_ObjectBuiltins.get = function() 
  do return _hx_tab_array({[0]=__blub_prolog_builtins_objects_DotAccessor.new(), __blub_prolog_builtins_objects_ArrowAssigner.new()}, 2) end;
end

__blub_prolog_builtins_objects_DotAccessor.new = function() 
  local self = _hx_new(__blub_prolog_builtins_objects_DotAccessor.prototype)
  __blub_prolog_builtins_objects_DotAccessor.super(self)
  return self
end
__blub_prolog_builtins_objects_DotAccessor.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,".",2);
end
_hxClasses["blub.prolog.builtins.objects.DotAccessor"] = __blub_prolog_builtins_objects_DotAccessor
__blub_prolog_builtins_objects_DotAccessor.__name__ = "blub.prolog.builtins.objects.DotAccessor"
__blub_prolog_builtins_objects_DotAccessor.evalDot = function(engine,termA,termB) 
  local stru = termA:asStructure();
  if (((stru ~= nil) and (stru:getName().text == ".")) and (stru:getArity() == 2)) then 
    termA = __blub_prolog_Marshal.valueToTerm(__blub_prolog_builtins_objects_DotAccessor.evalDot(engine, stru:argAt(0), stru:argAt(1)));
  end;
  local atom = termA:asAtom();
  if (atom == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string(Std.string(Std.string("is not an atom: ") .. Std.string(Std.string(termA))) .. Std.string(" in ")) .. Std.string(Std.string(termA))) .. Std.string(".")) .. Std.string(Std.string(termB))),0);
  end;
  if (atom.object == nil) then 
    atom.object = __blub_prolog_builtins_objects_HashObjectWrapper.new(atom);
  end;
  if (not __lua_Boot.__instanceof(atom.object, __blub_prolog_builtins_objects_ObjectWrapper)) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string(Std.string(Std.string("is not an atom wrapping a native object: ") .. Std.string(Std.string(termA))) .. Std.string(" in ")) .. Std.string(Std.string(termA))) .. Std.string(".")) .. Std.string(Std.string(termB))),0);
  end;
  local wrapper = atom.object;
  local nameAtom = termB:asAtom();
  if (nameAtom ~= nil) then 
    local name = nameAtom.text;
    do return wrapper:getProperty(name) end;
  end;
  local method = termB:asStructure();
  if (method ~= nil) then 
    local args = __blub_prolog_builtins_objects_DotAccessor.makeArgs(engine, method:getArgs());
    do return wrapper:callMethod(method:getName().text, args) end;
  end;
  _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string(Std.string(Std.string("is not a field name or method call: ") .. Std.string(Std.string(termB))) .. Std.string(" in ")) .. Std.string(Std.string(termA))) .. Std.string(".")) .. Std.string(Std.string(termB))),0);
end
__blub_prolog_builtins_objects_DotAccessor.eval = function(engine,expr) 
  local stru = expr:asStructure();
  if (stru ~= nil) then 
    if ((stru:getArity() == 1) and (stru:getNameText() == "term")) then 
      do return stru:argAt(0) end;
    end;
    if (__blub_prolog_engine_ArithmeticEvaluator.isArithmetic(stru)) then 
      do return engine:get_arithmetic():evalFunc(stru) end;
    end;
    if ((stru:getName().text == ".") and (stru:getArity() == 2)) then 
      do return __blub_prolog_builtins_objects_DotAccessor.evalDot(engine, stru:argAt(0), stru:argAt(1)) end;
    else
      local className = stru:getName().text;
      local clazz = Type.resolveClass(className);
      if (clazz == nil) then 
        _G.error(__haxe_Exception.thrown(Std.string("Could not find class ") .. Std.string(className)),0);
      end;
      local args = __blub_prolog_builtins_objects_DotAccessor.makeArgs(engine, stru:getArgs());
      do return Type.createInstance(clazz, args) end;
    end;
  end;
  do return __blub_prolog_Marshal.termToValue(expr) end;
end
__blub_prolog_builtins_objects_DotAccessor.makeArgs = function(engine,terms) 
  local args = Array.new();
  if (terms.length == 1) then 
    local arg1 = terms[0]:asAtom();
    if ((arg1 ~= nil) and (arg1.text == "void")) then 
      do return args end;
    end;
  end;
  local _g = 0;
  while (_g < terms.length) do 
    local t = terms[_g];
    _g = _g + 1;
    args:push(__blub_prolog_builtins_objects_DotAccessor.eval(engine, t:asValueTerm()));
  end;
  do return args end;
end
__blub_prolog_builtins_objects_DotAccessor.prototype = _hx_e();
__blub_prolog_builtins_objects_DotAccessor.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env):dereference();
  local b = args[1]:toValue(env):dereference();
  __blub_prolog_builtins_objects_DotAccessor.evalDot(engine, a, b);
end

__blub_prolog_builtins_objects_DotAccessor.prototype.__class__ =  __blub_prolog_builtins_objects_DotAccessor
__blub_prolog_builtins_objects_DotAccessor.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_objects_DotAccessor.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_objects_ArrowAssigner.new = function() 
  local self = _hx_new(__blub_prolog_builtins_objects_ArrowAssigner.prototype)
  __blub_prolog_builtins_objects_ArrowAssigner.super(self)
  return self
end
__blub_prolog_builtins_objects_ArrowAssigner.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"<-",2);
end
_hxClasses["blub.prolog.builtins.objects.ArrowAssigner"] = __blub_prolog_builtins_objects_ArrowAssigner
__blub_prolog_builtins_objects_ArrowAssigner.__name__ = "blub.prolog.builtins.objects.ArrowAssigner"
__blub_prolog_builtins_objects_ArrowAssigner.prototype = _hx_e();
__blub_prolog_builtins_objects_ArrowAssigner.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local a = args[0]:toValue(env):dereference();
  local b = args[1]:toValue(env):dereference();
  local value = nil;
  local _hx_status, _hx_result = pcall(function() 
  
      value = __blub_prolog_builtins_objects_DotAccessor.eval(engine, b);
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    local e = __haxe_Exception.caught(_g):unwrap();
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom(Std.string(e)), engine.context));
    do return end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  if (a:asReference() ~= nil) then 
    local valTerm = __blub_prolog_Marshal.valueToTerm(value);
    engine:unify(a, valTerm);
    do return end;
  end;
  local target = a:asStructure();
  if (((target == nil) or (target:getName().text ~= ".")) or (target:getArity() ~= 2)) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom(Std.string("target of <- must be a var or dot-accessor: ") .. Std.string(a:toString())), engine.context));
    do return end;
  end;
  local atom = nil;
  local lhsRef = target:argAt(0):asReference();
  if (lhsRef ~= nil) then 
    atom = __blub_prolog_Marshal.newAtom();
    engine:unify(lhsRef, atom);
  else
    atom = target:argAt(0):asAtom();
  end;
  if (atom == nil) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom(Std.string(Std.string(Std.string("is not an atom: ") .. Std.string(Std.string(target:argAt(0)))) .. Std.string(" in ")) .. Std.string(target:toString())), engine.context));
    do return end;
  end;
  if (atom.object == nil) then 
    atom.object = __blub_prolog_builtins_objects_HashObjectWrapper.new(atom);
  end;
  if (not __lua_Boot.__instanceof(atom.object, __blub_prolog_builtins_objects_ObjectWrapper)) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom(Std.string(Std.string(Std.string("is not an atom wrapping a native object: ") .. Std.string(Std.string(atom))) .. Std.string(" in ")) .. Std.string(target:toString())), engine.context));
    do return end;
  end;
  local nameAtom = target:argAt(1):asAtom();
  if (nameAtom == nil) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom(Std.string(Std.string(Std.string("is not an atom representing a field name: ") .. Std.string(Std.string(target:argAt(1)))) .. Std.string(" in ")) .. Std.string(target:toString())), engine.context));
    do return end;
  end;
  local name = nameAtom.text;
  local wrapper = atom.object;
  wrapper:setProperty(name, value);
end

__blub_prolog_builtins_objects_ArrowAssigner.prototype.__class__ =  __blub_prolog_builtins_objects_ArrowAssigner
__blub_prolog_builtins_objects_ArrowAssigner.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_objects_ArrowAssigner.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_async_AsyncBuiltins.new = {}
_hxClasses["blub.prolog.builtins.async.AsyncBuiltins"] = __blub_prolog_builtins_async_AsyncBuiltins
__blub_prolog_builtins_async_AsyncBuiltins.__name__ = "blub.prolog.builtins.async.AsyncBuiltins"
__blub_prolog_builtins_async_AsyncBuiltins.get = function() 
  local send = __blub_prolog_builtins_async_messages_Send.new();
  local receive = __blub_prolog_builtins_async_messages_Receive.new(send.channels);
  do return _hx_tab_array({[0]=__blub_prolog_builtins_async_Sleep.new(), send, receive, __blub_prolog_builtins_async_Spawn.new(), __blub_prolog_builtins_async_Spawns.new(), __blub_prolog_builtins_async_Stop.new()}, 6) end;
end

__blub_prolog_builtins_async_messages_Send.new = function() 
  local self = _hx_new(__blub_prolog_builtins_async_messages_Send.prototype)
  __blub_prolog_builtins_async_messages_Send.super(self)
  return self
end
__blub_prolog_builtins_async_messages_Send.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"send",2);
  self.channels = __haxe_ds_StringMap.new();
end
_hxClasses["blub.prolog.builtins.async.messages.Send"] = __blub_prolog_builtins_async_messages_Send
__blub_prolog_builtins_async_messages_Send.__name__ = "blub.prolog.builtins.async.messages.Send"
__blub_prolog_builtins_async_messages_Send.prototype = _hx_e();
__blub_prolog_builtins_async_messages_Send.prototype.channels= nil;
__blub_prolog_builtins_async_messages_Send.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local channel = args[0]:toValue(env):asAtom();
  local msg = args[1]:toValue(env):dereference();
  if (channel == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_atom, channel, engine.context));
  end;
  if (msg:isGround()) then 
    local ret = self.channels.h[channel.text];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local msgChannel = ret;
    if (msgChannel == nil) then 
      do return end;
    end;
    msgChannel:send(msg);
    do return end;
  end;
  engine:raiseException(__blub_prolog_RuntimeError.instantiationError(engine.context));
end

__blub_prolog_builtins_async_messages_Send.prototype.__class__ =  __blub_prolog_builtins_async_messages_Send
__blub_prolog_builtins_async_messages_Send.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_async_messages_Send.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_async_messages_Receive.new = function(channels) 
  local self = _hx_new(__blub_prolog_builtins_async_messages_Receive.prototype)
  __blub_prolog_builtins_async_messages_Receive.super(self,channels)
  return self
end
__blub_prolog_builtins_async_messages_Receive.super = function(self,channels) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"receive",2);
  self.channels = channels;
end
_hxClasses["blub.prolog.builtins.async.messages.Receive"] = __blub_prolog_builtins_async_messages_Receive
__blub_prolog_builtins_async_messages_Receive.__name__ = "blub.prolog.builtins.async.messages.Receive"
__blub_prolog_builtins_async_messages_Receive.prototype = _hx_e();
__blub_prolog_builtins_async_messages_Receive.prototype.channels= nil;
__blub_prolog_builtins_async_messages_Receive.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local channel = args[0]:toValue(env):asAtom();
  local msg = args[1]:toValue(env):dereference();
  if (channel == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_atom, channel, engine.context));
  end;
  local ret = self.channels.h[channel.text];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local msgChannel = ret;
  if (msgChannel == nil) then 
    msgChannel = __blub_prolog_builtins_async_messages_MessageChannel.new(channel.text, self.channels);
  end;
  local listener = msgChannel:listen(engine, msg);
  engine:beginAsync(__blub_prolog_builtins_async_AsyncOperationImpl.new(Std.string(Std.string(Std.string(Std.string("receive(") .. Std.string(channel.text)) .. Std.string(",")) .. Std.string(Std.string(_hx_bind(msg,msg.toString)))) .. Std.string(")"), function() 
    msgChannel:unlisten(listener);
  end));
end

__blub_prolog_builtins_async_messages_Receive.prototype.__class__ =  __blub_prolog_builtins_async_messages_Receive
__blub_prolog_builtins_async_messages_Receive.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_async_messages_Receive.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_async_Sleep.new = function() 
  local self = _hx_new(__blub_prolog_builtins_async_Sleep.prototype)
  __blub_prolog_builtins_async_Sleep.super(self)
  return self
end
__blub_prolog_builtins_async_Sleep.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"sleep",1);
end
_hxClasses["blub.prolog.builtins.async.Sleep"] = __blub_prolog_builtins_async_Sleep
__blub_prolog_builtins_async_Sleep.__name__ = "blub.prolog.builtins.async.Sleep"
__blub_prolog_builtins_async_Sleep.prototype = _hx_e();
__blub_prolog_builtins_async_Sleep.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local time = args[0]:toValue(env):asNumber();
  if (time == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_number, time, engine.context));
  end;
  local millis = Std.int(time.value);
  engine:beginAsync(__blub_prolog_builtins_async_AsyncOperationImpl.new(Std.string(Std.string("sleep(") .. Std.string(millis)) .. Std.string(")"), nil));
  __haxe_Timer.delay(function() 
    engine:continueAsync();
  end, millis);
end

__blub_prolog_builtins_async_Sleep.prototype.__class__ =  __blub_prolog_builtins_async_Sleep
__blub_prolog_builtins_async_Sleep.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_async_Sleep.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_async_Spawn.new = function() 
  local self = _hx_new(__blub_prolog_builtins_async_Spawn.prototype)
  __blub_prolog_builtins_async_Spawn.super(self)
  return self
end
__blub_prolog_builtins_async_Spawn.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"spawn",1);
end
_hxClasses["blub.prolog.builtins.async.Spawn"] = __blub_prolog_builtins_async_Spawn
__blub_prolog_builtins_async_Spawn.__name__ = "blub.prolog.builtins.async.Spawn"
__blub_prolog_builtins_async_Spawn.prototype = _hx_e();
__blub_prolog_builtins_async_Spawn.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local queryArg = args[0]:toValue(env):dereference();
  local stru = queryArg:asStructure();
  if (stru ~= nil) then 
    if (stru:getName().text == "{}") then 
      queryArg = stru:argAt(0):asValueTerm();
      stru = queryArg:asStructure();
      if (stru ~= nil) then 
        queryArg = stru:variablize();
      end;
    else
      queryArg = stru:variablize();
    end;
  end;
  if (not __lua_Boot.__instanceof(queryArg, __blub_prolog_terms_ClauseTerm)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, queryArg, engine.context));
  end;
  local query = __blub_prolog_async_AsyncQuery.new(engine.database, queryArg);
  query:execute();
end

__blub_prolog_builtins_async_Spawn.prototype.__class__ =  __blub_prolog_builtins_async_Spawn
__blub_prolog_builtins_async_Spawn.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_async_Spawn.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_async_Spawns.new = function() 
  local self = _hx_new(__blub_prolog_builtins_async_Spawns.prototype)
  __blub_prolog_builtins_async_Spawns.super(self)
  return self
end
__blub_prolog_builtins_async_Spawns.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"spawns",2);
  self.count = 0;
end
_hxClasses["blub.prolog.builtins.async.Spawns"] = __blub_prolog_builtins_async_Spawns
__blub_prolog_builtins_async_Spawns.__name__ = "blub.prolog.builtins.async.Spawns"
__blub_prolog_builtins_async_Spawns.prototype = _hx_e();
__blub_prolog_builtins_async_Spawns.prototype.count= nil;
__blub_prolog_builtins_async_Spawns.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local ref = args[0]:toValue(env):asReference();
  local queryArg = args[1]:toValue(env):dereference();
  if (ref == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_variable, args[0], engine.context));
  end;
  local stru = queryArg:asStructure();
  if (stru ~= nil) then 
    if (stru:getName().text == "{}") then 
      queryArg = stru:argAt(0):asValueTerm();
      stru = queryArg:asStructure();
      if (stru ~= nil) then 
        queryArg = stru:variablize();
      end;
    else
      queryArg = stru:variablize();
    end;
  end;
  if (not __lua_Boot.__instanceof(queryArg, __blub_prolog_terms_ClauseTerm)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, queryArg, engine.context));
  end;
  local query = __blub_prolog_async_AsyncQuery.new(engine.database, queryArg);
  query:execute();
  local atom = Std.string("spawned-query#") .. Std.string((function() 
  local _hx_obj = self;
  local _hx_fld = 'count';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)());
  local atom = __blub_prolog_terms_Atom.unregisteredAtom(atom);
  atom.object = query:get_engine();
  engine:unify(ref, atom);
end

__blub_prolog_builtins_async_Spawns.prototype.__class__ =  __blub_prolog_builtins_async_Spawns
__blub_prolog_builtins_async_Spawns.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_async_Spawns.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_async_Stop.new = function() 
  local self = _hx_new(__blub_prolog_builtins_async_Stop.prototype)
  __blub_prolog_builtins_async_Stop.super(self)
  return self
end
__blub_prolog_builtins_async_Stop.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"stop",1);
end
_hxClasses["blub.prolog.builtins.async.Stop"] = __blub_prolog_builtins_async_Stop
__blub_prolog_builtins_async_Stop.__name__ = "blub.prolog.builtins.async.Stop"
__blub_prolog_builtins_async_Stop.prototype = _hx_e();
__blub_prolog_builtins_async_Stop.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local atom = args[0]:toValue(env):asAtom();
  if (atom == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_atom, args[0], engine.context));
  end;
  if ((atom.object == nil) or not __lua_Boot.__instanceof(atom.object, __blub_prolog_engine_QueryEngine)) then 
    engine:raiseException(__blub_prolog_PrologException.new(__blub_prolog_terms_Atom.unregisteredAtom(Std.string("atom must contain a spawned query: ") .. Std.string(Std.string(atom))), engine.context));
    do return end;
  end;
  local eng2 = atom.object;
  eng2:halt();
end

__blub_prolog_builtins_async_Stop.prototype.__class__ =  __blub_prolog_builtins_async_Stop
__blub_prolog_builtins_async_Stop.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_async_Stop.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_meta_MetaBuiltins.new = {}
_hxClasses["blub.prolog.builtins.meta.MetaBuiltins"] = __blub_prolog_builtins_meta_MetaBuiltins
__blub_prolog_builtins_meta_MetaBuiltins.__name__ = "blub.prolog.builtins.meta.MetaBuiltins"
__blub_prolog_builtins_meta_MetaBuiltins.get = function() 
  do return _hx_tab_array({[0]=__blub_prolog_builtins_meta_MetaAbort.new(), __blub_prolog_builtins_meta_MetaQuery.new(), __blub_prolog_builtins_meta_MetaSolution.new()}, 3) end;
end

__blub_prolog_builtins_meta_MetaAbort.new = function() 
  local self = _hx_new(__blub_prolog_builtins_meta_MetaAbort.prototype)
  __blub_prolog_builtins_meta_MetaAbort.super(self)
  return self
end
__blub_prolog_builtins_meta_MetaAbort.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"abort",1);
end
_hxClasses["blub.prolog.builtins.meta.MetaAbort"] = __blub_prolog_builtins_meta_MetaAbort
__blub_prolog_builtins_meta_MetaAbort.__name__ = "blub.prolog.builtins.meta.MetaAbort"
__blub_prolog_builtins_meta_MetaAbort.prototype = _hx_e();
__blub_prolog_builtins_meta_MetaAbort.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local atom = args[0]:toValue(env):dereference():asAtom();
  if ((atom == nil) or (atom.object == nil)) then 
    do return end;
  end;
  if (not __lua_Boot.__instanceof(atom.object, __blub_prolog_builtins_meta_TemplateQuery)) then 
    do return end;
  end;
  local query = atom.object;
  query:halt();
  atom.object = nil;
end

__blub_prolog_builtins_meta_MetaAbort.prototype.__class__ =  __blub_prolog_builtins_meta_MetaAbort
__blub_prolog_builtins_meta_MetaAbort.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_meta_MetaAbort.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_meta_MetaQuery.new = function() 
  local self = _hx_new(__blub_prolog_builtins_meta_MetaQuery.prototype)
  __blub_prolog_builtins_meta_MetaQuery.super(self)
  return self
end
__blub_prolog_builtins_meta_MetaQuery.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"query",3);
end
_hxClasses["blub.prolog.builtins.meta.MetaQuery"] = __blub_prolog_builtins_meta_MetaQuery
__blub_prolog_builtins_meta_MetaQuery.__name__ = "blub.prolog.builtins.meta.MetaQuery"
__blub_prolog_builtins_meta_MetaQuery.prototype = _hx_e();
__blub_prolog_builtins_meta_MetaQuery.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local queryTerm = args[0]:toValue(env):dereference();
  local template = args[1]:toValue(env):dereference();
  local queryVar = args[2]:toValue(env):dereference();
  if (queryVar:asReference() == nil) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_variable, queryVar, engine.context));
    do return end;
  end;
  if (not __lua_Boot.__instanceof(queryTerm, __blub_prolog_terms_ClauseTerm)) then 
    engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_callable, queryTerm, engine.context));
    do return end;
  end;
  local queryClause = queryTerm;
  local query = __blub_prolog_builtins_meta_TemplateQuery.new(engine, queryClause, template);
  local atom = __blub_prolog_terms_Atom.unregisteredAtom("query:");
  atom.object = query;
  engine:unify(queryVar, atom);
end

__blub_prolog_builtins_meta_MetaQuery.prototype.__class__ =  __blub_prolog_builtins_meta_MetaQuery
__blub_prolog_builtins_meta_MetaQuery.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_meta_MetaQuery.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_meta_MetaSolution.new = function() 
  local self = _hx_new(__blub_prolog_builtins_meta_MetaSolution.prototype)
  __blub_prolog_builtins_meta_MetaSolution.super(self)
  return self
end
__blub_prolog_builtins_meta_MetaSolution.super = function(self) 
  __blub_prolog_builtins_BuiltinPredicate.super(self,"solution",2);
end
_hxClasses["blub.prolog.builtins.meta.MetaSolution"] = __blub_prolog_builtins_meta_MetaSolution
__blub_prolog_builtins_meta_MetaSolution.__name__ = "blub.prolog.builtins.meta.MetaSolution"
__blub_prolog_builtins_meta_MetaSolution.prototype = _hx_e();
__blub_prolog_builtins_meta_MetaSolution.prototype.execute = function(self,engine,args) 
  local env = engine.environment;
  local queryAtom = args[0]:toValue(env):dereference():asAtom();
  local soln = args[1]:toValue(env):dereference();
  if (((queryAtom == nil) or (queryAtom.object == nil)) or not __lua_Boot.__instanceof(queryAtom.object, __blub_prolog_builtins_meta_TemplateQuery)) then 
    engine:fail();
    do return end;
  end;
  local query = queryAtom.object;
  if (not query:nextSolution(engine, soln)) then 
    engine:fail();
  end;
end

__blub_prolog_builtins_meta_MetaSolution.prototype.__class__ =  __blub_prolog_builtins_meta_MetaSolution
__blub_prolog_builtins_meta_MetaSolution.__super__ = __blub_prolog_builtins_BuiltinPredicate
setmetatable(__blub_prolog_builtins_meta_MetaSolution.prototype,{__index=__blub_prolog_builtins_BuiltinPredicate.prototype})

__blub_prolog_builtins_Builtins.new = {}
_hxClasses["blub.prolog.builtins.Builtins"] = __blub_prolog_builtins_Builtins
__blub_prolog_builtins_Builtins.__name__ = "blub.prolog.builtins.Builtins"
__blub_prolog_builtins_Builtins.register = function(database) 
  local _g = 0;
  local _g1 = __blub_prolog_builtins_Builtins.builtins;
  while (_g < _g1.length) do 
    local b = _g1[_g];
    _g = _g + 1;
    b:register(database);
  end;
end

__blub_prolog_builtins_NotCallable.new = function(culprit) 
  local self = _hx_new(__blub_prolog_builtins_NotCallable.prototype)
  __blub_prolog_builtins_NotCallable.super(self,culprit)
  return self
end
__blub_prolog_builtins_NotCallable.super = function(self,culprit) 
  self.culprit = culprit;
end
_hxClasses["blub.prolog.builtins.NotCallable"] = __blub_prolog_builtins_NotCallable
__blub_prolog_builtins_NotCallable.__name__ = "blub.prolog.builtins.NotCallable"
__blub_prolog_builtins_NotCallable.prototype = _hx_e();
__blub_prolog_builtins_NotCallable.prototype.culprit= nil;

__blub_prolog_builtins_NotCallable.prototype.__class__ =  __blub_prolog_builtins_NotCallable

__blub_prolog_compiler_CompilerBase.new = function(database) 
  local self = _hx_new(__blub_prolog_compiler_CompilerBase.prototype)
  __blub_prolog_compiler_CompilerBase.super(self,database)
  return self
end
__blub_prolog_compiler_CompilerBase.super = function(self,database) 
  self.database = database;
  self.instructions = Array.new();
end
_hxClasses["blub.prolog.compiler.CompilerBase"] = __blub_prolog_compiler_CompilerBase
__blub_prolog_compiler_CompilerBase.__name__ = "blub.prolog.compiler.CompilerBase"
__blub_prolog_compiler_CompilerBase.prototype = _hx_e();
__blub_prolog_compiler_CompilerBase.prototype.database= nil;
__blub_prolog_compiler_CompilerBase.prototype.instructions= nil;
__blub_prolog_compiler_CompilerBase.prototype.assemble = function(self) 
  local asm = __blub_prolog_compiler_Assembler.new(self.database);
  asm:translateList(self.instructions);
  do return asm.operations end
end
__blub_prolog_compiler_CompilerBase.prototype.clauseTerm = function(self,term) 
  if (not __lua_Boot.__instanceof(term, __blub_prolog_terms_ClauseTerm)) then 
    _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Bad clause term: ") .. Std.string(Std.string(term)))),0);
  end;
  do return term end
end
__blub_prolog_compiler_CompilerBase.prototype.compileTerm = function(self,term,tail) 
  if (tail == nil) then 
    tail = false;
  end;
  local stru = term:asStructure();
  local args = nil;
  if (stru ~= nil) then 
    local _g = term:getIndicator():toString();
    if (_g) == ",/2" then 
      self:compileConjunction(stru, tail);
      do return end;
    elseif (_g) == ";/2" then 
      self:compileDisjunction(stru, tail);
      do return end;else end;
    args = stru:getArgs();
  end;
  local pred = self.database:lookup(term:getIndicator());
  if (pred ~= nil) then 
    if (pred.isBuiltin) then 
      pred.builtin:compile(self, pred, term);
      if (tail) then 
        self:add(__blub_prolog_compiler_Instruction.succeed);
      end;
      do return end;
    end;
  end;
  if (tail) then 
    self:add(__blub_prolog_compiler_Instruction.tail_call(term:getIndicator():toString(), args));
  else
    self:add(__blub_prolog_compiler_Instruction.call_pred(term:getIndicator():toString(), args));
  end;
end
__blub_prolog_compiler_CompilerBase.prototype.compileNestedTerm = function(self,term,cutBarrier) 
  if (cutBarrier == nil) then 
    cutBarrier = false;
  end;
  local nestedCode = self:compileOther(self:clauseTerm(term), true);
  if (cutBarrier) then 
    nestedCode:unshift(__blub_prolog_compiler_Instruction.cut_point);
  end;
  self:add(__blub_prolog_compiler_Instruction.call_nested(nestedCode));
end
__blub_prolog_compiler_CompilerBase.prototype.compileConjunction = function(self,stru,tail) 
  if (tail == nil) then 
    tail = false;
  end;
  local t1 = self:clauseTerm(stru:argAt(0));
  local t2 = self:clauseTerm(stru:argAt(1));
  local t1s = t1:asStructure();
  if ((t1s ~= nil) and t1s:isDisjunction()) then 
    self:compileNestedTerm(t1);
  else
    self:compileTerm(t1, false);
  end;
  self:compileTerm(t2, tail);
end
__blub_prolog_compiler_CompilerBase.prototype.compileDisjunction = function(self,stru,tail) 
  if (tail == nil) then 
    tail = false;
  end;
  local t1 = self:clauseTerm(stru:argAt(0));
  local t2 = self:clauseTerm(stru:argAt(1));
  local alternative = self:compileOther(t2, tail);
  self:add(__blub_prolog_compiler_Instruction.choice_point(alternative));
  self:compileTerm(t1, tail);
end
__blub_prolog_compiler_CompilerBase.prototype.compileOther = function(self,term,tail) 
  if (tail == nil) then 
    tail = false;
  end;
  local altCompiler = __blub_prolog_compiler_CompilerBase.new(self.database);
  altCompiler:compileTerm(term, tail);
  do return altCompiler.instructions end
end
__blub_prolog_compiler_CompilerBase.prototype.add = function(self,instruction) 
  self.instructions:push(instruction);
end
__blub_prolog_compiler_CompilerBase.prototype.logOp = function(self,msg) 
  if (__blub_prolog_compiler_CompilerBase.ADD_LOGGING) then 
    self:add(__blub_prolog_compiler_Instruction.log(msg));
  end;
end

__blub_prolog_compiler_CompilerBase.prototype.__class__ =  __blub_prolog_compiler_CompilerBase

__blub_prolog_builtins_CallCompiler.new = function(engine) 
  local self = _hx_new(__blub_prolog_builtins_CallCompiler.prototype)
  __blub_prolog_builtins_CallCompiler.super(self,engine)
  return self
end
__blub_prolog_builtins_CallCompiler.super = function(self,engine) 
  __blub_prolog_compiler_CompilerBase.super(self,engine.database);
  self.eng = engine;
end
_hxClasses["blub.prolog.builtins.CallCompiler"] = __blub_prolog_builtins_CallCompiler
__blub_prolog_builtins_CallCompiler.__name__ = "blub.prolog.builtins.CallCompiler"
__blub_prolog_builtins_CallCompiler.prototype = _hx_e();
__blub_prolog_builtins_CallCompiler.prototype.eng= nil;
__blub_prolog_builtins_CallCompiler.prototype.compileCall = function(self,term) 
  local clause = self:clauseTerm(term);
  local stru = clause:asStructure();
  self:compileTerm(clause, true);
  do return self:assemble() end
end
__blub_prolog_builtins_CallCompiler.prototype.clauseTerm = function(self,term) 
  if (not __lua_Boot.__instanceof(term, __blub_prolog_terms_ClauseTerm)) then 
    _G.error(__haxe_Exception.thrown(__blub_prolog_builtins_NotCallable.new(term)),0);
  end;
  do return term end
end

__blub_prolog_builtins_CallCompiler.prototype.__class__ =  __blub_prolog_builtins_CallCompiler
__blub_prolog_builtins_CallCompiler.__super__ = __blub_prolog_compiler_CompilerBase
setmetatable(__blub_prolog_builtins_CallCompiler.prototype,{__index=__blub_prolog_compiler_CompilerBase.prototype})

__blub_prolog_builtins_MemberChoicePoint.new = function(eng,frame,arg1,arg2) 
  local self = _hx_new(__blub_prolog_builtins_MemberChoicePoint.prototype)
  __blub_prolog_builtins_MemberChoicePoint.super(self,eng,frame,arg1,arg2)
  return self
end
__blub_prolog_builtins_MemberChoicePoint.super = function(self,eng,frame,arg1,arg2) 
  __blub_prolog_engine_parts_ChoicePoint.super(self,eng,frame);
  self.arg1 = arg1;
  self.arg2 = arg2;
  self.clause = 0;
end
_hxClasses["blub.prolog.builtins.MemberChoicePoint"] = __blub_prolog_builtins_MemberChoicePoint
__blub_prolog_builtins_MemberChoicePoint.__name__ = "blub.prolog.builtins.MemberChoicePoint"
__blub_prolog_builtins_MemberChoicePoint.prototype = _hx_e();
__blub_prolog_builtins_MemberChoicePoint.prototype.clause= nil;
__blub_prolog_builtins_MemberChoicePoint.prototype.arg1= nil;
__blub_prolog_builtins_MemberChoicePoint.prototype.arg2= nil;
__blub_prolog_builtins_MemberChoicePoint.prototype.clause1 = function(self) 
  local param2 = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST);
  param2:addArg(self.arg1);
  param2:addArg(__blub_prolog_terms_Reference.new());
  local result = param2:unify(self.arg2, self.engine);
  do return result end
end
__blub_prolog_builtins_MemberChoicePoint.prototype.clause2 = function(self) 
  local refB = __blub_prolog_terms_Reference.new();
  local param2 = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST);
  param2:addArg(__blub_prolog_terms_Reference.new());
  param2:addArg(refB);
  local result = param2:unify(self.arg2, self.engine);
  if (result) then 
    __blub_prolog_builtins_MemberChoicePoint.new(self.engine, self.frame, self.arg1, refB);
  end;
end
__blub_prolog_builtins_MemberChoicePoint.prototype.nextChoice = function(self) 
  self.clause = self.clause + 1;
  local _g = self.clause;
  if (_g) == 1 then 
    if (self:clause1()) then 
      self.frame:restore();
      do return true end;
    else
      do return false end;
    end;
  elseif (_g) == 2 then 
    self:clause2();
    do return false end;else
  self:popThisChoicePoint();
  do return false end; end;
end
__blub_prolog_builtins_MemberChoicePoint.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("member/2 [") .. Std.string((self.clause + 1))) .. Std.string("] (")) .. Std.string(Std.string(self.arg1))) .. Std.string(",")) .. Std.string(Std.string(self.arg2))) .. Std.string(")") end
end

__blub_prolog_builtins_MemberChoicePoint.prototype.__class__ =  __blub_prolog_builtins_MemberChoicePoint
__blub_prolog_builtins_MemberChoicePoint.__super__ = __blub_prolog_engine_parts_ChoicePoint
setmetatable(__blub_prolog_builtins_MemberChoicePoint.prototype,{__index=__blub_prolog_engine_parts_ChoicePoint.prototype})

__blub_prolog_terms_Term.new = {}
_hxClasses["blub.prolog.terms.Term"] = __blub_prolog_terms_Term
__blub_prolog_terms_Term.__name__ = "blub.prolog.terms.Term"
__blub_prolog_terms_Term.prototype = _hx_e();
__blub_prolog_terms_Term.prototype.toString= nil;
__blub_prolog_terms_Term.prototype.equals= nil;
__blub_prolog_terms_Term.prototype.isGround= nil;
__blub_prolog_terms_Term.prototype.hasReferences= nil;
__blub_prolog_terms_Term.prototype.hasVariables= nil;
__blub_prolog_terms_Term.prototype.toValue= nil;
__blub_prolog_terms_Term.prototype.asReference= nil;
__blub_prolog_terms_Term.prototype.asUnchasedReference= nil;
__blub_prolog_terms_Term.prototype.asAtom= nil;
__blub_prolog_terms_Term.prototype.asStructure= nil;
__blub_prolog_terms_Term.prototype.asNumber= nil;
__blub_prolog_terms_Term.prototype.asValueTerm= nil;
__blub_prolog_terms_Term.prototype.commaSeparated= nil;
__blub_prolog_terms_Term.prototype.couldMatch= nil;
__blub_prolog_terms_Term.prototype.match= nil;

__blub_prolog_terms_Term.prototype.__class__ =  __blub_prolog_terms_Term

__blub_prolog_terms_ValueTerm.new = {}
_hxClasses["blub.prolog.terms.ValueTerm"] = __blub_prolog_terms_ValueTerm
__blub_prolog_terms_ValueTerm.__name__ = "blub.prolog.terms.ValueTerm"
__blub_prolog_terms_ValueTerm.__interfaces__ = {__blub_prolog_terms_Term}
__blub_prolog_terms_ValueTerm.prototype = _hx_e();
__blub_prolog_terms_ValueTerm.prototype.unify= nil;
__blub_prolog_terms_ValueTerm.prototype.dereference= nil;
__blub_prolog_terms_ValueTerm.prototype.gatherReferences= nil;

__blub_prolog_terms_ValueTerm.prototype.__class__ =  __blub_prolog_terms_ValueTerm

__blub_prolog_terms_Reference.new = function(name) 
  local self = _hx_new(__blub_prolog_terms_Reference.prototype)
  __blub_prolog_terms_Reference.super(self,name)
  return self
end
__blub_prolog_terms_Reference.super = function(self,name) 
  self.reference = nil;
  self._name = name;
end
_hxClasses["blub.prolog.terms.Reference"] = __blub_prolog_terms_Reference
__blub_prolog_terms_Reference.__name__ = "blub.prolog.terms.Reference"
__blub_prolog_terms_Reference.__interfaces__ = {__blub_prolog_terms_ValueTerm}
__blub_prolog_terms_Reference.prototype = _hx_e();
__blub_prolog_terms_Reference.prototype.name= nil;
__blub_prolog_terms_Reference.prototype.reference= nil;
__blub_prolog_terms_Reference.prototype.asAtom_nochase = function(self) 
  if (self.reference == nil) then 
    do return nil end;
  else
    do return self.reference:asAtom() end;
  end;
end
__blub_prolog_terms_Reference.prototype.asStructure_nochase = function(self) 
  if (self.reference == nil) then 
    do return nil end;
  else
    do return self.reference:asStructure() end;
  end;
end
__blub_prolog_terms_Reference.prototype.asNumber_nochase = function(self) 
  if (self.reference == nil) then 
    do return nil end;
  else
    do return self.reference:asNumber() end;
  end;
end
__blub_prolog_terms_Reference.prototype.asReference_nochase = function(self) 
  if (self.reference == nil) then 
    do return self end;
  else
    do return nil end;
  end;
end
__blub_prolog_terms_Reference.prototype.asValueTerm = function(self) 
  do return self end
end
__blub_prolog_terms_Reference.prototype.asAtom = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  do return ref:asAtom_nochase() end
end
__blub_prolog_terms_Reference.prototype.asStructure = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  do return ref:asStructure_nochase() end
end
__blub_prolog_terms_Reference.prototype.asNumber = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  do return ref:asNumber_nochase() end
end
__blub_prolog_terms_Reference.prototype.asReference = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  do return ref:asReference_nochase() end
end
__blub_prolog_terms_Reference.prototype.asUnchasedReference = function(self) 
  do return self end
end
__blub_prolog_terms_Reference.prototype.commaSeparated = function(self) 
  if (self.reference ~= nil) then 
    do return self.reference:commaSeparated() end;
  else
    do return _hx_tab_array({[0]=self}, 1) end;
  end;
end
__blub_prolog_terms_Reference.prototype.gatherReferences = function(self,refs) 
  if (self.reference == nil) then 
    if (refs == nil) then 
      do return _hx_tab_array({[0]=self}, 1) end;
    end;
    refs:push(self);
    do return refs end;
  end;
  do return self.reference:gatherReferences(refs) end
end
__blub_prolog_terms_Reference.prototype.isGround = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  local ref = ref;
  local val = ref.reference;
  if (val ~= nil) then 
    do return val:isGround() end;
  end;
  do return false end
end
__blub_prolog_terms_Reference.prototype.hasReferences = function(self) 
  do return true end
end
__blub_prolog_terms_Reference.prototype.hasVariables = function(self) 
  do return false end
end
__blub_prolog_terms_Reference.prototype.toValue = function(self,env) 
  do return self end
end
__blub_prolog_terms_Reference.prototype.toString = function(self) 
  local val = self:dereference();
  if (val == self) then 
    do return Std.string("_") .. Std.string(self:get_name()) end;
  else
    do return Std.string(Std.string(self:get_name()) .. Std.string("=")) .. Std.string(val:toString()) end;
  end;
end
__blub_prolog_terms_Reference.prototype.match = function(self,other,env,trail) 
  local val = self:dereference();
  if (val == self) then 
    if (trail ~= nil) then 
      trail:newBinding(self, self.reference);
    end;
    self:bind(other);
    do return true end;
  else
    do return val:equals(other) end;
  end;
end
__blub_prolog_terms_Reference.prototype.equals = function(self,other) 
  if (self == other) then 
    do return true end;
  end;
  local otherVal = other:asValueTerm();
  if (otherVal == nil) then 
    do return false end;
  end;
  otherVal = otherVal:dereference();
  local thisVal = self:dereference();
  local otherRef = otherVal:asReference();
  local thisRef = thisVal:asReference();
  if ((otherRef ~= nil) and (thisRef ~= nil)) then 
    do return otherRef == thisRef end;
  end;
  if ((otherRef ~= nil) or (thisRef ~= nil)) then 
    do return false end;
  end;
  do return thisVal:equals(otherVal) end
end
__blub_prolog_terms_Reference.prototype._name= nil;
__blub_prolog_terms_Reference.prototype.get_name = function(self) 
  if (self._name == nil) then 
    self._name = Std.string("V_") .. Std.string((function() 
    local _hx_obj = __blub_prolog_terms_Reference;
    local _hx_fld = 'nameGen';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)());
  end;
  do return self._name end
end
__blub_prolog_terms_Reference.prototype.couldMatch = function(self,arg) 
  do return false end
end
__blub_prolog_terms_Reference.prototype.unify = function(self,other,trail) 
  local here = self:dereferenceReferences();
  local hereRef = here:asReference();
  local thereRef = other:asReference();
  local there = (function() 
    local _hx_1
    if (thereRef ~= nil) then 
    _hx_1 = thereRef:dereferenceReferences(); else 
    _hx_1 = other; end
    return _hx_1
  end )();
  thereRef = there:asReference();
  if ((hereRef == nil) and (thereRef == nil)) then 
    do return here:unify(there, trail) end;
  end;
  local ref;
  local value;
  if (hereRef ~= nil) then 
    ref = hereRef;
    value = there;
  else
    ref = thereRef;
    value = here;
  end;
  if (trail ~= nil) then 
    trail:newBinding(ref, ref.reference);
  end;
  ref = ref:bind(value);
  do return true end
end
__blub_prolog_terms_Reference.prototype.bind = function(self,term,allowRebinding) 
  if (allowRebinding == nil) then 
    allowRebinding = false;
  end;
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  local target = ref;
  if ((target.reference ~= nil) and not allowRebinding) then 
    _G.error(__haxe_Exception.thrown(Std.string("Cannot bind already bound var ") .. Std.string(target:toString())),0);
  end;
  if (target == term) then 
    do return target end;
  end;
  target.reference = term;
  do return target end
end
__blub_prolog_terms_Reference.prototype.unbind = function(self,oldValue) 
  self.reference = oldValue;
end
__blub_prolog_terms_Reference.prototype.rebindLast = function(self,value,trail) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  local ref = ref;
  if (trail ~= nil) then 
    trail:newBinding(ref, ref.reference);
  end;
  ref:rebind(value);
end
__blub_prolog_terms_Reference.prototype.rebind = function(self,value) 
  self.reference = value;
end
__blub_prolog_terms_Reference.prototype.chaseReferences = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  do return ref end
end
__blub_prolog_terms_Reference.prototype.dereference = function(self) 
  if (self.reference == nil) then 
    do return self end;
  end;
  do return self.reference:dereference() end
end
__blub_prolog_terms_Reference.prototype.dereferenceReferences = function(self) 
  local ref = self;
  local val = self.reference;
  while (val ~= nil) do 
    local nextRef = val:asUnchasedReference();
    if (nextRef ~= nil) then 
      ref = nextRef;
      val = ref.reference;
    else
      break;
    end;
  end;
  local ref = ref;
  if (ref.reference == nil) then 
    do return ref end;
  end;
  do return ref.reference end
end

__blub_prolog_terms_Reference.prototype.__class__ =  __blub_prolog_terms_Reference

__blub_prolog_terms_Reference.prototype.__properties__ =  {get_name="get_name"}

__blub_prolog_builtins__Stack_StackTail.new = function(head) 
  local self = _hx_new(__blub_prolog_builtins__Stack_StackTail.prototype)
  __blub_prolog_builtins__Stack_StackTail.super(self,head)
  return self
end
__blub_prolog_builtins__Stack_StackTail.super = function(self,head) 
  __blub_prolog_terms_Reference.super(self);
  self.head = head;
end
_hxClasses["blub.prolog.builtins._Stack.StackTail"] = __blub_prolog_builtins__Stack_StackTail
__blub_prolog_builtins__Stack_StackTail.__name__ = "blub.prolog.builtins._Stack.StackTail"
__blub_prolog_builtins__Stack_StackTail.prototype = _hx_e();
__blub_prolog_builtins__Stack_StackTail.prototype.head= nil;
__blub_prolog_builtins__Stack_StackTail.prototype.bind = function(self,term,allowRebinding) 
  if (allowRebinding == nil) then 
    allowRebinding = false;
  end;
  local ref = term:asReference();
  if (ref ~= nil) then 
    ref.reference = self;
    do return ref end;
  end;
  self.head:push(term);
  do return self end
end
__blub_prolog_builtins__Stack_StackTail.prototype.unbind = function(self,oldValue) 
  self.head:pop();
end

__blub_prolog_builtins__Stack_StackTail.prototype.__class__ =  __blub_prolog_builtins__Stack_StackTail
__blub_prolog_builtins__Stack_StackTail.__super__ = __blub_prolog_terms_Reference
setmetatable(__blub_prolog_builtins__Stack_StackTail.prototype,{__index=__blub_prolog_terms_Reference.prototype})
setmetatable(__blub_prolog_builtins__Stack_StackTail.prototype.__properties__,{__index=__blub_prolog_terms_Reference.prototype.__properties__})

__blub_prolog_terms_ValueTermImpl.new = function() 
  local self = _hx_new(__blub_prolog_terms_ValueTermImpl.prototype)
  __blub_prolog_terms_ValueTermImpl.super(self)
  return self
end
__blub_prolog_terms_ValueTermImpl.super = function(self) 
end
_hxClasses["blub.prolog.terms.ValueTermImpl"] = __blub_prolog_terms_ValueTermImpl
__blub_prolog_terms_ValueTermImpl.__name__ = "blub.prolog.terms.ValueTermImpl"
__blub_prolog_terms_ValueTermImpl.__interfaces__ = {__blub_prolog_terms_ValueTerm}
__blub_prolog_terms_ValueTermImpl.prototype = _hx_e();
__blub_prolog_terms_ValueTermImpl.prototype.toValue = function(self,env) 
  do return self end
end
__blub_prolog_terms_ValueTermImpl.prototype.equals = function(self,other) 
  do return self == other end
end
__blub_prolog_terms_ValueTermImpl.prototype.toString = function(self) 
  do return "<ValueTermImpl>" end
end
__blub_prolog_terms_ValueTermImpl.prototype.isGround = function(self) 
  do return true end
end
__blub_prolog_terms_ValueTermImpl.prototype.hasReferences = function(self) 
  do return false end
end
__blub_prolog_terms_ValueTermImpl.prototype.hasVariables = function(self) 
  do return false end
end
__blub_prolog_terms_ValueTermImpl.prototype.asReference = function(self) 
  do return nil end
end
__blub_prolog_terms_ValueTermImpl.prototype.asUnchasedReference = function(self) 
  do return nil end
end
__blub_prolog_terms_ValueTermImpl.prototype.asAtom = function(self) 
  do return nil end
end
__blub_prolog_terms_ValueTermImpl.prototype.asStructure = function(self) 
  do return nil end
end
__blub_prolog_terms_ValueTermImpl.prototype.asNumber = function(self) 
  do return nil end
end
__blub_prolog_terms_ValueTermImpl.prototype.couldMatch = function(self,arg) 
  do return false end
end
__blub_prolog_terms_ValueTermImpl.prototype.commaSeparated = function(self) 
  do return _hx_tab_array({[0]=self}, 1) end
end
__blub_prolog_terms_ValueTermImpl.prototype.unify = function(self,other,trail) 
  do return false end
end
__blub_prolog_terms_ValueTermImpl.prototype.match = function(self,other,env,trail) 
  do return false end
end
__blub_prolog_terms_ValueTermImpl.prototype.dereference = function(self) 
  do return self end
end
__blub_prolog_terms_ValueTermImpl.prototype.asValueTerm = function(self) 
  do return self end
end
__blub_prolog_terms_ValueTermImpl.prototype.gatherReferences = function(self,refs) 
  do return _hx_tab_array({}, 0) end
end

__blub_prolog_terms_ValueTermImpl.prototype.__class__ =  __blub_prolog_terms_ValueTermImpl

__blub_prolog_terms_ClauseTerm.new = {}
_hxClasses["blub.prolog.terms.ClauseTerm"] = __blub_prolog_terms_ClauseTerm
__blub_prolog_terms_ClauseTerm.__name__ = "blub.prolog.terms.ClauseTerm"
__blub_prolog_terms_ClauseTerm.__interfaces__ = {__blub_prolog_terms_ValueTerm}
__blub_prolog_terms_ClauseTerm.prototype = _hx_e();
__blub_prolog_terms_ClauseTerm.prototype.getIndicator= nil;
__blub_prolog_terms_ClauseTerm.prototype.getHead= nil;
__blub_prolog_terms_ClauseTerm.prototype.getBody= nil;
__blub_prolog_terms_ClauseTerm.prototype.getNameText= nil;
__blub_prolog_terms_ClauseTerm.prototype.getFunctor= nil;
__blub_prolog_terms_ClauseTerm.prototype.getArgs= nil;

__blub_prolog_terms_ClauseTerm.prototype.__class__ =  __blub_prolog_terms_ClauseTerm

__blub_prolog_terms_ClauseTermImpl.new = function(payload) 
  local self = _hx_new(__blub_prolog_terms_ClauseTermImpl.prototype)
  __blub_prolog_terms_ClauseTermImpl.super(self,payload)
  return self
end
__blub_prolog_terms_ClauseTermImpl.super = function(self,payload) 
  __blub_prolog_terms_ValueTermImpl.super(self);
  self.payload = payload;
end
_hxClasses["blub.prolog.terms.ClauseTermImpl"] = __blub_prolog_terms_ClauseTermImpl
__blub_prolog_terms_ClauseTermImpl.__name__ = "blub.prolog.terms.ClauseTermImpl"
__blub_prolog_terms_ClauseTermImpl.__interfaces__ = {__blub_prolog_terms_ClauseTerm}
__blub_prolog_terms_ClauseTermImpl.prototype = _hx_e();
__blub_prolog_terms_ClauseTermImpl.prototype.payload= nil;
__blub_prolog_terms_ClauseTermImpl.prototype.getIndicator = function(self) 
  do return self.payload:getIndicator() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.getHead = function(self) 
  do return self.payload:getHead() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.getBody = function(self) 
  do return self.payload:getBody() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.getFunctor = function(self) 
  do return self.payload:getFunctor() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.getArgs = function(self) 
  do return self.payload:getArgs() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.getNameText = function(self) 
  do return self.payload:getNameText() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.equals = function(self,other) 
  do return self.payload:equals(other) end
end
__blub_prolog_terms_ClauseTermImpl.prototype.toString = function(self) 
  do return self.payload:toString() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.isGround = function(self) 
  do return self.payload:isGround() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.hasReferences = function(self) 
  do return self.payload:hasReferences() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.hasVariables = function(self) 
  do return self.payload:hasVariables() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.asAtom = function(self) 
  do return self.payload:asAtom() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.asStructure = function(self) 
  do return self.payload:asStructure() end
end
__blub_prolog_terms_ClauseTermImpl.prototype.couldMatch = function(self,arg) 
  do return self.payload:couldMatch(arg) end
end
__blub_prolog_terms_ClauseTermImpl.prototype.unify = function(self,other,trail) 
  do return self.payload:unify(other, trail) end
end
__blub_prolog_terms_ClauseTermImpl.prototype.dereference = function(self) 
  do return self.payload:dereference() end
end

__blub_prolog_terms_ClauseTermImpl.prototype.__class__ =  __blub_prolog_terms_ClauseTermImpl
__blub_prolog_terms_ClauseTermImpl.__super__ = __blub_prolog_terms_ValueTermImpl
setmetatable(__blub_prolog_terms_ClauseTermImpl.prototype,{__index=__blub_prolog_terms_ValueTermImpl.prototype})

__blub_prolog_builtins__Stack_StackHead.new = function() 
  local self = _hx_new(__blub_prolog_builtins__Stack_StackHead.prototype)
  __blub_prolog_builtins__Stack_StackHead.super(self)
  return self
end
__blub_prolog_builtins__Stack_StackHead.super = function(self) 
  __blub_prolog_terms_ClauseTermImpl.super(self,__blub_prolog_terms_Structure.EMPTY_LIST);
  self.elems = __haxe_ds_List.new();
end
_hxClasses["blub.prolog.builtins._Stack.StackHead"] = __blub_prolog_builtins__Stack_StackHead
__blub_prolog_builtins__Stack_StackHead.__name__ = "blub.prolog.builtins._Stack.StackHead"
__blub_prolog_builtins__Stack_StackHead.prototype = _hx_e();
__blub_prolog_builtins__Stack_StackHead.prototype.elems= nil;
__blub_prolog_builtins__Stack_StackHead.prototype.push = function(self,term) 
  local s = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST);
  s:addArg(term);
  s:addArg(__blub_prolog_terms_Structure.EMPTY_LIST);
  s:forceHasRefs();
  if (self.elems:isEmpty()) then 
    self.payload = s;
  else
    self.elems:first():getArgs()[1] = s;
  end;
  self.elems:push(s);
end
__blub_prolog_builtins__Stack_StackHead.prototype.pop = function(self) 
  if (self.elems:isEmpty()) then 
    do return end;
  end;
  self.elems:pop();
  if (self.elems:isEmpty()) then 
    self.payload = _hx_funcToField(__blub_prolog_terms_Structure.EMPTY_LIST);
    do return end;
  end;
  self.elems:first():getArgs()[1] = __blub_prolog_terms_Structure.EMPTY_LIST;
end

__blub_prolog_builtins__Stack_StackHead.prototype.__class__ =  __blub_prolog_builtins__Stack_StackHead
__blub_prolog_builtins__Stack_StackHead.__super__ = __blub_prolog_terms_ClauseTermImpl
setmetatable(__blub_prolog_builtins__Stack_StackHead.prototype,{__index=__blub_prolog_terms_ClauseTermImpl.prototype})

__blub_prolog_builtins_async_AsyncOperation.new = {}
_hxClasses["blub.prolog.builtins.async.AsyncOperation"] = __blub_prolog_builtins_async_AsyncOperation
__blub_prolog_builtins_async_AsyncOperation.__name__ = "blub.prolog.builtins.async.AsyncOperation"
__blub_prolog_builtins_async_AsyncOperation.prototype = _hx_e();
__blub_prolog_builtins_async_AsyncOperation.prototype.cancel= nil;
__blub_prolog_builtins_async_AsyncOperation.prototype.getDescription= nil;

__blub_prolog_builtins_async_AsyncOperation.prototype.__class__ =  __blub_prolog_builtins_async_AsyncOperation

__blub_prolog_builtins_async_AsyncOperationImpl.new = function(description,cancelFn) 
  local self = _hx_new(__blub_prolog_builtins_async_AsyncOperationImpl.prototype)
  __blub_prolog_builtins_async_AsyncOperationImpl.super(self,description,cancelFn)
  return self
end
__blub_prolog_builtins_async_AsyncOperationImpl.super = function(self,description,cancelFn) 
  self.description = description;
  self.cancelFn = _hx_funcToField(cancelFn);
end
_hxClasses["blub.prolog.builtins.async.AsyncOperationImpl"] = __blub_prolog_builtins_async_AsyncOperationImpl
__blub_prolog_builtins_async_AsyncOperationImpl.__name__ = "blub.prolog.builtins.async.AsyncOperationImpl"
__blub_prolog_builtins_async_AsyncOperationImpl.__interfaces__ = {__blub_prolog_builtins_async_AsyncOperation}
__blub_prolog_builtins_async_AsyncOperationImpl.prototype = _hx_e();
__blub_prolog_builtins_async_AsyncOperationImpl.prototype.description= nil;
__blub_prolog_builtins_async_AsyncOperationImpl.prototype.cancelFn= nil;
__blub_prolog_builtins_async_AsyncOperationImpl.prototype.cancel = function(self) 
  if (self.cancelFn ~= nil) then 
    self:cancelFn();
  end;
end
__blub_prolog_builtins_async_AsyncOperationImpl.prototype.getDescription = function(self) 
  do return self.description end
end

__blub_prolog_builtins_async_AsyncOperationImpl.prototype.__class__ =  __blub_prolog_builtins_async_AsyncOperationImpl

__blub_prolog_builtins_async_messages_MessageChannel.new = function(name,channels) 
  local self = _hx_new(__blub_prolog_builtins_async_messages_MessageChannel.prototype)
  __blub_prolog_builtins_async_messages_MessageChannel.super(self,name,channels)
  return self
end
__blub_prolog_builtins_async_messages_MessageChannel.super = function(self,name,channels) 
  self.name = name;
  self.channels = channels;
  self.listeners = __blub_prolog_util_DLList.new();
  channels.h[name] = self;
end
_hxClasses["blub.prolog.builtins.async.messages.MessageChannel"] = __blub_prolog_builtins_async_messages_MessageChannel
__blub_prolog_builtins_async_messages_MessageChannel.__name__ = "blub.prolog.builtins.async.messages.MessageChannel"
__blub_prolog_builtins_async_messages_MessageChannel.prototype = _hx_e();
__blub_prolog_builtins_async_messages_MessageChannel.prototype.name= nil;
__blub_prolog_builtins_async_messages_MessageChannel.prototype.channels= nil;
__blub_prolog_builtins_async_messages_MessageChannel.prototype.listeners= nil;
__blub_prolog_builtins_async_messages_MessageChannel.prototype.listen = function(self,engine,term) 
  do return self.listeners:append(__blub_prolog_builtins_async_messages_MessageListener.new(engine, term)) end
end
__blub_prolog_builtins_async_messages_MessageChannel.prototype.unlisten = function(self,token) 
  if (token == nil) then 
    do return end;
  end;
  if (__lua_Boot.__instanceof(token, __blub_prolog_util_Entry)) then 
    local entry = token;
    token:remove();
    if (self.listeners.size == 0) then 
      self.channels:remove(self.name);
    end;
  end;
end
__blub_prolog_builtins_async_messages_MessageChannel.prototype.send = function(self,msg) 
  local listener = self.listeners:get_entries();
  while (listener:hasNext()) do 
    local listener = listener:next();
    if (listener.item:receive(msg)) then 
      listener:remove();
    end;
  end;
  if (self.listeners.size == 0) then 
    self.channels:remove(self.name);
  end;
end

__blub_prolog_builtins_async_messages_MessageChannel.prototype.__class__ =  __blub_prolog_builtins_async_messages_MessageChannel

__blub_prolog_builtins_async_messages_MessageListener.new = function(engine,term) 
  local self = _hx_new(__blub_prolog_builtins_async_messages_MessageListener.prototype)
  __blub_prolog_builtins_async_messages_MessageListener.super(self,engine,term)
  return self
end
__blub_prolog_builtins_async_messages_MessageListener.super = function(self,engine,term) 
  self.engine = engine;
  self.term = term;
end
_hxClasses["blub.prolog.builtins.async.messages.MessageListener"] = __blub_prolog_builtins_async_messages_MessageListener
__blub_prolog_builtins_async_messages_MessageListener.__name__ = "blub.prolog.builtins.async.messages.MessageListener"
__blub_prolog_builtins_async_messages_MessageListener.prototype = _hx_e();
__blub_prolog_builtins_async_messages_MessageListener.prototype.engine= nil;
__blub_prolog_builtins_async_messages_MessageListener.prototype.term= nil;
__blub_prolog_builtins_async_messages_MessageListener.prototype.receive = function(self,msg) 
  local bindings = self.engine.bindings;
  if (not self.term:unify(msg, self.engine)) then 
    local _this = self.engine;
    local bind = _this.bindings;
    while ((bind ~= nil) and (bind ~= bindings)) do 
      bind.ref:unbind(bind.old);
      bind = bind.next;
    end;
    _this.bindings = bindings;
    do return false end;
  end;
  self.engine:continueAsync();
  do return true end
end

__blub_prolog_builtins_async_messages_MessageListener.prototype.__class__ =  __blub_prolog_builtins_async_messages_MessageListener

__blub_prolog_builtins_lazy_LazyLoadPredicates.new = function(database) 
  local self = _hx_new(__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype)
  __blub_prolog_builtins_lazy_LazyLoadPredicates.super(self,database)
  return self
end
__blub_prolog_builtins_lazy_LazyLoadPredicates.super = function(self,database) 
  self.database = database;
  self:init();
end
_hxClasses["blub.prolog.builtins.lazy.LazyLoadPredicates"] = __blub_prolog_builtins_lazy_LazyLoadPredicates
__blub_prolog_builtins_lazy_LazyLoadPredicates.__name__ = "blub.prolog.builtins.lazy.LazyLoadPredicates"
__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype = _hx_e();
__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype.database= nil;
__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype.preds= nil;
__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype.load = function(self,indicator) 
  local functor = indicator:toString();
  local ret = self.preds.h[functor];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local src = ret;
  if (src == nil) then 
    do return false end;
  end;
  self.database:addPredicateSrc(functor, src);
  do return true end
end
__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype.init = function(self) 
  self.preds = __haxe_ds_StringMap.new();
  local _this = self.preds;
  _this.h["map/3"] = " map(Predicate,List,Result) :- Goal =.. [Predicate,In,Out], findall(Out,(member(In,List),Goal),Result).";
  local _this = self.preds;
  _this.h["append/3"] = "append([], L, L). append([X|Ll], L2, [X|L3]) :- append(Ll, L2, L3).";
  local _this = self.preds;
  _this.h["findall/3"] = "findall(Template,Goal,Results) :- query(Goal,Template,Q),findall_gather(Q,Results).";
  local _this = self.preds;
  _this.h["findall_gather/2"] = "findall_gather(Q,R) :- solution( Q, S ) -> R = [S|T], findall_gather(Q,T) ; R=[].";
end

__blub_prolog_builtins_lazy_LazyLoadPredicates.prototype.__class__ =  __blub_prolog_builtins_lazy_LazyLoadPredicates

__blub_prolog_builtins_meta_TemplateQuery.new = function(engine,queryTerm,template) 
  local self = _hx_new(__blub_prolog_builtins_meta_TemplateQuery.prototype)
  __blub_prolog_builtins_meta_TemplateQuery.super(self,engine,queryTerm,template)
  return self
end
__blub_prolog_builtins_meta_TemplateQuery.super = function(self,engine,queryTerm,template) 
  local stru = queryTerm:asStructure();
  if (stru ~= nil) then 
    queryTerm = stru:variablize();
  end;
  self.query = __blub_prolog_Query.new(engine.database, queryTerm);
  self.template = template:asValueTerm();
  if (stru ~= nil) then 
    local env = self.query:get_engine().environment;
    local deref = queryTerm:toValue(env);
    stru:unify(deref, engine);
  end;
end
_hxClasses["blub.prolog.builtins.meta.TemplateQuery"] = __blub_prolog_builtins_meta_TemplateQuery
__blub_prolog_builtins_meta_TemplateQuery.__name__ = "blub.prolog.builtins.meta.TemplateQuery"
__blub_prolog_builtins_meta_TemplateQuery.prototype = _hx_e();
__blub_prolog_builtins_meta_TemplateQuery.prototype.query= nil;
__blub_prolog_builtins_meta_TemplateQuery.prototype.template= nil;
__blub_prolog_builtins_meta_TemplateQuery.prototype.halt = function(self) 
  self.query:get_engine();
end
__blub_prolog_builtins_meta_TemplateQuery.prototype.nextSolution = function(self,engine,soln) 
  local result = self.query:nextSolution();
  if (result == nil) then 
    do return false end;
  end;
  local tmp = result[1];
  if (tmp) == 0 then 
    do return false end;
  elseif (tmp) == 1 then 
    do return true end;
  elseif (tmp) == 2 then 
    local b = result[2];
    local captured = self.template:dereference();
    if (not soln:unify(captured, engine)) then 
      self.query:putBack(result);
      do return false end;
    end;
    do return true end; end;
end

__blub_prolog_builtins_meta_TemplateQuery.prototype.__class__ =  __blub_prolog_builtins_meta_TemplateQuery

__blub_prolog_builtins_objects_ObjectWrapper.new = {}
_hxClasses["blub.prolog.builtins.objects.ObjectWrapper"] = __blub_prolog_builtins_objects_ObjectWrapper
__blub_prolog_builtins_objects_ObjectWrapper.__name__ = "blub.prolog.builtins.objects.ObjectWrapper"
__blub_prolog_builtins_objects_ObjectWrapper.prototype = _hx_e();
__blub_prolog_builtins_objects_ObjectWrapper.prototype.getProperty= nil;
__blub_prolog_builtins_objects_ObjectWrapper.prototype.setProperty= nil;
__blub_prolog_builtins_objects_ObjectWrapper.prototype.callMethod= nil;
__blub_prolog_builtins_objects_ObjectWrapper.prototype.getObject= nil;
__blub_prolog_builtins_objects_ObjectWrapper.prototype.addPropListener= nil;
__blub_prolog_builtins_objects_ObjectWrapper.prototype.removePropListener= nil;

__blub_prolog_builtins_objects_ObjectWrapper.prototype.__class__ =  __blub_prolog_builtins_objects_ObjectWrapper

__blub_prolog_builtins_objects_ObjectWrapperImpl.new = function(object,atom) 
  local self = _hx_new(__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype)
  __blub_prolog_builtins_objects_ObjectWrapperImpl.super(self,object,atom)
  return self
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.super = function(self,object,atom) 
  self.object = object;
  self.atom = atom;
end
_hxClasses["blub.prolog.builtins.objects.ObjectWrapperImpl"] = __blub_prolog_builtins_objects_ObjectWrapperImpl
__blub_prolog_builtins_objects_ObjectWrapperImpl.__name__ = "blub.prolog.builtins.objects.ObjectWrapperImpl"
__blub_prolog_builtins_objects_ObjectWrapperImpl.__interfaces__ = {__blub_prolog_builtins_objects_ObjectWrapper}
__blub_prolog_builtins_objects_ObjectWrapperImpl.capitalize = function(name) 
  if (__lua_lib_luautf8_Utf8.len(name) < 2) then 
    do return __lua_lib_luautf8_Utf8.upper(name) end;
  end;
  local pos = 0;
  local len = 1;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(name)))) then 
    len = __lua_lib_luautf8_Utf8.len(name);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(name) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(name) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  local tmp = __lua_lib_luautf8_Utf8.upper(__lua_lib_luautf8_Utf8.sub(name, pos + 1, pos + len));
  local pos = 1;
  local len = nil;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(name)))) then 
    len = __lua_lib_luautf8_Utf8.len(name);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(name) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(name) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return Std.string(tmp) .. Std.string(__lua_lib_luautf8_Utf8.sub(name, pos + 1, pos + len)) end;
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype = _hx_e();
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.atom= nil;
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.object= nil;
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.listeners= nil;
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.getProperty = function(self,name) 
  do return Reflect.field(self.object, name) end
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.setProperty_final = function(self,name,value) 
  local oldValue = (function() 
    local _hx_1
    if ((self.listeners ~= nil) and (self.listeners.size > 0)) then 
    _hx_1 = self:getProperty(name); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  self.object[name] = value;
  if (self.listeners ~= nil) then 
    local listener = self.listeners:iterator();
    while (listener:hasNext()) do 
      local listener = listener:next();
      listener:propertyChanged(self, self.atom, name, oldValue, value);
    end;
  end;
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.setProperty = function(self,name,value) 
  local oldValue = (function() 
    local _hx_1
    if ((self.listeners ~= nil) and (self.listeners.size > 0)) then 
    _hx_1 = self:getProperty(name); else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  self:set(name, value);
  if (self.listeners ~= nil) then 
    local listener = self.listeners:iterator();
    while (listener:hasNext()) do 
      local listener = listener:next();
      listener:propertyChanged(self, self.atom, name, oldValue, value);
    end;
  end;
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.set = function(self,name,value) 
  self.object[name] = value;
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.callMethod = function(self,name,args) 
  if (args == nil) then 
    args = _hx_tab_array({}, 0);
  end;
  do return Reflect.callMethod(self.object,Reflect.field(self.object, name),args) end
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.getObject = function(self) 
  do return self.object end
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.addPropListener = function(self,listener) 
  if (self.listeners == nil) then 
    self.listeners = __blub_prolog_util_DLList.new();
  end;
  do return self.listeners:append(listener) end
end
__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.removePropListener = function(self,token) 
  if (token == nil) then 
    do return end;
  end;
  if (not __lua_Boot.__instanceof(token, __blub_prolog_util_Entry)) then 
    do return end;
  end;
  local entry = token;
  entry:remove();
end

__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype.__class__ =  __blub_prolog_builtins_objects_ObjectWrapperImpl

__blub_prolog_builtins_objects_HashObjectWrapper.new = function(atom,hash) 
  local self = _hx_new(__blub_prolog_builtins_objects_HashObjectWrapper.prototype)
  __blub_prolog_builtins_objects_HashObjectWrapper.super(self,atom,hash)
  return self
end
__blub_prolog_builtins_objects_HashObjectWrapper.super = function(self,atom,hash) 
  __blub_prolog_builtins_objects_ObjectWrapperImpl.super(self,(function() 
    local _hx_1
    if (hash ~= nil) then 
    _hx_1 = hash; else 
    _hx_1 = __haxe_ds_StringMap.new(); end
    return _hx_1
  end )(),atom);
end
_hxClasses["blub.prolog.builtins.objects.HashObjectWrapper"] = __blub_prolog_builtins_objects_HashObjectWrapper
__blub_prolog_builtins_objects_HashObjectWrapper.__name__ = "blub.prolog.builtins.objects.HashObjectWrapper"
__blub_prolog_builtins_objects_HashObjectWrapper.prototype = _hx_e();
__blub_prolog_builtins_objects_HashObjectWrapper.prototype.getProperty = function(self,name) 
  local ret = self.object.h[name];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__blub_prolog_builtins_objects_HashObjectWrapper.prototype.set = function(self,name,value) 
  local _this = self.object;
  local value = value;
  if (value == nil) then 
    _this.h[name] = __haxe_ds_StringMap.tnull;
  else
    _this.h[name] = value;
  end;
end
__blub_prolog_builtins_objects_HashObjectWrapper.prototype.callMethod = function(self,name,args) 
  local prop = self:getProperty(name);
  if ((prop ~= nil) and Reflect.isFunction(prop)) then 
    do return Reflect.callMethod(self.object,prop,args) end;
  end;
  do return nil end
end

__blub_prolog_builtins_objects_HashObjectWrapper.prototype.__class__ =  __blub_prolog_builtins_objects_HashObjectWrapper
__blub_prolog_builtins_objects_HashObjectWrapper.__super__ = __blub_prolog_builtins_objects_ObjectWrapperImpl
setmetatable(__blub_prolog_builtins_objects_HashObjectWrapper.prototype,{__index=__blub_prolog_builtins_objects_ObjectWrapperImpl.prototype})

__blub_prolog_builtins_objects_NativeAccess.new = {}
_hxClasses["blub.prolog.builtins.objects.NativeAccess"] = __blub_prolog_builtins_objects_NativeAccess
__blub_prolog_builtins_objects_NativeAccess.__name__ = "blub.prolog.builtins.objects.NativeAccess"
__blub_prolog_builtins_objects_NativeAccess.prototype = _hx_e();
__blub_prolog_builtins_objects_NativeAccess.prototype.get= nil;
__blub_prolog_builtins_objects_NativeAccess.prototype.set= nil;

__blub_prolog_builtins_objects_NativeAccess.prototype.__class__ =  __blub_prolog_builtins_objects_NativeAccess

__blub_prolog_builtins_objects_PropertyListener.new = {}
_hxClasses["blub.prolog.builtins.objects.PropertyListener"] = __blub_prolog_builtins_objects_PropertyListener
__blub_prolog_builtins_objects_PropertyListener.__name__ = "blub.prolog.builtins.objects.PropertyListener"
__blub_prolog_builtins_objects_PropertyListener.prototype = _hx_e();
__blub_prolog_builtins_objects_PropertyListener.prototype.propertyChanged= nil;

__blub_prolog_builtins_objects_PropertyListener.prototype.__class__ =  __blub_prolog_builtins_objects_PropertyListener

__blub_prolog_compiler_Assembler.new = function(database) 
  local self = _hx_new(__blub_prolog_compiler_Assembler.prototype)
  __blub_prolog_compiler_Assembler.super(self,database)
  return self
end
__blub_prolog_compiler_Assembler.super = function(self,database) 
  self.db = database;
end
_hxClasses["blub.prolog.compiler.Assembler"] = __blub_prolog_compiler_Assembler
__blub_prolog_compiler_Assembler.__name__ = "blub.prolog.compiler.Assembler"
__blub_prolog_compiler_Assembler.dumpInstruction = function(i,out,indent) 
  if (indent == nil) then 
    indent = "";
  end;
  local tmp = i[1];
  if (tmp) == 0 then 
    local args = i[3];
    local functor = i[2];
    out(Std.string(Std.string(Std.string(Std.string(indent) .. Std.string("call_builtin ")) .. Std.string(functor)) .. Std.string(" ")) .. Std.string(Std.string(args)));
  elseif (tmp) == 1 then 
    local args = i[3];
    local functor = i[2];
    out(Std.string(Std.string(Std.string(Std.string(indent) .. Std.string("call_pred ")) .. Std.string(functor)) .. Std.string(" ")) .. Std.string(Std.string(args)));
  elseif (tmp) == 2 then 
    local args = i[3];
    local functor = i[2];
    out(Std.string(Std.string(Std.string(Std.string(indent) .. Std.string("tail_call ")) .. Std.string(functor)) .. Std.string(" ")) .. Std.string(Std.string(args)));
  elseif (tmp) == 3 then 
    local functor = i[2];
    out(Std.string(Std.string(indent) .. Std.string("call_clauses ")) .. Std.string(functor));
  elseif (tmp) == 4 then 
    local eIdx = i[3];
    local aIdx = i[2];
    out(Std.string(Std.string(Std.string(Std.string(indent) .. Std.string("arg_to_env ")) .. Std.string(aIdx)) .. Std.string(" ")) .. Std.string(eIdx));
  elseif (tmp) == 5 then 
    local terms = i[2];
    out(Std.string(Std.string(indent) .. Std.string("set_args ")) .. Std.string(Std.string(terms)));
  elseif (tmp) == 6 then 
    local terms = i[2];
    out(Std.string(Std.string(indent) .. Std.string("set_arg_values ")) .. Std.string(Std.string(terms)));
  elseif (tmp) == 7 then 
    local head = i[2];
    out(Std.string(Std.string(indent) .. Std.string("unify_args ")) .. Std.string(Std.string(head)));
  elseif (tmp) == 8 then 
    local term = i[3];
    local index = i[2];
    out(Std.string(Std.string(Std.string(Std.string(indent) .. Std.string("unify_arg ")) .. Std.string(index)) .. Std.string(" ")) .. Std.string(Std.string(term)));
  elseif (tmp) == 9 then 
    local alt = i[2];
    out(Std.string(indent) .. Std.string("choice_point {"));
    __blub_prolog_compiler_Assembler.dumpAsm(alt, out, Std.string(indent) .. Std.string(".   "));
    out(Std.string(indent) .. Std.string("}"));
  elseif (tmp) == 10 then 
    local code = i[2];
    out(Std.string(indent) .. Std.string("call_nested {"));
    __blub_prolog_compiler_Assembler.dumpAsm(code, out, Std.string(indent) .. Std.string(".   "));
    out(Std.string(indent) .. Std.string("}"));
  elseif (tmp) == 11 then 
    local size = i[2];
    out(Std.string(Std.string(indent) .. Std.string("new_environment ")) .. Std.string(size));
  elseif (tmp) == 12 then 
    out(Std.string(indent) .. Std.string("push_code_frame"));
  elseif (tmp) == 13 then 
    out(Std.string(indent) .. Std.string("pop_code_frame"));
  elseif (tmp) == 14 then 
    out(Std.string(indent) .. Std.string("succeed"));
  elseif (tmp) == 15 then 
    out(Std.string(indent) .. Std.string("no_op"));
  elseif (tmp) == 16 then 
    out(Std.string(indent) .. Std.string("fail"));
  elseif (tmp) == 17 then 
    out(Std.string(indent) .. Std.string("cut"));
  elseif (tmp) == 18 then 
    out(Std.string(indent) .. Std.string("cut_point"));
  elseif (tmp) == 19 then 
    local msg = i[2];
    out(Std.string(Std.string(Std.string(indent) .. Std.string("log '")) .. Std.string(msg)) .. Std.string("'"));
  elseif (tmp) == 20 then 
    local fn = i[2];
    out(Std.string(Std.string(indent) .. Std.string("call_back ")) .. Std.string(Std.string(fn)));
  elseif (tmp) == 21 then 
    out(Std.string(indent) .. Std.string("dump"));
  elseif (tmp) == 22 then 
    out(Std.string(indent) .. Std.string("halt"));
  elseif (tmp) == 23 then 
    local msg = i[2];
    out(Std.string(Std.string(Std.string(indent) .. Std.string("debug_trace '")) .. Std.string(msg)) .. Std.string("'"));
  elseif (tmp) == 24 then 
    local count = i[2];
    out(Std.string(Std.string(indent) .. Std.string("halt_count ")) .. Std.string(count)); end;
end
__blub_prolog_compiler_Assembler.dumpAsm = function(instructions,out,indent) 
  if (indent == nil) then 
    indent = "";
  end;
  local _g = 0;
  while (_g < instructions.length) do 
    local i = instructions[_g];
    _g = _g + 1;
    __blub_prolog_compiler_Assembler.dumpInstruction(i, out, indent);
  end;
end
__blub_prolog_compiler_Assembler.traceDump = function(instructions,prefix) 
  local traceCount = 0;
  local out = function(msg) 
    traceCount = traceCount + 1;
    __haxe_Log.trace(msg, _hx_o({__fields__={methodName=true,lineNumber=true,fileName=true,customParams=true,className=true},methodName=nil,lineNumber=traceCount - 1,fileName=prefix,customParams=nil,className=nil}));
  end;
  __blub_prolog_compiler_Assembler.dumpAsm(instructions, out);
end
__blub_prolog_compiler_Assembler.prototype = _hx_e();
__blub_prolog_compiler_Assembler.prototype.operations= nil;
__blub_prolog_compiler_Assembler.prototype.db= nil;
__blub_prolog_compiler_Assembler.prototype["end"]= nil;
__blub_prolog_compiler_Assembler.prototype.translateList = function(self,instructions) 
  local _g = 0;
  while (_g < instructions.length) do 
    local i = instructions[_g];
    _g = _g + 1;
    self:translate(i);
  end;
end
__blub_prolog_compiler_Assembler.prototype.transOther = function(self,instructions) 
  local asm = __blub_prolog_compiler_Assembler.new(self.db);
  asm:translateList(instructions);
  do return asm.operations end
end
__blub_prolog_compiler_Assembler.prototype.translate = function(self,i) 
  local tmp = i[1];
  if (tmp) == 0 then 
    local args = i[3];
    local functor = i[2];
    self:add(i, __blub_prolog_engine_Operations.call_builtin(self.db, __blub_prolog_PredicateIndicator.fromString(functor, self.db.context), args));
  elseif (tmp) == 1 then 
    local args = i[3];
    local functor = i[2];
    self:add(i, __blub_prolog_engine_Operations.call_pred(self.db, __blub_prolog_PredicateIndicator.fromString(functor, self.db.context), args));
  elseif (tmp) == 2 then 
    local args = i[3];
    local functor = i[2];
    self:add(i, __blub_prolog_engine_Operations.tail_call(self.db, __blub_prolog_PredicateIndicator.fromString(functor, self.db.context), args));
  elseif (tmp) == 3 then 
    local functor = i[2];
    self:add(i, __blub_prolog_engine_Operations.call_clauses(self.db, __blub_prolog_PredicateIndicator.fromString(functor, self.db.context)));
  elseif (tmp) == 4 then 
    local eIdx = i[3];
    local aIdx = i[2];
    self:add(i, __blub_prolog_engine_Operations.arg_to_env(aIdx, eIdx));
  elseif (tmp) == 5 then 
    local terms = i[2];
    self:add(i, __blub_prolog_engine_Operations.set_args(terms));
  elseif (tmp) == 6 then 
    local terms = i[2];
    self:add(i, __blub_prolog_engine_Operations.set_arg_values(terms));
  elseif (tmp) == 7 then 
    local head = i[2];
    self:add(i, __blub_prolog_engine_Operations.unify_args(head));
  elseif (tmp) == 8 then 
    local term = i[3];
    local index = i[2];
    self:add(i, __blub_prolog_engine_Operations.unify_arg(index, term));
  elseif (tmp) == 9 then 
    local alt = i[2];
    self:add(i, __blub_prolog_engine_Operations.choice_point(self:transOther(alt)));
  elseif (tmp) == 10 then 
    local code = i[2];
    self:add(i, __blub_prolog_engine_Operations.call_nested(self:transOther(code)));
  elseif (tmp) == 11 then 
    local size = i[2];
    self:add(i, __blub_prolog_engine_Operations.new_environment(size));
  elseif (tmp) == 12 then 
    self:add(i, __blub_prolog_engine_Operations.push_code_frame);
  elseif (tmp) == 13 then 
    self:add(i, __blub_prolog_engine_Operations.pop_code_frame);
  elseif (tmp) == 14 then 
    self:add(i, __blub_prolog_engine_Operations.succeed);
  elseif (tmp) == 15 then 
    self:add(i, __blub_prolog_engine_Operations.no_op);
  elseif (tmp) == 16 then 
    self:add(i, __blub_prolog_engine_Operations.fail);
  elseif (tmp) == 17 then 
    self:add(i, __blub_prolog_engine_Operations.cut);
  elseif (tmp) == 18 then 
    self:add(i, __blub_prolog_engine_Operations.cut_point);
  elseif (tmp) == 19 then 
    local msg = i[2];
    self:add(i, __blub_prolog_engine_Operations.log(msg));
  elseif (tmp) == 20 then 
    local fn = i[2];
    self:add(i, __blub_prolog_engine_Operations.call_back(fn));
  elseif (tmp) == 21 then 
    self:add(i, __blub_prolog_engine_Operations.dump);
  elseif (tmp) == 22 then 
    self:add(i, __blub_prolog_engine_Operations.halt);
  elseif (tmp) == 23 then 
    local msg = i[2];
    self:add(i, __blub_prolog_engine_Operations.debug_trace(msg));
  elseif (tmp) == 24 then 
    local count = i[2];
    self:add(i, __blub_prolog_engine_Operations.halt_count(count)); end;
end
__blub_prolog_compiler_Assembler.prototype.add = function(self,i,op) 
  local asm = nil;
  if (self["end"] == nil) then 
    self["end"] = _hx_o({__fields__={op=true,asm=true,next=true},op=function(_,...) return op(...) end,asm=asm,next=nil});
    self.operations = self["end"];
  else
    local elem = _hx_o({__fields__={op=true,asm=true,next=true},op=function(_,...) return op(...) end,asm=asm,next=nil});
    self["end"].next = elem;
    self["end"] = elem;
  end;
end

__blub_prolog_compiler_Assembler.prototype.__class__ =  __blub_prolog_compiler_Assembler

__blub_prolog_compiler_ClauseCompiler.new = function(database) 
  local self = _hx_new(__blub_prolog_compiler_ClauseCompiler.prototype)
  __blub_prolog_compiler_ClauseCompiler.super(self,database)
  return self
end
__blub_prolog_compiler_ClauseCompiler.super = function(self,database) 
  __blub_prolog_compiler_CompilerBase.super(self,database);
end
_hxClasses["blub.prolog.compiler.ClauseCompiler"] = __blub_prolog_compiler_ClauseCompiler
__blub_prolog_compiler_ClauseCompiler.__name__ = "blub.prolog.compiler.ClauseCompiler"
__blub_prolog_compiler_ClauseCompiler.prototype = _hx_e();
__blub_prolog_compiler_ClauseCompiler.prototype.compile = function(self,clause) 
  if (clause.variableContext:get_count() > 0) then 
    self:add(__blub_prolog_compiler_Instruction.new_environment(clause.variableContext:get_count()));
  end;
  local head = clause.head;
  if (head:getIndicator().arity > 0) then 
    self:add(__blub_prolog_compiler_Instruction.unify_args(head));
  end;
  local body = clause.body;
  if (body ~= nil) then 
    self:compileTerm(body, true);
  else
    self:add(__blub_prolog_compiler_Instruction.succeed);
  end;
  do return self:assemble() end
end

__blub_prolog_compiler_ClauseCompiler.prototype.__class__ =  __blub_prolog_compiler_ClauseCompiler
__blub_prolog_compiler_ClauseCompiler.__super__ = __blub_prolog_compiler_CompilerBase
setmetatable(__blub_prolog_compiler_ClauseCompiler.prototype,{__index=__blub_prolog_compiler_CompilerBase.prototype})
_hxClasses["blub.prolog.compiler.Instruction"] = __blub_prolog_compiler_Instruction;
_hxClasses["blub.prolog.compiler.Instruction"] = { __ename__ = "blub.prolog.compiler.Instruction", __constructs__ = _hx_tab_array({[0]="call_builtin","call_pred","tail_call","call_clauses","arg_to_env","set_args","set_arg_values","unify_args","unify_arg","choice_point","call_nested","new_environment","push_code_frame","pop_code_frame","succeed","no_op","fail","cut","cut_point","log","call_back","dump","halt","debug_trace","halt_count"},25)}
__blub_prolog_compiler_Instruction = _hxClasses["blub.prolog.compiler.Instruction"];
__blub_prolog_compiler_Instruction.call_builtin = function(functor,args) local _x = _hx_tab_array({[0]="call_builtin",0,functor,args,__enum__=__blub_prolog_compiler_Instruction}, 4); return _x; end 
__blub_prolog_compiler_Instruction.call_pred = function(functor,args) local _x = _hx_tab_array({[0]="call_pred",1,functor,args,__enum__=__blub_prolog_compiler_Instruction}, 4); return _x; end 
__blub_prolog_compiler_Instruction.tail_call = function(functor,args) local _x = _hx_tab_array({[0]="tail_call",2,functor,args,__enum__=__blub_prolog_compiler_Instruction}, 4); return _x; end 
__blub_prolog_compiler_Instruction.call_clauses = function(functor) local _x = _hx_tab_array({[0]="call_clauses",3,functor,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.arg_to_env = function(argIndex,envIndex) local _x = _hx_tab_array({[0]="arg_to_env",4,argIndex,envIndex,__enum__=__blub_prolog_compiler_Instruction}, 4); return _x; end 
__blub_prolog_compiler_Instruction.set_args = function(terms) local _x = _hx_tab_array({[0]="set_args",5,terms,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.set_arg_values = function(terms) local _x = _hx_tab_array({[0]="set_arg_values",6,terms,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.unify_args = function(head) local _x = _hx_tab_array({[0]="unify_args",7,head,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.unify_arg = function(index,term) local _x = _hx_tab_array({[0]="unify_arg",8,index,term,__enum__=__blub_prolog_compiler_Instruction}, 4); return _x; end 
__blub_prolog_compiler_Instruction.choice_point = function(alternative) local _x = _hx_tab_array({[0]="choice_point",9,alternative,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.call_nested = function(code) local _x = _hx_tab_array({[0]="call_nested",10,code,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.new_environment = function(size) local _x = _hx_tab_array({[0]="new_environment",11,size,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.push_code_frame = _hx_tab_array({[0]="push_code_frame",12,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.pop_code_frame = _hx_tab_array({[0]="pop_code_frame",13,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.succeed = _hx_tab_array({[0]="succeed",14,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.no_op = _hx_tab_array({[0]="no_op",15,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.fail = _hx_tab_array({[0]="fail",16,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.cut = _hx_tab_array({[0]="cut",17,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.cut_point = _hx_tab_array({[0]="cut_point",18,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.log = function(msg) local _x = _hx_tab_array({[0]="log",19,msg,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.call_back = function(fn) local _x = _hx_tab_array({[0]="call_back",20,fn,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.dump = _hx_tab_array({[0]="dump",21,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.halt = _hx_tab_array({[0]="halt",22,__enum__ = __blub_prolog_compiler_Instruction},2)

__blub_prolog_compiler_Instruction.debug_trace = function(msg) local _x = _hx_tab_array({[0]="debug_trace",23,msg,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.halt_count = function(count) local _x = _hx_tab_array({[0]="halt_count",24,count,__enum__=__blub_prolog_compiler_Instruction}, 3); return _x; end 
__blub_prolog_compiler_Instruction.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_compiler_Instruction.push_code_frame,__blub_prolog_compiler_Instruction.pop_code_frame,__blub_prolog_compiler_Instruction.succeed,__blub_prolog_compiler_Instruction.no_op,__blub_prolog_compiler_Instruction.fail,__blub_prolog_compiler_Instruction.cut,__blub_prolog_compiler_Instruction.cut_point,__blub_prolog_compiler_Instruction.dump,__blub_prolog_compiler_Instruction.halt}, 9)

__blub_prolog_compiler_PredicateCompiler.new = function(database) 
  local self = _hx_new(__blub_prolog_compiler_PredicateCompiler.prototype)
  __blub_prolog_compiler_PredicateCompiler.super(self,database)
  return self
end
__blub_prolog_compiler_PredicateCompiler.super = function(self,database) 
  __blub_prolog_compiler_CompilerBase.super(self,database);
end
_hxClasses["blub.prolog.compiler.PredicateCompiler"] = __blub_prolog_compiler_PredicateCompiler
__blub_prolog_compiler_PredicateCompiler.__name__ = "blub.prolog.compiler.PredicateCompiler"
__blub_prolog_compiler_PredicateCompiler.prototype = _hx_e();
__blub_prolog_compiler_PredicateCompiler.prototype.compile = function(self,predicate) 
  self:add(__blub_prolog_compiler_Instruction.call_clauses(predicate.indicator:toString()));
  do return self:assemble() end
end

__blub_prolog_compiler_PredicateCompiler.prototype.__class__ =  __blub_prolog_compiler_PredicateCompiler
__blub_prolog_compiler_PredicateCompiler.__super__ = __blub_prolog_compiler_CompilerBase
setmetatable(__blub_prolog_compiler_PredicateCompiler.prototype,{__index=__blub_prolog_compiler_CompilerBase.prototype})

__blub_prolog_compiler_QueryCompiler.new = function(database) 
  local self = _hx_new(__blub_prolog_compiler_QueryCompiler.prototype)
  __blub_prolog_compiler_QueryCompiler.super(self,database)
  return self
end
__blub_prolog_compiler_QueryCompiler.super = function(self,database) 
  __blub_prolog_compiler_CompilerBase.super(self,database);
end
_hxClasses["blub.prolog.compiler.QueryCompiler"] = __blub_prolog_compiler_QueryCompiler
__blub_prolog_compiler_QueryCompiler.__name__ = "blub.prolog.compiler.QueryCompiler"
__blub_prolog_compiler_QueryCompiler.prototype = _hx_e();
__blub_prolog_compiler_QueryCompiler.prototype.compile = function(self,term) 
  self:compileTerm(term, true);
  do return self:assemble() end
end

__blub_prolog_compiler_QueryCompiler.prototype.__class__ =  __blub_prolog_compiler_QueryCompiler
__blub_prolog_compiler_QueryCompiler.__super__ = __blub_prolog_compiler_CompilerBase
setmetatable(__blub_prolog_compiler_QueryCompiler.prototype,{__index=__blub_prolog_compiler_CompilerBase.prototype})

__blub_prolog_engine_ArithmeticEvaluator.new = function(engine) 
  local self = _hx_new(__blub_prolog_engine_ArithmeticEvaluator.prototype)
  __blub_prolog_engine_ArithmeticEvaluator.super(self,engine)
  return self
end
__blub_prolog_engine_ArithmeticEvaluator.super = function(self,engine) 
  self.engine = engine;
end
_hxClasses["blub.prolog.engine.ArithmeticEvaluator"] = __blub_prolog_engine_ArithmeticEvaluator
__blub_prolog_engine_ArithmeticEvaluator.__name__ = "blub.prolog.engine.ArithmeticEvaluator"
__blub_prolog_engine_ArithmeticEvaluator.isArithmetic = function(struct) 
  local this1 = __blub_prolog_engine_ArithmeticEvaluator.arithmeticFuncs;
  local key = struct:getIndicator():toString();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret == true end;
end
__blub_prolog_engine_ArithmeticEvaluator.isEvaluable = function(t) 
  if (t:asNumber() ~= nil) then 
    do return true end;
  end;
  local s = t:asStructure();
  if (s == nil) then 
    do return false end;
  end;
  do return __blub_prolog_engine_ArithmeticEvaluator.isArithmetic(s) end;
end
__blub_prolog_engine_ArithmeticEvaluator.hasAllNumericArgs = function(s) 
  local _g = 0;
  local _g1 = s:getArgs();
  while (_g < _g1.length) do 
    local a = _g1[_g];
    _g = _g + 1;
    if (a:asNumber() == nil) then 
      do return false end;
    end;
  end;
  do return true end;
end
__blub_prolog_engine_ArithmeticEvaluator.prototype = _hx_e();
__blub_prolog_engine_ArithmeticEvaluator.prototype.engine= nil;
__blub_prolog_engine_ArithmeticEvaluator.prototype.evaluate = function(self,expression) 
  local numTerm = expression:asNumber();
  if (numTerm ~= nil) then 
    do return numTerm.value end;
  end;
  local stru = expression:asStructure();
  if (stru ~= nil) then 
    do return self:evalFunc(stru) end;
  end;
  self.engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_evaluable, expression, self.engine.context));
  do return 0.0 end
end
__blub_prolog_engine_ArithmeticEvaluator.prototype.evalFunc = function(self,funcExpression) 
  local _g = funcExpression:getIndicator():toString();
  if (_g) == "*/2" then 
    do return self:evaluate(funcExpression:argAt(0)) * self:evaluate(funcExpression:argAt(1)) end;
  elseif (_g) == "+/2" then 
    do return self:evaluate(funcExpression:argAt(0)) + self:evaluate(funcExpression:argAt(1)) end;
  elseif (_g) == "-/2" then 
    do return self:evaluate(funcExpression:argAt(0)) - self:evaluate(funcExpression:argAt(1)) end;
  elseif (_g) == "./2" then 
    local val = __blub_prolog_builtins_objects_DotAccessor.evalDot(self.engine, funcExpression:argAt(0), funcExpression:argAt(1));
    if (__lua_Boot.__instanceof(val, Float)) then 
      local flt = val;
      do return flt end;
    end;
  elseif (_g) == "//2" then 
    do return self:evaluate(funcExpression:argAt(0)) / self:evaluate(funcExpression:argAt(1)) end;else end;
  self.engine:raiseException(__blub_prolog_RuntimeError.typeError(__blub_prolog_TypeError.VALID_TYPE_evaluable, funcExpression, self.engine.context));
  do return 0.0 end
end

__blub_prolog_engine_ArithmeticEvaluator.prototype.__class__ =  __blub_prolog_engine_ArithmeticEvaluator

__blub_prolog_engine_DatabaseTransaction.new = function(database) 
  local self = _hx_new(__blub_prolog_engine_DatabaseTransaction.prototype)
  __blub_prolog_engine_DatabaseTransaction.super(self,database)
  return self
end
__blub_prolog_engine_DatabaseTransaction.super = function(self,database) 
  self.database = database;
end
_hxClasses["blub.prolog.engine.DatabaseTransaction"] = __blub_prolog_engine_DatabaseTransaction
__blub_prolog_engine_DatabaseTransaction.__name__ = "blub.prolog.engine.DatabaseTransaction"
__blub_prolog_engine_DatabaseTransaction.prototype = _hx_e();
__blub_prolog_engine_DatabaseTransaction.prototype.database= nil;
__blub_prolog_engine_DatabaseTransaction.prototype.preAsserts= nil;
__blub_prolog_engine_DatabaseTransaction.prototype.postAsserts= nil;
__blub_prolog_engine_DatabaseTransaction.prototype.retractions= nil;
__blub_prolog_engine_DatabaseTransaction.prototype.abolitions= nil;
__blub_prolog_engine_DatabaseTransaction.prototype.preAssert = function(self,term) 
  if (self.preAsserts == nil) then 
    self.preAsserts = Array.new();
  end;
  self.preAsserts:push(term);
end
__blub_prolog_engine_DatabaseTransaction.prototype.postAssert = function(self,term) 
  if (self.postAsserts == nil) then 
    self.postAsserts = Array.new();
  end;
  self.postAsserts:push(term);
end
__blub_prolog_engine_DatabaseTransaction.prototype.retract = function(self,clause) 
  if (self.retractions == nil) then 
    self.retractions = Array.new();
  end;
  self.retractions:push(clause);
end
__blub_prolog_engine_DatabaseTransaction.prototype.abolish = function(self,pred) 
  if (self.abolitions == nil) then 
    self.abolitions = Array.new();
  end;
  self.abolitions:push(pred);
end
__blub_prolog_engine_DatabaseTransaction.prototype.commit = function(self) 
  if (self.preAsserts ~= nil) then 
    local _g = 0;
    local _g1 = self.preAsserts;
    while (_g < _g1.length) do 
      local term = _g1[_g];
      _g = _g + 1;
      self.database:assertA(term, true);
    end;
  end;
  if (self.postAsserts ~= nil) then 
    local _g = 0;
    local _g1 = self.postAsserts;
    while (_g < _g1.length) do 
      local term = _g1[_g];
      _g = _g + 1;
      self.database:assertZ(term, true);
    end;
  end;
  if (self.retractions ~= nil) then 
    local _g = 0;
    local _g1 = self.retractions;
    while (_g < _g1.length) do 
      local clause = _g1[_g];
      _g = _g + 1;
      clause:retract();
    end;
  end;
  if (self.abolitions ~= nil) then 
    local _g = 0;
    local _g1 = self.abolitions;
    while (_g < _g1.length) do 
      local pred = _g1[_g];
      _g = _g + 1;
      pred:abolish();
    end;
  end;
end

__blub_prolog_engine_DatabaseTransaction.prototype.__class__ =  __blub_prolog_engine_DatabaseTransaction

__blub_prolog_engine_Operations.new = {}
_hxClasses["blub.prolog.engine.Operations"] = __blub_prolog_engine_Operations
__blub_prolog_engine_Operations.__name__ = "blub.prolog.engine.Operations"
__blub_prolog_engine_Operations.halt_count = function(count) 
  local i = 0;
  do return function(eng) 
    if (i >= count) then 
      eng:halt();
    end;
    i = i + 1;
  end end;
end
__blub_prolog_engine_Operations.unify_arg = function(index,term) 
  do return function(eng) 
    eng:unify(term:toValue(eng.environment), eng.arguments[index]);
  end end;
end
__blub_prolog_engine_Operations.unify_args = function(head) 
  do return function(eng) 
    local stru = head:asStructure();
    if (stru == nil) then 
      do return end;
    end;
    local headArgs = stru:getArgs();
    local args = eng.arguments;
    local numArgs = args.length;
    local env = eng.environment;
    local _g = 0;
    local _g1 = numArgs;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (not eng:unify(headArgs[i]:toValue(env), args[i])) then 
        do return end;
      end;
    end;
  end end;
end
__blub_prolog_engine_Operations.set_args = function(terms) 
  do return function(eng) 
    if (terms ~= nil) then 
      local args = Array.new();
      local env = eng.environment;
      local _g = 0;
      while (_g < terms.length) do 
        local t = terms[_g];
        _g = _g + 1;
        args:push(t:toValue(env));
      end;
      eng.arguments = args;
    else
      eng.arguments = nil;
    end;
  end end;
end
__blub_prolog_engine_Operations.arg_to_env = function(argIndex,envIndex) 
  do return function(eng) 
    eng.environment[envIndex]:bind(eng.arguments[argIndex]);
  end end;
end
__blub_prolog_engine_Operations.set_arg_values = function(terms) 
  do return function(eng) 
    eng.arguments = terms;
  end end;
end
__blub_prolog_engine_Operations.call_clauses = function(db,indicator) 
  local predicate = db:lookup(indicator);
  if (predicate ~= nil) then 
    do return function(eng) 
      local clauses = predicate:findMatchingClauses(eng.arguments);
      local len = clauses.length;
      if (len == 0) then 
        eng:fail();
      else
        __blub_prolog_engine_parts_ClauseChoices.new(eng, clauses);
      end;
    end end;
  end;
  do return function(eng) 
    local predicate = db:lookup(indicator);
    if (predicate == nil) then 
      eng:raiseException(__blub_prolog_RuntimeError.existenceError(__blub_prolog_ExistenceError.ee_procedure, __blub_prolog_terms_Atom.unregisteredAtom(indicator:toString()), eng.context));
      do return end;
    end;
    local clauses = predicate:findMatchingClauses(eng.arguments);
    local len = clauses.length;
    if (len == 0) then 
      eng:fail();
    else
      if (len == 1) then 
        eng.context = clauses[0];
        eng.codePointer = clauses[0].code;
      else
        __blub_prolog_engine_parts_ClauseChoices.new(eng, clauses);
      end;
    end;
  end end;
end
__blub_prolog_engine_Operations.call_builtin = function(db,indicator,args) 
  local predicate = db:lookup(indicator);
  if (predicate ~= nil) then 
    if (predicate.isBuiltin) then 
      do return function(eng) 
        predicate.builtin:execute(eng, args);
      end end;
    end;
  end;
  _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Cannot find built-in ") .. Std.string(indicator:toString()))),0);
end
__blub_prolog_engine_Operations.call_pred = function(db,indicator,args) 
  local predicate = db:lookup(indicator);
  if (predicate ~= nil) then 
    if (predicate.isBuiltin) then 
      do return function(eng) 
        predicate.builtin:execute(eng, args);
      end end;
    else
      do return function(eng) 
        if (args ~= nil) then 
          local args1 = Array.new();
          local env = eng.environment;
          local _g = 0;
          while (_g < args.length) do 
            local t = args[_g];
            _g = _g + 1;
            args1:push(t:toValue(env));
          end;
          eng.arguments = args1;
        else
          eng.arguments = nil;
        end;
        eng.codeStack = __blub_prolog_engine_parts_CodeFrame.new(eng);
        eng.codePointer = predicate.code;
      end end;
    end;
  end;
  do return function(eng) 
    local predicate = db:lookup(indicator);
    if (predicate == nil) then 
      eng:raiseException(__blub_prolog_RuntimeError.existenceError(__blub_prolog_ExistenceError.ee_procedure, __blub_prolog_terms_Atom.unregisteredAtom(indicator:toString()), eng.context));
      do return end;
    end;
    if (args ~= nil) then 
      local args1 = Array.new();
      local env = eng.environment;
      local _g = 0;
      while (_g < args.length) do 
        local t = args[_g];
        _g = _g + 1;
        args1:push(t:toValue(env));
      end;
      eng.arguments = args1;
    else
      eng.arguments = nil;
    end;
    eng.codeStack = __blub_prolog_engine_parts_CodeFrame.new(eng);
    eng.codePointer = predicate.code;
  end end;
end
__blub_prolog_engine_Operations.tail_call = function(db,indicator,args) 
  local predicate = db:lookup(indicator);
  if (predicate ~= nil) then 
    do return function(eng) 
      if (args ~= nil) then 
        local args1 = Array.new();
        local env = eng.environment;
        local _g = 0;
        while (_g < args.length) do 
          local t = args[_g];
          _g = _g + 1;
          args1:push(t:toValue(env));
        end;
        eng.arguments = args1;
      else
        eng.arguments = nil;
      end;
      eng.codePointer = predicate.code;
    end end;
  end;
  do return function(eng) 
    local predicate = db:lookup(indicator);
    if (predicate == nil) then 
      eng:raiseException(__blub_prolog_RuntimeError.existenceError(__blub_prolog_ExistenceError.ee_procedure, __blub_prolog_terms_Atom.unregisteredAtom(indicator:toString()), eng.context));
      do return end;
    end;
    if (args ~= nil) then 
      local args1 = Array.new();
      local env = eng.environment;
      local _g = 0;
      while (_g < args.length) do 
        local t = args[_g];
        _g = _g + 1;
        args1:push(t:toValue(env));
      end;
      eng.arguments = args1;
    else
      eng.arguments = nil;
    end;
    eng.codePointer = predicate.code;
  end end;
end
__blub_prolog_engine_Operations.choice_point = function(alternative) 
  do return function(eng) 
    __blub_prolog_engine_parts_ChoicePoint.new(eng, __blub_prolog_engine_parts_CodeFrame.new(eng, alternative));
  end end;
end
__blub_prolog_engine_Operations.succeed = function(eng) 
  eng:succeed();
end
__blub_prolog_engine_Operations.no_op = function(eng) 
end
__blub_prolog_engine_Operations.fail = function(eng) 
  eng:fail();
end
__blub_prolog_engine_Operations.cut = function(eng) 
  eng:cut();
end
__blub_prolog_engine_Operations.cut_point = function(eng) 
  local cp = __blub_prolog_engine_parts_CutPoint.new(eng);
  eng.cutBarrier = _hx_o({__fields__={prev=true,choice=true},prev=eng.cutBarrier,choice=cp});
end
__blub_prolog_engine_Operations.log = function(msg) 
  do return function(eng) 
    if (eng.logger ~= nil) then 
      eng:logger(msg);
    end;
  end end;
end
__blub_prolog_engine_Operations.debug_trace = function(msg) 
  do return function(eng) 
    __haxe_Log.trace(msg, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/blub/prolog/engine/Operations.hx",lineNumber=381,className="blub.prolog.engine.Operations",methodName="debug_trace"}));
  end end;
end
__blub_prolog_engine_Operations.call_back = function(fn) 
  do return fn end;
end
__blub_prolog_engine_Operations.dump = function(eng) 
  eng:dump();
end
__blub_prolog_engine_Operations.halt = function(eng) 
  eng:halt();
end
__blub_prolog_engine_Operations.new_environment = function(size) 
  do return function(eng) 
    eng.environment = Array.new();
    local _g = 0;
    local _g1 = size;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      eng.environment:push(__blub_prolog_terms_Reference.new());
    end;
  end end;
end
__blub_prolog_engine_Operations.push_code_frame = function(eng) 
  eng.codeStack = __blub_prolog_engine_parts_CodeFrame.new(eng);
end
__blub_prolog_engine_Operations.call_nested = function(code) 
  do return function(eng) 
    eng.codeStack = __blub_prolog_engine_parts_CodeFrame.new(eng);
    eng.codePointer = code;
  end end;
end
__blub_prolog_engine_Operations.pop_code_frame = function(eng) 
  if (eng.codeStack ~= nil) then 
    eng.codeStack:restore();
  end;
end
__blub_prolog_engine_Operations.jump_to = function(code) 
  do return function(eng) 
    eng.codePointer = code;
  end end;
end
_hxClasses["blub.prolog.engine.AsyncCallbackType"] = __blub_prolog_engine_AsyncCallbackType;
_hxClasses["blub.prolog.engine.AsyncCallbackType"] = { __ename__ = "blub.prolog.engine.AsyncCallbackType", __constructs__ = _hx_tab_array({[0]="asyncSoln","asyncDone","asyncHalt","asyncStart"},4)}
__blub_prolog_engine_AsyncCallbackType = _hxClasses["blub.prolog.engine.AsyncCallbackType"];
__blub_prolog_engine_AsyncCallbackType.asyncSoln = _hx_tab_array({[0]="asyncSoln",0,__enum__ = __blub_prolog_engine_AsyncCallbackType},2)

__blub_prolog_engine_AsyncCallbackType.asyncDone = _hx_tab_array({[0]="asyncDone",1,__enum__ = __blub_prolog_engine_AsyncCallbackType},2)

__blub_prolog_engine_AsyncCallbackType.asyncHalt = _hx_tab_array({[0]="asyncHalt",2,__enum__ = __blub_prolog_engine_AsyncCallbackType},2)

__blub_prolog_engine_AsyncCallbackType.asyncStart = _hx_tab_array({[0]="asyncStart",3,__enum__ = __blub_prolog_engine_AsyncCallbackType},2)

__blub_prolog_engine_AsyncCallbackType.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_engine_AsyncCallbackType.asyncSoln,__blub_prolog_engine_AsyncCallbackType.asyncDone,__blub_prolog_engine_AsyncCallbackType.asyncHalt,__blub_prolog_engine_AsyncCallbackType.asyncStart}, 4)

__blub_prolog_terms_BindingTrail.new = {}
_hxClasses["blub.prolog.terms.BindingTrail"] = __blub_prolog_terms_BindingTrail
__blub_prolog_terms_BindingTrail.__name__ = "blub.prolog.terms.BindingTrail"
__blub_prolog_terms_BindingTrail.prototype = _hx_e();
__blub_prolog_terms_BindingTrail.prototype.newBinding= nil;
__blub_prolog_terms_BindingTrail.prototype.bookmark= nil;
__blub_prolog_terms_BindingTrail.prototype.undo= nil;

__blub_prolog_terms_BindingTrail.prototype.__class__ =  __blub_prolog_terms_BindingTrail

__blub_prolog_engine_QueryEngine.new = function(database,code) 
  local self = _hx_new(__blub_prolog_engine_QueryEngine.prototype)
  __blub_prolog_engine_QueryEngine.super(self,database,code)
  return self
end
__blub_prolog_engine_QueryEngine.super = function(self,database,code) 
  self.database = database;
  self.codePointer = code;
  self.isAsync = false;
  self.isHalted = false;
  self.atBreakpoint = false;
end
_hxClasses["blub.prolog.engine.QueryEngine"] = __blub_prolog_engine_QueryEngine
__blub_prolog_engine_QueryEngine.__name__ = "blub.prolog.engine.QueryEngine"
__blub_prolog_engine_QueryEngine.__interfaces__ = {__blub_prolog_terms_BindingTrail}
__blub_prolog_engine_QueryEngine.prototype = _hx_e();
__blub_prolog_engine_QueryEngine.prototype.database= nil;
__blub_prolog_engine_QueryEngine.prototype.arithmetic= nil;
__blub_prolog_engine_QueryEngine.prototype.isHalted= nil;
__blub_prolog_engine_QueryEngine.prototype.atBreakpoint= nil;
__blub_prolog_engine_QueryEngine.prototype.exception= nil;
__blub_prolog_engine_QueryEngine.prototype.logger= nil;
__blub_prolog_engine_QueryEngine.prototype.codeStack= nil;
__blub_prolog_engine_QueryEngine.prototype.codePointer= nil;
__blub_prolog_engine_QueryEngine.prototype.bindings= nil;
__blub_prolog_engine_QueryEngine.prototype.cutBarrier= nil;
__blub_prolog_engine_QueryEngine.prototype.choiceStack= nil;
__blub_prolog_engine_QueryEngine.prototype.solutionFound= nil;
__blub_prolog_engine_QueryEngine.prototype.arguments= nil;
__blub_prolog_engine_QueryEngine.prototype.environment= nil;
__blub_prolog_engine_QueryEngine.prototype.context= nil;
__blub_prolog_engine_QueryEngine.prototype._arithmetic= nil;
__blub_prolog_engine_QueryEngine.prototype.get_arithmetic = function(self) 
  if (self._arithmetic == nil) then 
    self._arithmetic = __blub_prolog_engine_ArithmeticEvaluator.new(self);
  end;
  do return self._arithmetic end
end
__blub_prolog_engine_QueryEngine.prototype.transaction= nil;
__blub_prolog_engine_QueryEngine.prototype.makeTransaction = function(self) 
  if (self.transaction == nil) then 
    self.transaction = __blub_prolog_engine_DatabaseTransaction.new(self.database);
  end;
  do return self.transaction end
end
__blub_prolog_engine_QueryEngine.prototype.findSolution = function(self) 
  if (self.isHalted) then 
    do return false end;
  end;
  self.isAsync = false;
  if ((self.codePointer == nil) and not self:backtrack()) then 
    do return false end;
  end;
  self.solutionFound = false;
  while (self.codePointer ~= nil) do 
    local op = self.codePointer.op;
    self.codePointer = _hx_funcToField(self.codePointer.next);
    op(self);
  end;
  do return self.solutionFound end
end
__blub_prolog_engine_QueryEngine.prototype.executeStep = function(self) 
  self.atBreakpoint = false;
  if (self.exception ~= nil) then 
    local e = self.exception;
    self.exception = nil;
    _G.error(__haxe_Exception.thrown(self.exception),0);
  end;
  if (self.isHalted) then 
    do return end;
  end;
  self.isAsync = false;
  self.solutionFound = false;
  if (self.codePointer == nil) then 
    self:backtrack();
    do return end;
  end;
  if (self.codePointer ~= nil) then 
    local op = self.codePointer.op;
    self.codePointer = _hx_funcToField(self.codePointer.next);
    op(self);
  end;
end
__blub_prolog_engine_QueryEngine.prototype.debugRun = function(self) 
  self.atBreakpoint = false;
  if (self.exception ~= nil) then 
    local e = self.exception;
    self.exception = nil;
    _G.error(__haxe_Exception.thrown(self.exception),0);
  end;
  if (self.isHalted) then 
    do return end;
  end;
  self.isAsync = false;
  self.solutionFound = false;
  local _hx_status, _hx_result = pcall(function() 
  
      if (self.codePointer == nil) then 
        if (not self:backtrack()) then 
          do return end;
        end;
      end;
      while (self.codePointer ~= nil) do 
        local op = self.codePointer.op;
        self.codePointer = _hx_funcToField(self.codePointer.next);
        op(self);
        if (self.atBreakpoint) then 
          do return end;
        end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    local _g1 = __haxe_Exception.caught(_g):unwrap();
    if (__lua_Boot.__instanceof(_g1, __blub_prolog_PrologError)) then 
      local ex = _g1;
      self.exception = ex;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__blub_prolog_engine_QueryEngine.prototype.clearBreakpoint = function(self) 
  self.atBreakpoint = false;
  if (self.exception ~= nil) then 
    local e = self.exception;
    self.exception = nil;
    _G.error(__haxe_Exception.thrown(self.exception),0);
  end;
end
__blub_prolog_engine_QueryEngine.prototype.asyncCallback= nil;
__blub_prolog_engine_QueryEngine.prototype.asyncUnderway= nil;
__blub_prolog_engine_QueryEngine.prototype.asyncOp= nil;
__blub_prolog_engine_QueryEngine.prototype.isAsync= nil;
__blub_prolog_engine_QueryEngine.prototype.asyncResult= nil;
__blub_prolog_engine_QueryEngine.prototype.getCurrentAsyncOp = function(self) 
  do return self.asyncOp end
end
__blub_prolog_engine_QueryEngine.prototype.executeAsync = function(self,asyncCallback) 
  self.asyncCallback = _hx_funcToField(asyncCallback);
  self:continueAsync();
end
__blub_prolog_engine_QueryEngine.prototype.beginAsync = function(self,operation) 
  if (not self.isAsync) then 
    _G.error(__haxe_Exception.thrown(__blub_prolog_PrologError.new(Std.string("Async predicate can only be used in an async query, op:") .. Std.string(operation:getDescription()))),0);
  end;
  self.asyncOp = operation;
  self.asyncResult = nil;
  self.asyncUnderway = true;
end
__blub_prolog_engine_QueryEngine.prototype.continueAsync = function(self,result) 
  if (self.isHalted) then 
    do return end;
  end;
  self.asyncOp = nil;
  self.isAsync = true;
  self.asyncResult = result;
  self.asyncUnderway = false;
  while (true) do 
    if ((self.codePointer == nil) and not self:backtrack()) then 
      if (self.asyncCallback ~= nil) then 
        self:asyncCallback(self, __blub_prolog_engine_AsyncCallbackType.asyncDone);
      end;
      do return end;
    end;
    self.solutionFound = false;
    while ((self.codePointer ~= nil) and not self.asyncUnderway) do 
      local op = self.codePointer.op;
      self.codePointer = _hx_funcToField(self.codePointer.next);
      op(self);
    end;
    if (self.asyncCallback ~= nil) then 
      self:asyncCallback(self, (function() 
        local _hx_1
        if (self.asyncUnderway) then 
        _hx_1 = __blub_prolog_engine_AsyncCallbackType.asyncStart; else 
        _hx_1 = __blub_prolog_engine_AsyncCallbackType.asyncSoln; end
        return _hx_1
      end )());
    end;
    if (self.asyncUnderway) then 
      do return end;
    end;
  end;
end
__blub_prolog_engine_QueryEngine.prototype.halt = function(self) 
  if (self.logger ~= nil) then 
    self:logger("*** HALTED ***");
  end;
  self.codePointer = nil;
  self.codeStack = nil;
  self.solutionFound = false;
  self.isHalted = true;
  if (self.choiceStack ~= nil) then 
    local cp = self.choiceStack;
    while (cp ~= nil) do 
      cp:halt();
      cp = cp.prev;
    end;
    self.choiceStack = nil;
  end;
  if (self.asyncOp ~= nil) then 
    self.asyncOp:cancel();
    self.asyncOp = nil;
  end;
  self.asyncResult = nil;
  self.asyncUnderway = false;
  if (self.asyncCallback ~= nil) then 
    self:asyncCallback(self, __blub_prolog_engine_AsyncCallbackType.asyncHalt);
  end;
end
__blub_prolog_engine_QueryEngine.prototype.backtrack = function(self) 
  self.solutionFound = false;
  self.codePointer = nil;
  self.codeStack = nil;
  while (self.choiceStack ~= nil) do 
    self.choiceStack:undoBindings();
    if (self.choiceStack:nextChoice()) then 
      do return true end;
    end;
  end;
  do return false end
end
__blub_prolog_engine_QueryEngine.prototype.breakpoint = function(self) 
  self.atBreakpoint = true;
end
__blub_prolog_engine_QueryEngine.prototype.processBuiltinChoices = function(self) 
  self:backtrack();
end
__blub_prolog_engine_QueryEngine.prototype.log = function(self,msg) 
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
end
__blub_prolog_engine_QueryEngine.prototype.setLogger = function(self,fn) 
  self.logger = _hx_funcToField(fn);
end
__blub_prolog_engine_QueryEngine.prototype.raiseException = function(self,exception) 
  _G.error(__haxe_Exception.thrown(exception),0);
end
__blub_prolog_engine_QueryEngine.prototype.unify = function(self,termA,termB) 
  if (termA:unify(termB, self)) then 
    do return true end;
  end;
  self:fail();
  do return false end
end
__blub_prolog_engine_QueryEngine.prototype.succeed = function(self) 
  if (self.codeStack ~= nil) then 
    if (self.codeStack ~= nil) then 
      self.codeStack:restore();
    end;
    do return end;
  end;
  self.solutionFound = true;
  self.codePointer = nil;
end
__blub_prolog_engine_QueryEngine.prototype.fail = function(self) 
  self:backtrack();
end
__blub_prolog_engine_QueryEngine.prototype.cut = function(self) 
  if (self.cutBarrier ~= nil) then 
    self.choiceStack = self.cutBarrier.choice.prev;
    self.cutBarrier = _hx_funcToField(self.cutBarrier.prev);
  else
    self.choiceStack = nil;
  end;
end
__blub_prolog_engine_QueryEngine.prototype.newBinding = function(self,ref,oldValue) 
  self.bindings = _hx_o({__fields__={next=true,ref=true,old=true},next=self.bindings,ref=ref,old=oldValue});
end
__blub_prolog_engine_QueryEngine.prototype.bookmark = function(self) 
  do return self.bindings end
end
__blub_prolog_engine_QueryEngine.prototype.undo = function(self,bookmark) 
  local prevBind = bookmark;
  local bind = self.bindings;
  while ((bind ~= nil) and (bind ~= prevBind)) do 
    bind.ref:unbind(bind.old);
    bind = bind.next;
  end;
  self.bindings = prevBind;
end
__blub_prolog_engine_QueryEngine.prototype.undoBindings = function(self,prevBind) 
  local bind = self.bindings;
  while ((bind ~= nil) and (bind ~= prevBind)) do 
    bind.ref:unbind(bind.old);
    bind = bind.next;
  end;
  self.bindings = prevBind;
end
__blub_prolog_engine_QueryEngine.prototype.pushCutPoint = function(self) 
  local cp = __blub_prolog_engine_parts_CutPoint.new(self);
  self.cutBarrier = _hx_o({__fields__={prev=true,choice=true},prev=self.cutBarrier,choice=cp});
end
__blub_prolog_engine_QueryEngine.prototype.pushCutBarrier = function(self,cpnt) 
  self.cutBarrier = _hx_o({__fields__={prev=true,choice=true},prev=self.cutBarrier,choice=cpnt});
end
__blub_prolog_engine_QueryEngine.prototype.pushCodeFrame = function(self) 
  self.codeStack = __blub_prolog_engine_parts_CodeFrame.new(self);
end
__blub_prolog_engine_QueryEngine.prototype.popCodeFrame = function(self) 
  if (self.codeStack ~= nil) then 
    self.codeStack:restore();
  end;
end
__blub_prolog_engine_QueryEngine.prototype.createEnvironment = function(self,size) 
  self.environment = Array.new();
  local _g = 0;
  local _g1 = size;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self.environment:push(__blub_prolog_terms_Reference.new());
  end;
end
__blub_prolog_engine_QueryEngine.prototype.setArguments = function(self,newArgs) 
  if (newArgs ~= nil) then 
    local args = Array.new();
    local env = self.environment;
    local _g = 0;
    while (_g < newArgs.length) do 
      local t = newArgs[_g];
      _g = _g + 1;
      args:push(t:toValue(env));
    end;
    self.arguments = args;
  else
    self.arguments = nil;
  end;
end
__blub_prolog_engine_QueryEngine.prototype.useTraceLogger = function(self,prefix) 
  if (prefix == nil) then 
    prefix = ":";
  end;
  self.traceCount = 0;
  self.tracePrefix = prefix;
  self.logger = _hx_funcToField(_hx_bind(self,self.traceLogger));
end
__blub_prolog_engine_QueryEngine.prototype.tracePrefix= nil;
__blub_prolog_engine_QueryEngine.prototype.traceCount= nil;
__blub_prolog_engine_QueryEngine.prototype.traceLogger = function(self,msg) 
  __haxe_Log.trace(msg, _hx_o({__fields__={methodName=true,lineNumber=true,fileName=true,customParams=true,className=true},methodName=nil,lineNumber=(function() 
  local _hx_obj = self;
  local _hx_fld = 'traceCount';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)(),fileName=self.tracePrefix,customParams=nil,className=nil}));
end
__blub_prolog_engine_QueryEngine.prototype.dump = function(self) 
  if (self.logger ~= nil) then 
    self:logger("---------------------------------------");
  end;
  local msg = Std.string("codeStack:     ") .. Std.string(Std.string(self.codeStack));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  local msg = Std.string("codePointer:   ") .. Std.string(Std.string(self.codePointer));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  local msg = Std.string("cutBarrier:    ") .. Std.string(Std.string(self.cutBarrier));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  local msg = Std.string("choiceStack:   ") .. Std.string(Std.string(self.choiceStack));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  local msg = Std.string("solutionFound: ") .. Std.string(Std.string(self.solutionFound));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  local msg = Std.string("arguments:     ") .. Std.string(Std.string(self.arguments));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  local msg = Std.string("environment:   ") .. Std.string(Std.string(self.environment));
  if (self.logger ~= nil) then 
    self:logger(msg);
  end;
  if (self.logger ~= nil) then 
    self:logger("---------------------------------------");
  end;
end

__blub_prolog_engine_QueryEngine.prototype.__class__ =  __blub_prolog_engine_QueryEngine

__blub_prolog_engine_QueryEngine.prototype.__properties__ =  {get_arithmetic="get_arithmetic"}

__blub_prolog_engine_parts_ClauseChoices.new = function(eng,clauses) 
  local self = _hx_new(__blub_prolog_engine_parts_ClauseChoices.prototype)
  __blub_prolog_engine_parts_ClauseChoices.super(self,eng,clauses)
  return self
end
__blub_prolog_engine_parts_ClauseChoices.super = function(self,eng,clauses) 
  __blub_prolog_engine_parts_ChoicePoint.super(self,eng);
  self.clauses = clauses;
  self.index = 0;
  self:jumpToChoice();
end
_hxClasses["blub.prolog.engine.parts.ClauseChoices"] = __blub_prolog_engine_parts_ClauseChoices
__blub_prolog_engine_parts_ClauseChoices.__name__ = "blub.prolog.engine.parts.ClauseChoices"
__blub_prolog_engine_parts_ClauseChoices.prototype = _hx_e();
__blub_prolog_engine_parts_ClauseChoices.prototype.clauses= nil;
__blub_prolog_engine_parts_ClauseChoices.prototype.index= nil;
__blub_prolog_engine_parts_ClauseChoices.prototype.nextChoice = function(self) 
  self.frame:restore();
  do return self:jumpToChoice() end
end
__blub_prolog_engine_parts_ClauseChoices.prototype.jumpToChoice = function(self) 
  local clause = self.clauses[(function() 
  local _hx_obj = self;
  local _hx_fld = 'index';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()];
  if (self.index == self.clauses.length) then 
    self:popThisChoicePoint();
  end;
  local _this = self.engine;
  _this.cutBarrier = _hx_o({__fields__={prev=true,choice=true},prev=_this.cutBarrier,choice=self});
  self.engine.context = clause;
  self.engine.codePointer = clause.code;
  do return true end
end
__blub_prolog_engine_parts_ClauseChoices.prototype.toString = function(self) 
  do return Std.string("Next clause: ") .. Std.string(Std.string(self.clauses[self.index].head)) end
end

__blub_prolog_engine_parts_ClauseChoices.prototype.__class__ =  __blub_prolog_engine_parts_ClauseChoices
__blub_prolog_engine_parts_ClauseChoices.__super__ = __blub_prolog_engine_parts_ChoicePoint
setmetatable(__blub_prolog_engine_parts_ClauseChoices.prototype,{__index=__blub_prolog_engine_parts_ChoicePoint.prototype})

__blub_prolog_engine_parts_CodeFrame.new = function(eng,continuation) 
  local self = _hx_new(__blub_prolog_engine_parts_CodeFrame.prototype)
  __blub_prolog_engine_parts_CodeFrame.super(self,eng,continuation)
  return self
end
__blub_prolog_engine_parts_CodeFrame.super = function(self,eng,continuation) 
  self.engine = eng;
  self.codeStack = self.engine.codeStack;
  self.codePointer = (function() 
    local _hx_1
    if (continuation == nil) then 
    _hx_1 = self.engine.codePointer; else 
    _hx_1 = continuation; end
    return _hx_1
  end )();
  self.cutBarrier = self.engine.cutBarrier;
  self.arguments = self.engine.arguments;
  self.environment = self.engine.environment;
  self.context = self.engine.context;
end
_hxClasses["blub.prolog.engine.parts.CodeFrame"] = __blub_prolog_engine_parts_CodeFrame
__blub_prolog_engine_parts_CodeFrame.__name__ = "blub.prolog.engine.parts.CodeFrame"
__blub_prolog_engine_parts_CodeFrame.prototype = _hx_e();
__blub_prolog_engine_parts_CodeFrame.prototype.engine= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.codeStack= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.codePointer= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.cutBarrier= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.arguments= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.environment= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.context= nil;
__blub_prolog_engine_parts_CodeFrame.prototype.restore = function(self) 
  self.engine.codeStack = self.codeStack;
  self.engine.codePointer = self.codePointer;
  self.engine.cutBarrier = self.cutBarrier;
  self.engine.arguments = self.arguments;
  self.engine.environment = self.environment;
  self.engine.context = self.context;
end
__blub_prolog_engine_parts_CodeFrame.prototype.toString = function(self) 
  do return Std.string("Frame: ") .. Std.string(Std.string(self.environment)) end
end

__blub_prolog_engine_parts_CodeFrame.prototype.__class__ =  __blub_prolog_engine_parts_CodeFrame

__blub_prolog_engine_parts_CutPoint.new = function(eng) 
  local self = _hx_new(__blub_prolog_engine_parts_CutPoint.prototype)
  __blub_prolog_engine_parts_CutPoint.super(self,eng)
  return self
end
__blub_prolog_engine_parts_CutPoint.super = function(self,eng) 
  __blub_prolog_engine_parts_ChoicePoint.super(self,eng);
end
_hxClasses["blub.prolog.engine.parts.CutPoint"] = __blub_prolog_engine_parts_CutPoint
__blub_prolog_engine_parts_CutPoint.__name__ = "blub.prolog.engine.parts.CutPoint"
__blub_prolog_engine_parts_CutPoint.prototype = _hx_e();
__blub_prolog_engine_parts_CutPoint.prototype.nextChoice = function(self) 
  self.frame.engine.choiceStack = self.prev;
  do return false end
end

__blub_prolog_engine_parts_CutPoint.prototype.__class__ =  __blub_prolog_engine_parts_CutPoint
__blub_prolog_engine_parts_CutPoint.__super__ = __blub_prolog_engine_parts_ChoicePoint
setmetatable(__blub_prolog_engine_parts_CutPoint.prototype,{__index=__blub_prolog_engine_parts_ChoicePoint.prototype})

__blub_prolog_engine_parts_RepeatingChoicePoint.new = function(eng) 
  local self = _hx_new(__blub_prolog_engine_parts_RepeatingChoicePoint.prototype)
  __blub_prolog_engine_parts_RepeatingChoicePoint.super(self,eng)
  return self
end
__blub_prolog_engine_parts_RepeatingChoicePoint.super = function(self,eng) 
  __blub_prolog_engine_parts_ChoicePoint.super(self,eng,eng.codeStack);
end
_hxClasses["blub.prolog.engine.parts.RepeatingChoicePoint"] = __blub_prolog_engine_parts_RepeatingChoicePoint
__blub_prolog_engine_parts_RepeatingChoicePoint.__name__ = "blub.prolog.engine.parts.RepeatingChoicePoint"
__blub_prolog_engine_parts_RepeatingChoicePoint.prototype = _hx_e();
__blub_prolog_engine_parts_RepeatingChoicePoint.prototype.nextChoice = function(self) 
  self.frame:restore();
  do return true end
end
__blub_prolog_engine_parts_RepeatingChoicePoint.prototype.toString = function(self) 
  do return Std.string("Repeating: ") .. Std.string(Std.string(self.frame)) end
end

__blub_prolog_engine_parts_RepeatingChoicePoint.prototype.__class__ =  __blub_prolog_engine_parts_RepeatingChoicePoint
__blub_prolog_engine_parts_RepeatingChoicePoint.__super__ = __blub_prolog_engine_parts_ChoicePoint
setmetatable(__blub_prolog_engine_parts_RepeatingChoicePoint.prototype,{__index=__blub_prolog_engine_parts_ChoicePoint.prototype})

__blub_prolog_stopgap_parse_Char.new = function(line,col,text,index) 
  local self = _hx_new(__blub_prolog_stopgap_parse_Char.prototype)
  __blub_prolog_stopgap_parse_Char.super(self,line,col,text,index)
  return self
end
__blub_prolog_stopgap_parse_Char.super = function(self,line,col,text,index) 
  self.line = line;
  self.col = col;
  local pos = index;
  local len = 1;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(text)))) then 
    len = __lua_lib_luautf8_Utf8.len(text);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(text) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(text) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  self.value = __lua_lib_luautf8_Utf8.sub(text, pos + 1, pos + len);
  self.code = __lua_lib_luautf8_Utf8.byte(self.value, 1);
end
_hxClasses["blub.prolog.stopgap.parse.Char"] = __blub_prolog_stopgap_parse_Char
__blub_prolog_stopgap_parse_Char.__name__ = "blub.prolog.stopgap.parse.Char"
__blub_prolog_stopgap_parse_Char.isOpChar_ = function(value) 
  local startIndex = nil;
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local tmp;
  if (value == "") then 
    tmp = String.indexOfEmpty("#$&*+-./:<=>?@^~\\", startIndex - 1);
  else
    local r = __lua_lib_luautf8_Utf8.find("#$&*+-./:<=>?@^~\\", value, startIndex, true);
    tmp = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
  end;
  do return tmp >= 0 end;
end
__blub_prolog_stopgap_parse_Char.prototype = _hx_e();
__blub_prolog_stopgap_parse_Char.prototype.line= nil;
__blub_prolog_stopgap_parse_Char.prototype.col= nil;
__blub_prolog_stopgap_parse_Char.prototype.value= nil;
__blub_prolog_stopgap_parse_Char.prototype.code= nil;
__blub_prolog_stopgap_parse_Char.prototype.toString = function(self) 
  do return self.value end
end
__blub_prolog_stopgap_parse_Char.prototype.isOpChar = function(self) 
  local str = self.value;
  local startIndex = nil;
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local tmp;
  if (str == "") then 
    tmp = String.indexOfEmpty("#$&*+-./:<=>?@^~\\", startIndex - 1);
  else
    local r = __lua_lib_luautf8_Utf8.find("#$&*+-./:<=>?@^~\\", str, startIndex, true);
    tmp = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
  end;
  do return tmp >= 0 end
end
__blub_prolog_stopgap_parse_Char.prototype.isComma = function(self) 
  do return self.value == "," end
end
__blub_prolog_stopgap_parse_Char.prototype.isExclamation = function(self) 
  do return self.value == "!" end
end
__blub_prolog_stopgap_parse_Char.prototype.isSemicolon = function(self) 
  do return self.value == ";" end
end
__blub_prolog_stopgap_parse_Char.prototype.isBar = function(self) 
  do return self.value == "|" end
end
__blub_prolog_stopgap_parse_Char.prototype.isUnderscore = function(self) 
  do return self.value == "_" end
end
__blub_prolog_stopgap_parse_Char.prototype.isSingleQuote = function(self) 
  do return self.value == "'" end
end
__blub_prolog_stopgap_parse_Char.prototype.isDoubleQuote = function(self) 
  do return self.value == "\"" end
end
__blub_prolog_stopgap_parse_Char.prototype.isUppercase = function(self) 
  if (self.code >= 65) then 
    do return self.code <= 90 end;
  else
    do return false end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isLowercase = function(self) 
  if (self.code >= 97) then 
    do return self.code <= 122 end;
  else
    do return false end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isLetter = function(self) 
  if (not self:isUppercase()) then 
    do return self:isLowercase() end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isAtomChar = function(self) 
  if (not ((self:isUppercase() or self:isLowercase()) or self:isDigit())) then 
    do return self:isUnderscore() end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isVarChar = function(self) 
  if (not ((self:isUppercase() or self:isLowercase()) or self:isDigit())) then 
    do return self:isUnderscore() end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isDigit = function(self) 
  if (self.code >= 48) then 
    do return self.code <= 57 end;
  else
    do return false end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isHexDigit = function(self) 
  if (not (self:isDigit() or ((self.code >= 65) and (self.code <= 70)))) then 
    if (self.code >= 97) then 
      do return self.code <= 102 end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isHexX = function(self) 
  if (self.value ~= "x") then 
    do return self.value == "X" end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isExponentE = function(self) 
  if (self.value ~= "e") then 
    do return self.value == "E" end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isNumericSign = function(self) 
  if (self.value ~= "-") then 
    do return self.value == "+" end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Char.prototype.isZero = function(self) 
  do return self.value == "0" end
end
__blub_prolog_stopgap_parse_Char.prototype.isNewline = function(self) 
  do return self.value == "\n" end
end
__blub_prolog_stopgap_parse_Char.prototype.isReturn = function(self) 
  do return self.value == "\r" end
end
__blub_prolog_stopgap_parse_Char.prototype.isPeriod = function(self) 
  do return self.value == "." end
end
__blub_prolog_stopgap_parse_Char.prototype.isMinus = function(self) 
  do return self.value == "-" end
end
__blub_prolog_stopgap_parse_Char.prototype.isLineComment = function(self) 
  do return self.value == "%" end
end
__blub_prolog_stopgap_parse_Char.prototype.isSlash = function(self) 
  do return self.value == "/" end
end
__blub_prolog_stopgap_parse_Char.prototype.isBackslash = function(self) 
  do return self.value == "\\" end
end
__blub_prolog_stopgap_parse_Char.prototype.isAsterisk = function(self) 
  do return self.value == "*" end
end
__blub_prolog_stopgap_parse_Char.prototype.isOpenParen = function(self) 
  do return self.value == "(" end
end
__blub_prolog_stopgap_parse_Char.prototype.isCloseParen = function(self) 
  do return self.value == ")" end
end
__blub_prolog_stopgap_parse_Char.prototype.isOpenBrace = function(self) 
  do return self.value == "{" end
end
__blub_prolog_stopgap_parse_Char.prototype.isCloseBrace = function(self) 
  do return self.value == "}" end
end
__blub_prolog_stopgap_parse_Char.prototype.isOpenBracket = function(self) 
  do return self.value == "[" end
end
__blub_prolog_stopgap_parse_Char.prototype.isCloseBracket = function(self) 
  do return self.value == "]" end
end
__blub_prolog_stopgap_parse_Char.prototype.isWhitespace = function(self) 
  local str = self.value;
  local startIndex = nil;
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local tmp;
  if (str == "") then 
    tmp = String.indexOfEmpty(" \n\r\t\012", startIndex - 1);
  else
    local r = __lua_lib_luautf8_Utf8.find(" \n\r\t\012", str, startIndex, true);
    tmp = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
  end;
  do return tmp >= 0 end
end

__blub_prolog_stopgap_parse_Char.prototype.__class__ =  __blub_prolog_stopgap_parse_Char

__blub_prolog_stopgap_parse_Lexer.new = function(text,origin,line,col) 
  local self = _hx_new(__blub_prolog_stopgap_parse_Lexer.prototype)
  __blub_prolog_stopgap_parse_Lexer.super(self,text,origin,line,col)
  return self
end
__blub_prolog_stopgap_parse_Lexer.super = function(self,text,origin,line,col) 
  if (col == nil) then 
    col = 1;
  end;
  if (line == nil) then 
    line = 1;
  end;
  if (origin == nil) then 
    origin = "<unknown>";
  end;
  self.text = text;
  self.origin = origin;
  self.buffer = Array.new();
  self:sanitize();
  self:readAllChars(line, col);
end
_hxClasses["blub.prolog.stopgap.parse.Lexer"] = __blub_prolog_stopgap_parse_Lexer
__blub_prolog_stopgap_parse_Lexer.__name__ = "blub.prolog.stopgap.parse.Lexer"
__blub_prolog_stopgap_parse_Lexer.prototype = _hx_e();
__blub_prolog_stopgap_parse_Lexer.prototype.buffer= nil;
__blub_prolog_stopgap_parse_Lexer.prototype.token= nil;
__blub_prolog_stopgap_parse_Lexer.prototype.text= nil;
__blub_prolog_stopgap_parse_Lexer.prototype.origin= nil;
__blub_prolog_stopgap_parse_Lexer.prototype.next = function(self,skipWS) 
  if (skipWS == nil) then 
    skipWS = true;
  end;
  self.token = Array.new();
  if (skipWS) then 
    self:skipWS();
  end;
  if (self.buffer.length == 0) then 
    do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_eof, self.token) end;
  end;
  local type;
  while (self:isCommentStart()) do 
    self:skipComment();
  end;
  local ch = self.buffer[0];
  if (ch:isWhitespace()) then 
    do return self:gatherWS() end;
  end;
  if (ch:isUnderscore() or ch:isUppercase()) then 
    do return self:gatherVar() end;
  end;
  if (ch:isDigit()) then 
    do return self:gatherNumber() end;
  end;
  if (ch:isPeriod() and ((((self.buffer.length == 1) or self.buffer[1]:isWhitespace()) or self.buffer[1]:isLineComment()) or (((self.buffer.length > 2) and self.buffer[1]:isSlash()) and self.buffer[2]:isAsterisk()))) then 
    self.token:push(self.buffer:shift());
    do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_term_end, self.token) end;
  end;
  if (ch:isOpChar()) then 
    do return self:gatherOp() end;
  end;
  if (ch:isLowercase()) then 
    do return self:gatherAtom() end;
  end;
  if (ch:isSingleQuote()) then 
    do return self:gatherQuotedAtom() end;
  end;
  if (ch:isDoubleQuote()) then 
    do return self:gatherString() end;
  end;
  if (ch:isComma()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_atom) end;
  end;
  if (ch:isSemicolon()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_atom) end;
  end;
  if (ch:isExclamation()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_atom) end;
  end;
  if (ch:isBar()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_atom) end;
  end;
  if (ch:isOpenParen()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_open_paren) end;
  end;
  if (ch:isCloseParen()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_close_paren) end;
  end;
  if (ch:isOpenBrace()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_open_brace) end;
  end;
  if (ch:isCloseBrace()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_close_brace) end;
  end;
  if (ch:isOpenBracket()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_open_bracket) end;
  end;
  if (ch:isCloseBracket()) then 
    do return self:one(__blub_prolog_stopgap_parse_TokenType.token_close_bracket) end;
  end;
  _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new(Std.string(Std.string("unrecognized character '") .. Std.string(ch.value)) .. Std.string("'"), self.origin, ch.line, ch.col)),0);
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherString = function(self) 
  local start = self.buffer:shift();
  local _end = nil;
  local _hx_continue_1 = false;
  while (true) do repeat 
    if (self.buffer.length == 0) then 
      local last = self.token:pop();
      _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new("unterminated string", self.origin, last.line, last.col)),0);
    end;
    if (self.buffer[0]:isBackslash() and (self.buffer.length > 1)) then 
      self.token:push(self.buffer:shift());
      self.token:push(self.buffer:shift());
      break;
    end;
    if (self.buffer[0]:isDoubleQuote()) then 
      _end = self.buffer:shift();
      _hx_continue_1 = true;break;
    end;
    self.token:push(self.buffer:shift());until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_string, self.token, start, _end) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.escapeReadChar = function(self) 
  if (self.buffer.length == 0) then 
    do return nil end;
  end;
  local ch = self.buffer:shift();
  if (ch:isBackslash()) then 
    if (self.buffer.length == 0) then 
      _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new("bad character escape", self.origin, ch.line, ch.col)),0);
    end;
    local ch2 = self.buffer:shift();
    local _g = ch2.value;
    if (_g) == "\"" then 
      ch.value = "\"";
    elseif (_g) == "'" then 
      ch.value = "'";
    elseif (_g) == "\\" then 
      ch.value = "\\";
    elseif (_g) == "`" then 
      ch.value = "`";
    elseif (_g) == "a" then 
      ch.value = "\007";
    elseif (_g) == "b" then 
      ch.value = "\t";
    elseif (_g) == "f" then 
      ch.value = "\012";
    elseif (_g) == "n" then 
      ch.value = "\n";
    elseif (_g) == "r" then 
      ch.value = "\r";
    elseif (_g) == "t" then 
      ch.value = "\t";
    elseif (_g) == "v" then 
      ch.value = "\011";
    elseif (_g) == "X" or (_g) == "x" then 
      local s = "0x";
      local _hx_continue_1 = false;
      while (true) do repeat 
        if (self.buffer.length == 0) then 
          _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new("unterminated escape char", self.origin, ch2.line, ch2.col)),0);
        end;
        ch2 = self.buffer:shift();
        if (ch2:isDigit()) then 
          s = Std.string(s) .. Std.string(ch2.value);
          break;
        end;
        if (ch2:isBackslash()) then 
          local code = Std.parseInt(s);
          ch.value = __lua_lib_luautf8_Utf8.char(code);
          _hx_continue_1 = true;break;
        end;
        _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new("non-digit in hex escape char", self.origin, ch2.line, ch2.col)),0);until true
        if _hx_continue_1 then 
        _hx_continue_1 = false;
        break;
        end;
        
      end;else
    _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new("bad character escape", self.origin, ch.line, ch.col)),0); end;
  end;
  do return ch end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherQuotedAtom = function(self) 
  self.buffer:shift();
  local _hx_continue_1 = false;
  while (true) do repeat 
    if (self.buffer.length == 0) then 
      local buf = StringBuf.new();
      local _g = 0;
      local _g1 = self.token;
      while (_g < _g1.length) do 
        local c = _g1[_g];
        _g = _g + 1;
        local str = Std.string(c.value);
        _G.table.insert(buf.b, str);
        local buf = buf;
        buf.length = buf.length + __lua_lib_luautf8_Utf8.len(str);
      end;
      local last = self.token:pop();
      _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new(Std.string("unterminated atom: ") .. Std.string(Std.string(buf)), self.origin, last.line, last.col)),0);
    end;
    if (self.buffer[0]:isBackslash() and (self.buffer.length > 1)) then 
      self.buffer:shift();
      local escChr = self.buffer:shift();
      local tmp;
      local _g = escChr.value;
      if (_g) == "\\" then 
        tmp = "\\";
      elseif (_g) == "n" then 
        tmp = "\n";
      elseif (_g) == "r" then 
        tmp = "\r";
      elseif (_g) == "t" then 
        tmp = "\t";else
      tmp = Std.string("\\") .. Std.string(escChr.value); end;
      escChr.value = tmp;
      self.token:push(escChr);
      break;
    end;
    if (self.buffer[0]:isSingleQuote()) then 
      if ((self.buffer.length > 1) and self.buffer[1]:isSingleQuote()) then 
        self.token:push(self.buffer:shift());
        self.buffer:shift();
        break;
      end;
      self.buffer:shift();
      _hx_continue_1 = true;break;
    end;
    self.token:push(self.buffer:shift());until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_atom, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherAtom = function(self) 
  self.token:push(self.buffer:shift());
  while ((self.buffer.length > 0) and self.buffer[0]:isAtomChar()) do 
    self.token:push(self.buffer:shift());
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_atom, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherOp = function(self) 
  while ((self.buffer.length > 0) and self.buffer[0]:isOpChar()) do 
    self.token:push(self.buffer:shift());
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_atom, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherNumber = function(self) 
  local ch = self.buffer:shift();
  self.token:push(ch);
  local type = __blub_prolog_stopgap_parse_TokenType.token_int;
  if ((ch:isZero() and (self.buffer.length > 0)) and self.buffer[0]:isHexX()) then 
    self.token:push(self.buffer:shift());
    do return self:gatherHex() end;
  end;
  self:gatherDigits();
  if (((self.buffer.length > 1) and self.buffer[0]:isPeriod()) and self.buffer[1]:isDigit()) then 
    type = __blub_prolog_stopgap_parse_TokenType.token_float;
    self.token:push(self.buffer:shift());
    self:gatherDigits();
  end;
  if (((self.buffer.length > 1) and self.buffer[0]:isExponentE()) and (self.buffer[1]:isDigit() or (((self.buffer.length > 2) and self.buffer[1]:isNumericSign()) and self.buffer[2]:isDigit()))) then 
    type = __blub_prolog_stopgap_parse_TokenType.token_float;
    self.token:push(self.buffer:shift());
    if (self.buffer[0]:isNumericSign()) then 
      self.token:push(self.buffer:shift());
    end;
    self:gatherDigits();
  end;
  if ((self.buffer.length > 0) and (self.buffer[0]:isLetter() or self.buffer[0]:isUnderscore())) then 
    _G.error(__haxe_Exception.thrown(__blub_prolog_stopgap_parse_ParseError.new(Std.string(Std.string("invalid char after a number '") .. Std.string(self.buffer[0].value)) .. Std.string("'"), self.origin, self.buffer[0].line, self.buffer[0].col)),0);
  end;
  do return __blub_prolog_stopgap_parse_Token.new(type, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherDigits = function(self) 
  while ((self.buffer.length > 0) and self.buffer[0]:isDigit()) do 
    self.token:push(self.buffer:shift());
  end;
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherHex = function(self) 
  while ((self.buffer.length > 0) and self.buffer[0]:isHexDigit()) do 
    self.token:push(self.buffer:shift());
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_int, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.one = function(self,type) 
  self.token:push(self.buffer:shift());
  do return __blub_prolog_stopgap_parse_Token.new(type, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherVar = function(self) 
  while ((self.buffer.length > 0) and self.buffer[0]:isVarChar()) do 
    self.token:push(self.buffer:shift());
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_variable, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.gatherWS = function(self) 
  while ((self.buffer.length > 0) and self.buffer[0]:isWhitespace()) do 
    if (self:isCommentStart()) then 
      self:skipComment();
    end;
    self.token:push(self.buffer:shift());
  end;
  do return __blub_prolog_stopgap_parse_Token.new(__blub_prolog_stopgap_parse_TokenType.token_whitespace, self.token) end
end
__blub_prolog_stopgap_parse_Lexer.prototype.skipWS = function(self) 
  local _hx_continue_1 = false;
  while ((self.buffer.length > 0) and (self.buffer[0]:isWhitespace() or self:isCommentStart())) do repeat 
    if (self:isCommentStart()) then 
      self:skipComment();
      break;
    end;
    self.buffer:shift();until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__blub_prolog_stopgap_parse_Lexer.prototype.isCommentStart = function(self) 
  if ((self.buffer.length > 0) and self.buffer[0]:isLineComment()) then 
    do return true end;
  end;
  if (((self.buffer.length > 1) and self.buffer[0]:isSlash()) and self.buffer[1]:isAsterisk()) then 
    do return true end;
  end;
  do return false end
end
__blub_prolog_stopgap_parse_Lexer.prototype.skipComment = function(self) 
  if (self.buffer[0]:isLineComment()) then 
    self:skipToEndOfLine();
  else
    while (self.buffer.length > 0) do 
      if ((self.buffer:shift():isAsterisk() and (self.buffer.length > 0)) and self.buffer[0]:isSlash()) then 
        self.buffer:shift();
        break;
      end;
    end;
  end;
end
__blub_prolog_stopgap_parse_Lexer.prototype.skipToEndOfLine = function(self) 
  while (self.buffer.length > 0) do 
    if (self.buffer:shift():isNewline()) then 
      break;
    end;
  end;
end
__blub_prolog_stopgap_parse_Lexer.prototype.sanitize = function(self) 
  self.text = StringTools.replace(self.text, "\r\n", "\n");
  self.text = StringTools.replace(self.text, "\r", "\n");
end
__blub_prolog_stopgap_parse_Lexer.prototype.readAllChars = function(self,line,col) 
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(self.text);
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local c = __blub_prolog_stopgap_parse_Char.new(line, col, self.text, i);
    if (c:isNewline()) then 
      line = line + 1;
      col = 1;
    else
      col = col + 1;
    end;
    self.buffer:push(c);
  end;
end

__blub_prolog_stopgap_parse_Lexer.prototype.__class__ =  __blub_prolog_stopgap_parse_Lexer

__blub_prolog_stopgap_parse_Operator.new = function(atom,spec,priority) 
  local self = _hx_new(__blub_prolog_stopgap_parse_Operator.prototype)
  __blub_prolog_stopgap_parse_Operator.super(self,atom,spec,priority)
  return self
end
__blub_prolog_stopgap_parse_Operator.super = function(self,atom,spec,priority) 
  self.priority = priority;
  self.spec = spec;
  self.atom = atom;
  local tmp;
  local tmp1 = spec[1];
  if (tmp1) == 0 or (tmp1) == 1 or (tmp1) == 2 or (tmp1) == 3 then 
    tmp = 1;
  elseif (tmp1) == 4 or (tmp1) == 5 or (tmp1) == 6 then 
    tmp = 2; end;
  self.arity = tmp;
  self.functor = Std.string(Std.string(atom.text) .. Std.string("/")) .. Std.string(self.arity);
end
_hxClasses["blub.prolog.stopgap.parse.Operator"] = __blub_prolog_stopgap_parse_Operator
__blub_prolog_stopgap_parse_Operator.__name__ = "blub.prolog.stopgap.parse.Operator"
__blub_prolog_stopgap_parse_Operator.functorForOp = function(name,arity) 
  do return Std.string(Std.string(name) .. Std.string("/")) .. Std.string(arity) end;
end
__blub_prolog_stopgap_parse_Operator.opSpec = function(s) 
  local s = s;
  if (s) == "fx" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_fx end;
  elseif (s) == "fy" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_fy end;
  elseif (s) == "xf" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_xf end;
  elseif (s) == "xfx" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_xfx end;
  elseif (s) == "xfy" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_xfy end;
  elseif (s) == "yf" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_yf end;
  elseif (s) == "yfx" then 
    do return __blub_prolog_stopgap_parse_OperatorSpec.op_yfx end;else
  do return nil end; end;
end
__blub_prolog_stopgap_parse_Operator.prototype = _hx_e();
__blub_prolog_stopgap_parse_Operator.prototype.atom= nil;
__blub_prolog_stopgap_parse_Operator.prototype.spec= nil;
__blub_prolog_stopgap_parse_Operator.prototype.priority= nil;
__blub_prolog_stopgap_parse_Operator.prototype.arity= nil;
__blub_prolog_stopgap_parse_Operator.prototype.functor= nil;
__blub_prolog_stopgap_parse_Operator.prototype.expectsLeft = function(self) 
  do return self:get_leftSpec() ~= nil end
end
__blub_prolog_stopgap_parse_Operator.prototype.expectsRight = function(self) 
  do return self:get_rightSpec() ~= nil end
end
__blub_prolog_stopgap_parse_Operator.prototype.rightSpec= nil;
__blub_prolog_stopgap_parse_Operator.prototype.get_rightSpec = function(self) 
  local tmp = self.spec[1];
  if (tmp) == 1 or (tmp) == 6 then 
    do return __blub_prolog_stopgap_parse_Specifier.spec_y end;
  elseif (tmp) == 2 or (tmp) == 3 then 
    do return nil end;
  elseif (tmp) == 0 or (tmp) == 4 or (tmp) == 5 then 
    do return __blub_prolog_stopgap_parse_Specifier.spec_x end; end;
end
__blub_prolog_stopgap_parse_Operator.prototype.leftSpec= nil;
__blub_prolog_stopgap_parse_Operator.prototype.get_leftSpec = function(self) 
  local tmp = self.spec[1];
  if (tmp) == 0 or (tmp) == 1 then 
    do return nil end;
  elseif (tmp) == 3 or (tmp) == 5 then 
    do return __blub_prolog_stopgap_parse_Specifier.spec_y end;
  elseif (tmp) == 2 or (tmp) == 4 or (tmp) == 6 then 
    do return __blub_prolog_stopgap_parse_Specifier.spec_x end; end;
end
__blub_prolog_stopgap_parse_Operator.prototype.compareToRight = function(self,right) 
  if (self.priority > right.priority) then 
    do return 1 end;
  end;
  if (self.priority < right.priority) then 
    do return 2 end;
  end;
  local rspec = self:get_rightSpec();
  local lspec = right:get_leftSpec();
  if (rspec == lspec) then 
    do return 0 end;
  end;
  if (rspec == __blub_prolog_stopgap_parse_Specifier.spec_y) then 
    do return 1 end;
  end;
  do return 2 end
end

__blub_prolog_stopgap_parse_Operator.prototype.__class__ =  __blub_prolog_stopgap_parse_Operator

__blub_prolog_stopgap_parse_Operator.prototype.__properties__ =  {get_leftSpec="get_leftSpec",get_rightSpec="get_rightSpec"}
_hxClasses["blub.prolog.stopgap.parse.Specifier"] = __blub_prolog_stopgap_parse_Specifier;
_hxClasses["blub.prolog.stopgap.parse.Specifier"] = { __ename__ = "blub.prolog.stopgap.parse.Specifier", __constructs__ = _hx_tab_array({[0]="spec_x","spec_y"},2)}
__blub_prolog_stopgap_parse_Specifier = _hxClasses["blub.prolog.stopgap.parse.Specifier"];
__blub_prolog_stopgap_parse_Specifier.spec_x = _hx_tab_array({[0]="spec_x",0,__enum__ = __blub_prolog_stopgap_parse_Specifier},2)

__blub_prolog_stopgap_parse_Specifier.spec_y = _hx_tab_array({[0]="spec_y",1,__enum__ = __blub_prolog_stopgap_parse_Specifier},2)

__blub_prolog_stopgap_parse_Specifier.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_stopgap_parse_Specifier.spec_x,__blub_prolog_stopgap_parse_Specifier.spec_y}, 2)
_hxClasses["blub.prolog.stopgap.parse.OperatorSpec"] = __blub_prolog_stopgap_parse_OperatorSpec;
_hxClasses["blub.prolog.stopgap.parse.OperatorSpec"] = { __ename__ = "blub.prolog.stopgap.parse.OperatorSpec", __constructs__ = _hx_tab_array({[0]="op_fx","op_fy","op_xf","op_yf","op_xfx","op_yfx","op_xfy"},7)}
__blub_prolog_stopgap_parse_OperatorSpec = _hxClasses["blub.prolog.stopgap.parse.OperatorSpec"];
__blub_prolog_stopgap_parse_OperatorSpec.op_fx = _hx_tab_array({[0]="op_fx",0,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.op_fy = _hx_tab_array({[0]="op_fy",1,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.op_xf = _hx_tab_array({[0]="op_xf",2,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.op_yf = _hx_tab_array({[0]="op_yf",3,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.op_xfx = _hx_tab_array({[0]="op_xfx",4,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.op_yfx = _hx_tab_array({[0]="op_yfx",5,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.op_xfy = _hx_tab_array({[0]="op_xfy",6,__enum__ = __blub_prolog_stopgap_parse_OperatorSpec},2)

__blub_prolog_stopgap_parse_OperatorSpec.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_stopgap_parse_OperatorSpec.op_fx,__blub_prolog_stopgap_parse_OperatorSpec.op_fy,__blub_prolog_stopgap_parse_OperatorSpec.op_xf,__blub_prolog_stopgap_parse_OperatorSpec.op_yf,__blub_prolog_stopgap_parse_OperatorSpec.op_xfx,__blub_prolog_stopgap_parse_OperatorSpec.op_yfx,__blub_prolog_stopgap_parse_OperatorSpec.op_xfy}, 7)

__blub_prolog_stopgap_parse_Operators.new = function() 
  local self = _hx_new(__blub_prolog_stopgap_parse_Operators.prototype)
  __blub_prolog_stopgap_parse_Operators.super(self)
  return self
end
__blub_prolog_stopgap_parse_Operators.super = function(self) 
  self.operators = __haxe_ds_StringMap.new();
end
_hxClasses["blub.prolog.stopgap.parse.Operators"] = __blub_prolog_stopgap_parse_Operators
__blub_prolog_stopgap_parse_Operators.__name__ = "blub.prolog.stopgap.parse.Operators"
__blub_prolog_stopgap_parse_Operators.prototype = _hx_e();
__blub_prolog_stopgap_parse_Operators.prototype.operators= nil;
__blub_prolog_stopgap_parse_Operators.prototype.add = function(self,op) 
  local key = op.functor;
  local _this = self.operators;
  if (op == nil) then 
    _this.h[key] = __haxe_ds_StringMap.tnull;
  else
    _this.h[key] = op;
  end;
end
__blub_prolog_stopgap_parse_Operators.prototype.newOp = function(self,name,spec,priority,context) 
  local op = __blub_prolog_stopgap_parse_Operator.new(context:getAtom(name), spec, priority);
  self:add(op);
  do return op end
end
__blub_prolog_stopgap_parse_Operators.prototype.lookup = function(self,name,arity) 
  local ret = self.operators.h[Std.string(Std.string(name) .. Std.string("/")) .. Std.string(arity)];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__blub_prolog_stopgap_parse_Operators.prototype.lookupAny = function(self,name) 
  local op = self:lookup(name, 1);
  if (op ~= nil) then 
    do return op end;
  end;
  do return self:lookup(name, 2) end
end
__blub_prolog_stopgap_parse_Operators.prototype.couldBeOp = function(self,name) 
  if (self:lookup(name, 1) == nil) then 
    do return self:lookup(name, 2) ~= nil end;
  else
    do return true end;
  end;
end
__blub_prolog_stopgap_parse_Operators.prototype.new_op = function(self,name,spec,priority) 
  self:newOp(name, spec, priority, __blub_prolog_AtomContext.GLOBALS);
end
__blub_prolog_stopgap_parse_Operators.prototype.addStandardOps = function(self) 
  self:new_op("dynamic", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 1150);
  self:new_op("discontiguous", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 1150);
  self:new_op("multifile", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 1150);
  self:new_op(":-", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 1200);
  self:new_op("-->", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 1200);
  self:new_op("?-", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 1200);
  self:new_op(";", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 1100);
  self:new_op("|", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 1100);
  self:new_op("->", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 1050);
  self:new_op(",", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 1000);
  self:new_op("\\+", __blub_prolog_stopgap_parse_OperatorSpec.op_fy, 900);
  self:new_op("<", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("=..", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("=@=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("=:=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("=<", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("==", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("=\\=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op(">", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op(">=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("@<", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("@=<", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("@>", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("@>=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("\\=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("\\==", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("is", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op(":", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 600);
  self:new_op("+", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 500);
  self:new_op("-", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 500);
  self:new_op("/\\", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 500);
  self:new_op("\\/", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 500);
  self:new_op("xor", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 500);
  self:new_op("?", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 500);
  self:new_op("*", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op("/", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op("//", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op("<<", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op(">>", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op("mod", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op("rem", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 400);
  self:new_op("**", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 200);
  self:new_op("^", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 200);
  self:new_op("#", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 1);
  self:new_op("from_global", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 530);
  self:new_op("to_global", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 530);
  self:new_op("<-", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 510);
  self:new_op(".", __blub_prolog_stopgap_parse_OperatorSpec.op_yfx, 100);
  self:new_op("<=&", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 510);
  self:new_op("<=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 510);
  self:new_op("<#&", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 510);
  self:new_op("<#", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 510);
  self:new_op("spawn", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 910);
  self:new_op("spawns", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 910);
  self:new_op("change_in", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 910);
  self:new_op("@", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 110);
  self:new_op("@=", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 700);
  self:new_op("chr_constraint", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 1150);
  self:new_op("<=>", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 1190);
  self:new_op("==>", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 1190);
  self:new_op("\\", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 1150);
  self:new_op("or", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 950);
  self:new_op("and", __blub_prolog_stopgap_parse_OperatorSpec.op_xfy, 930);
  self:new_op("~", __blub_prolog_stopgap_parse_OperatorSpec.op_fx, 100);
  self:new_op("=>", __blub_prolog_stopgap_parse_OperatorSpec.op_xfx, 1200);
end

__blub_prolog_stopgap_parse_Operators.prototype.__class__ =  __blub_prolog_stopgap_parse_Operators

__blub_prolog_stopgap_parse_ParseError.new = function(msg,origin,line,col) 
  local self = _hx_new(__blub_prolog_stopgap_parse_ParseError.prototype)
  __blub_prolog_stopgap_parse_ParseError.super(self,msg,origin,line,col)
  return self
end
__blub_prolog_stopgap_parse_ParseError.super = function(self,msg,origin,line,col) 
  __blub_prolog_PrologError.super(self,msg);
  self.origin = origin;
  self.line = line;
  self.col = col;
end
_hxClasses["blub.prolog.stopgap.parse.ParseError"] = __blub_prolog_stopgap_parse_ParseError
__blub_prolog_stopgap_parse_ParseError.__name__ = "blub.prolog.stopgap.parse.ParseError"
__blub_prolog_stopgap_parse_ParseError.prototype = _hx_e();
__blub_prolog_stopgap_parse_ParseError.prototype.origin= nil;
__blub_prolog_stopgap_parse_ParseError.prototype.line= nil;
__blub_prolog_stopgap_parse_ParseError.prototype.col= nil;
__blub_prolog_stopgap_parse_ParseError.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(self.origin) .. Std.string("<")) .. Std.string(self.line)) .. Std.string(":")) .. Std.string(self.col)) .. Std.string("> ")) .. Std.string(self.message) end
end

__blub_prolog_stopgap_parse_ParseError.prototype.__class__ =  __blub_prolog_stopgap_parse_ParseError
__blub_prolog_stopgap_parse_ParseError.__super__ = __blub_prolog_PrologError
setmetatable(__blub_prolog_stopgap_parse_ParseError.prototype,{__index=__blub_prolog_PrologError.prototype})

__blub_prolog_stopgap_parse_ParseNode.new = function(parser,term) 
  local self = _hx_new(__blub_prolog_stopgap_parse_ParseNode.prototype)
  __blub_prolog_stopgap_parse_ParseNode.super(self,parser,term)
  return self
end
__blub_prolog_stopgap_parse_ParseNode.super = function(self,parser,term) 
  self.parser = parser;
  self.term = term;
  if ((term ~= nil) and __lua_Boot.__instanceof(term, __blub_prolog_terms_Atom)) then 
    self.op = parser.operators:lookupAny((__lua_Boot.__cast(term , __blub_prolog_terms_Atom)).text);
  end;
end
_hxClasses["blub.prolog.stopgap.parse.ParseNode"] = __blub_prolog_stopgap_parse_ParseNode
__blub_prolog_stopgap_parse_ParseNode.__name__ = "blub.prolog.stopgap.parse.ParseNode"
__blub_prolog_stopgap_parse_ParseNode.prototype = _hx_e();
__blub_prolog_stopgap_parse_ParseNode.prototype.term= nil;
__blub_prolog_stopgap_parse_ParseNode.prototype.op= nil;
__blub_prolog_stopgap_parse_ParseNode.prototype.left= nil;
__blub_prolog_stopgap_parse_ParseNode.prototype.right= nil;
__blub_prolog_stopgap_parse_ParseNode.prototype.parent= nil;
__blub_prolog_stopgap_parse_ParseNode.prototype.parser= nil;
__blub_prolog_stopgap_parse_ParseNode.prototype.toString = function(self) 
  do return self.term:toString() end
end
__blub_prolog_stopgap_parse_ParseNode.prototype.getRoot = function(self) 
  local root = self;
  while (root.parent ~= nil) do 
    root = root.parent;
  end;
  do return root end
end
__blub_prolog_stopgap_parse_ParseNode.prototype.assembleTerm = function(self) 
  if (self.op ~= nil) then 
    local struct = __blub_prolog_terms_Structure.new(__lua_Boot.__cast(self.term , __blub_prolog_terms_Atom));
    if (self.left ~= nil) then 
      struct:addArg(self.left:assembleTerm());
    end;
    if (self.right ~= nil) then 
      struct:addArg(self.right:assembleTerm());
    end;
    struct = self:checkIfThenElse(struct);
    do return struct end;
  end;
  do return self.term end
end
__blub_prolog_stopgap_parse_ParseNode.prototype.checkIfThenElse = function(self,struct) 
  if ((((struct:getName().text == ";") and (struct:getArity() == 2)) and __lua_Boot.__instanceof(struct:argAt(0), __blub_prolog_terms_Structure)) and ((__lua_Boot.__cast(struct:argAt(0) , __blub_prolog_terms_Structure)):getName().text == "->")) then 
    local ifThen = __lua_Boot.__cast(struct:argAt(0) , __blub_prolog_terms_Structure);
    do return __blub_prolog_terms_Structure.new(self.parser.context:getAtom("#if_then_else"), _hx_tab_array({[0]=ifThen:argAt(0), ifThen:argAt(1), struct:argAt(1)}, 3)) end;
  end;
  do return struct end
end
__blub_prolog_stopgap_parse_ParseNode.prototype.assimilate = function(self,node) 
  if (node == nil) then 
    if (self.op ~= nil) then 
      if (((self.parent == nil) and (self.left == nil)) and (self.right == nil)) then 
        do return nil end;
      end;
      if ((self.right == nil) and self.op:expectsRight()) then 
        _G.error(__haxe_Exception.thrown(self.parser:oops(Std.string(Std.string("operator '") .. Std.string(self.op.atom.text)) .. Std.string("' expects a term to the right"))),0);
      end;
    end;
    do return nil end;
  end;
  if ((self.op ~= nil) and (node.op == nil)) then 
    if (not self.op:expectsRight()) then 
      _G.error(__haxe_Exception.thrown(self.parser:oops(Std.string(Std.string("operator '") .. Std.string(self.op.atom.text)) .. Std.string("' does not expect a term to the right"))),0);
    end;
    if (self.right ~= nil) then 
      _G.error(__haxe_Exception.thrown(self.parser:oops("*** IMPL ERROR - op right arg not empty ***")),0);
    end;
    self.right = node;
    node.parent = self;
  else
    if ((self.op ~= nil) and (node.op ~= nil)) then 
      local op2 = node.op;
      if (self.op:expectsRight() and not op2:expectsLeft()) then 
        self.right = node;
        node.parent = self;
      else
        _G.error(__haxe_Exception.thrown(self.parser:oops(Std.string(Std.string(Std.string("*** IMPL ERROR - op clash *** ") .. Std.string(Std.string(self.op))) .. Std.string(" ")) .. Std.string(Std.string(op2)))),0);
      end;
    else
      if (node.op ~= nil) then 
        local op2 = node.op;
        if (not op2:expectsLeft()) then 
          _G.error(__haxe_Exception.thrown(self.parser:oops(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("operator '") .. Std.string(op2.atom.text)) .. Std.string("' {")) .. Std.string(op2.priority)) .. Std.string("} does not expect a term to the left: ")) .. Std.string(Std.string(self.op.atom))) .. Std.string(" {")) .. Std.string(self.op.priority)) .. Std.string("}"))),0);
        end;
        local leftChild = self:findInsertionPoint(op2);
        leftChild:makeLeftChildOf(node);
      else
        if ((self.op == nil) and (node.op == nil)) then 
          _G.error(__haxe_Exception.thrown(self.parser:oops(Std.string("unexpected term - operator expected: ") .. Std.string(Std.string(node)))),0);
        end;
      end;
    end;
  end;
  do return node end
end
__blub_prolog_stopgap_parse_ParseNode.prototype.makeLeftChildOf = function(self,node) 
  node.left = self;
  if (self.parent ~= nil) then 
    node.parent = self.parent;
    if (self.parent.left == self) then 
      self.parent.left = node;
    else
      self.parent.right = node;
    end;
  end;
  self.parent = node;
end
__blub_prolog_stopgap_parse_ParseNode.prototype.findInsertionPoint = function(self,op) 
  if (self.op ~= nil) then 
    local _g = self.op:compareToRight(op);
    if (_g) == 0 then 
      _G.error(__haxe_Exception.thrown(self.parser:oops(Std.string(Std.string(Std.string("operator priority clash ") .. Std.string(Std.string(self))) .. Std.string(" ")) .. Std.string(Std.string(op.atom)))),0);
    elseif (_g) == 1 then 
      do return self.right end;
    elseif (_g) == 2 then 
      if (self.parent ~= nil) then 
        do return self.parent:findInsertionPoint(op) end;
      end;
      do return self end; end;
  end;
  if (self.parent ~= nil) then 
    do return self.parent:findInsertionPoint(op) end;
  end;
  do return self end
end

__blub_prolog_stopgap_parse_ParseNode.prototype.__class__ =  __blub_prolog_stopgap_parse_ParseNode

__blub_prolog_stopgap_parse_Parser.new = function(context,operators,text,origin,line,col) 
  local self = _hx_new(__blub_prolog_stopgap_parse_Parser.prototype)
  __blub_prolog_stopgap_parse_Parser.super(self,context,operators,text,origin,line,col)
  return self
end
__blub_prolog_stopgap_parse_Parser.super = function(self,context,operators,text,origin,line,col) 
  if (col == nil) then 
    col = 1;
  end;
  if (line == nil) then 
    line = 1;
  end;
  if (origin == nil) then 
    origin = "<unknown>";
  end;
  self.lastWasOp = true;
  self.origin = origin;
  self.operators = operators;
  self.context = context;
  if (self.context == nil) then 
    self.context = __blub_prolog_AtomContext.new();
  end;
  self.lexer = __blub_prolog_stopgap_parse_Lexer.new(text, origin, line, col);
end
_hxClasses["blub.prolog.stopgap.parse.Parser"] = __blub_prolog_stopgap_parse_Parser
__blub_prolog_stopgap_parse_Parser.__name__ = "blub.prolog.stopgap.parse.Parser"
__blub_prolog_stopgap_parse_Parser.prototype = _hx_e();
__blub_prolog_stopgap_parse_Parser.prototype.lexer= nil;
__blub_prolog_stopgap_parse_Parser.prototype.origin= nil;
__blub_prolog_stopgap_parse_Parser.prototype.next= nil;
__blub_prolog_stopgap_parse_Parser.prototype.context= nil;
__blub_prolog_stopgap_parse_Parser.prototype.operators= nil;
__blub_prolog_stopgap_parse_Parser.prototype.lastReadToken= nil;
__blub_prolog_stopgap_parse_Parser.prototype.lastWasOp= nil;
__blub_prolog_stopgap_parse_Parser.prototype.nextTerm = function(self) 
  local tok = self:getNext(true);
  if (tok.type == __blub_prolog_stopgap_parse_TokenType.token_eof) then 
    do return nil end;
  end;
  if ((tok.type == __blub_prolog_stopgap_parse_TokenType.token_atom) and (tok.value == ":-")) then 
    local directive = self:readUntil(__blub_prolog_stopgap_parse_TokenType.token_term_end);
    local stru = nil;
    if (directive ~= nil) then 
      stru = directive:asStructure();
      if (stru ~= nil) then 
        stru = stru:unpackParentheses():asStructure();
      end;
    end;
    if (stru == nil) then 
      _G.error(__haxe_Exception.thrown(self:oops("Malformed directive", tok)),0);
    end;
    do return __blub_prolog_terms_Structure.make(self.context:getAtom(":-"), stru) end;
  else
    self:pushback(tok);
  end;
  local term = self:readUntil(__blub_prolog_stopgap_parse_TokenType.token_term_end);
  local s = term:asStructure();
  if (s ~= nil) then 
    term = s:unpackParentheses();
  end;
  do return term end
end
__blub_prolog_stopgap_parse_Parser.prototype.readUntil = function(self,tokenType) 
  self.lastWasOp = true;
  local node = nil;
  local term;
  while (true) do 
    term = self:nextRawTerm(tokenType);
    if (not (term ~= nil)) then 
      break;
    end;
    local newNode = __blub_prolog_stopgap_parse_ParseNode.new(self, term);
    if (node ~= nil) then 
      node = node:assimilate(newNode);
    else
      node = newNode;
    end;
  end;
  if (node ~= nil) then 
    node:assimilate(nil);
    do return node:getRoot():assembleTerm() end;
  else
    do return nil end;
  end;
end
__blub_prolog_stopgap_parse_Parser.prototype.nextRawTerm = function(self,endType) 
  local t = self:_nextRawTerm(endType);
  if (t == nil) then 
    do return nil end;
  end;
  local atom = t:asAtom();
  self.lastWasOp = (atom ~= nil) and ((self.operators:lookup(atom.text, 1) ~= nil) or (self.operators:lookup(atom.text, 2) ~= nil));
  do return t end
end
__blub_prolog_stopgap_parse_Parser.prototype._nextRawTerm = function(self,endType) 
  if (endType == nil) then 
    endType = __blub_prolog_stopgap_parse_TokenType.token_term_end;
  end;
  local tok = self:getNext(true);
  if (tok.type == endType) then 
    do return nil end;
  end;
  local tmp = tok.type[1];
  if (tmp) == 0 then 
    do return __blub_prolog_terms_Variable.new(__lua_Boot.__cast(tok.value , String)) end;
  elseif (tmp) == 1 then 
    do return self:structureCheck(tok) end;
  elseif (tmp) == 2 or (tmp) == 3 then 
    do return __blub_prolog_terms_NumberTerm.new(__lua_Boot.__cast(tok.value , Float)) end;
  elseif (tmp) == 5 then 
    do return self:stringList(__lua_Boot.__cast(tok.value , String)) end;
  elseif (tmp) == 6 then 
    _G.error(__haxe_Exception.thrown(self:oops("unexpected end of term", tok)),0);
  elseif (tmp) == 7 then 
    _G.error(__haxe_Exception.thrown(self:oops("unexpected end of source")),0);
  elseif (tmp) == 8 then 
    do return __blub_prolog_terms_Structure.make(self.context:getAtom("()"), self:readUntil(__blub_prolog_stopgap_parse_TokenType.token_close_paren)) end;
  elseif (tmp) == 10 then 
    do return __blub_prolog_terms_Structure.make(self.context:getAtom("{}"), self:readUntil(__blub_prolog_stopgap_parse_TokenType.token_close_brace)) end;
  elseif (tmp) == 12 then 
    do return self:readList() end;else end;
  _G.error(__haxe_Exception.thrown(self:oops(Std.string("unexpected token: ") .. Std.string(Std.string(tok)), tok)),0);
end
__blub_prolog_stopgap_parse_Parser.prototype.stringList = function(self,s) 
  local t = __blub_prolog_terms_Structure.EMPTY_LIST;
  local i = __lua_lib_luautf8_Utf8.len(s) - 1;
  while (i >= 0) do 
    local bar = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST, _hx_tab_array({[0]=__blub_prolog_terms_NumberTerm.new(__lua_lib_luautf8_Utf8.byte(s, i + 1)), t}, 2));
    t = bar;
    i = i - 1;
  end;
  do return t end
end
__blub_prolog_stopgap_parse_Parser.prototype.readList = function(self) 
  local t = self:readUntil(__blub_prolog_stopgap_parse_TokenType.token_close_bracket);
  if (t == nil) then 
    do return __blub_prolog_terms_Structure.EMPTY_LIST end;
  end;
  local tail;
  local head;
  if (__lua_Boot.__instanceof(t, __blub_prolog_terms_Structure)) then 
    local s = __lua_Boot.__cast(t , __blub_prolog_terms_Structure);
    if (s:getName().text == "|") then 
      if (s:getArity() ~= 2) then 
        _G.error(__haxe_Exception.thrown(self:oops("list bar '|' requires terms on either side")),0);
      end;
      tail = s:argAt(1);
      head = s:argAt(0);
    else
      tail = __blub_prolog_terms_Structure.EMPTY_LIST;
      head = s;
    end;
  else
    tail = __blub_prolog_terms_Structure.EMPTY_LIST;
    head = t;
  end;
  if (__lua_Boot.__instanceof(head, __blub_prolog_terms_Structure) and ((__lua_Boot.__cast(head , __blub_prolog_terms_Structure)):getName().text == ",")) then 
    local headTerms = (__lua_Boot.__cast(head , __blub_prolog_terms_Structure)):flattenTree(",");
    while (headTerms.length > 0) do 
      local tailNode = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST, _hx_tab_array({[0]=headTerms:pop(), tail}, 2));
      tail = tailNode;
    end;
    do return tail end;
  end;
  local list = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST, _hx_tab_array({[0]=head, tail}, 2));
  do return list end
end
__blub_prolog_stopgap_parse_Parser.prototype.structureCheck = function(self,atom) 
  local tok = self:getNext(false);
  if ((self.lastWasOp and (atom.value == "-")) and ((tok.type == __blub_prolog_stopgap_parse_TokenType.token_int) or (tok.type == __blub_prolog_stopgap_parse_TokenType.token_float))) then 
    local val = __lua_Boot.__cast(tok.value , Float);
    val = -val;
    do return __blub_prolog_terms_NumberTerm.new(val) end;
  end;
  if (not self.operators:couldBeOp(atom.value) and (tok.type == __blub_prolog_stopgap_parse_TokenType.token_open_paren)) then 
    do return self:readStructure(atom) end;
  end;
  self:pushback(tok);
  local text = atom.value;
  local a = self.context:getAtom(text);
  do return a end
end
__blub_prolog_stopgap_parse_Parser.prototype.readStructure = function(self,functor) 
  local args = self:readUntil(__blub_prolog_stopgap_parse_TokenType.token_close_paren);
  if (args == nil) then 
    _G.error(__haxe_Exception.thrown(self:oops("invalid structure - empty parentheses", functor)),0);
  end;
  local argTerms;
  local stru = args:asStructure();
  if (stru ~= nil) then 
    argTerms = stru:flattenTree(",");
  else
    argTerms = Array.new();
    argTerms:push(args);
  end;
  do return __blub_prolog_terms_Structure.new(self.context:getAtom(__lua_Boot.__cast(functor.value , String)), argTerms) end
end
__blub_prolog_stopgap_parse_Parser.prototype.pushback = function(self,tok) 
  if (self.next ~= nil) then 
    _G.error(__haxe_Exception.thrown(self:oops("Pushback queue is too small", tok)),0);
  end;
  self.next = tok;
end
__blub_prolog_stopgap_parse_Parser.prototype.getNext = function(self,skipWS) 
  if (skipWS == nil) then 
    skipWS = true;
  end;
  local tok;
  if (self.next == nil) then 
    tok = self.lexer:next(skipWS);
  else
    if (skipWS and (self.next.type == __blub_prolog_stopgap_parse_TokenType.token_whitespace)) then 
      tok = self.lexer:next(true);
    else
      tok = self.next;
    end;
  end;
  self.next = nil;
  if (tok.type ~= __blub_prolog_stopgap_parse_TokenType.token_eof) then 
    self.lastReadToken = tok;
  end;
  do return tok end
end
__blub_prolog_stopgap_parse_Parser.prototype.oops = function(self,msg,tok) 
  if (tok == nil) then 
    tok = self.lastReadToken;
  end;
  do return __blub_prolog_stopgap_parse_ParseError.new(msg, self.origin, tok.startLine, tok.startCol) end
end

__blub_prolog_stopgap_parse_Parser.prototype.__class__ =  __blub_prolog_stopgap_parse_Parser

__blub_prolog_stopgap_parse_Token.new = function(type,chars,start,_end) 
  local self = _hx_new(__blub_prolog_stopgap_parse_Token.prototype)
  __blub_prolog_stopgap_parse_Token.super(self,type,chars,start,_end)
  return self
end
__blub_prolog_stopgap_parse_Token.super = function(self,type,chars,start,_end) 
  self.type = type;
  if (type == __blub_prolog_stopgap_parse_TokenType.token_eof) then 
    do return end;
  end;
  if (start == nil) then 
    start = chars[0];
  end;
  if (_end == nil) then 
    _end = chars[chars.length - 1];
  end;
  self.startLine = start.line;
  self.startCol = start.col;
  self.endLine = _end.line;
  self.endCol = _end.col;
  local s = chars:join("");
  if (type == __blub_prolog_stopgap_parse_TokenType.token_int) then 
    self.value = Std.parseInt(s);
  else
    if (type == __blub_prolog_stopgap_parse_TokenType.token_float) then 
      self.value = Std.parseFloat(s);
    else
      self.value = s;
    end;
  end;
end
_hxClasses["blub.prolog.stopgap.parse.Token"] = __blub_prolog_stopgap_parse_Token
__blub_prolog_stopgap_parse_Token.__name__ = "blub.prolog.stopgap.parse.Token"
__blub_prolog_stopgap_parse_Token.prototype = _hx_e();
__blub_prolog_stopgap_parse_Token.prototype.startLine= nil;
__blub_prolog_stopgap_parse_Token.prototype.startCol= nil;
__blub_prolog_stopgap_parse_Token.prototype.endLine= nil;
__blub_prolog_stopgap_parse_Token.prototype.endCol= nil;
__blub_prolog_stopgap_parse_Token.prototype.value= nil;
__blub_prolog_stopgap_parse_Token.prototype.type= nil;
__blub_prolog_stopgap_parse_Token.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(self.type)) .. Std.string(" [")) .. Std.string(self.startLine)) .. Std.string(":")) .. Std.string(self.startCol)) .. Std.string("-")) .. Std.string(self.endLine)) .. Std.string(":")) .. Std.string(self.endCol)) .. Std.string("] = '")) .. Std.string(Std.string(self.value))) .. Std.string("'") end
end

__blub_prolog_stopgap_parse_Token.prototype.__class__ =  __blub_prolog_stopgap_parse_Token
_hxClasses["blub.prolog.stopgap.parse.TokenType"] = __blub_prolog_stopgap_parse_TokenType;
_hxClasses["blub.prolog.stopgap.parse.TokenType"] = { __ename__ = "blub.prolog.stopgap.parse.TokenType", __constructs__ = _hx_tab_array({[0]="token_variable","token_atom","token_int","token_float","token_whitespace","token_string","token_term_end","token_eof","token_open_paren","token_close_paren","token_open_brace","token_close_brace","token_open_bracket","token_close_bracket"},14)}
__blub_prolog_stopgap_parse_TokenType = _hxClasses["blub.prolog.stopgap.parse.TokenType"];
__blub_prolog_stopgap_parse_TokenType.token_variable = _hx_tab_array({[0]="token_variable",0,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_atom = _hx_tab_array({[0]="token_atom",1,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_int = _hx_tab_array({[0]="token_int",2,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_float = _hx_tab_array({[0]="token_float",3,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_whitespace = _hx_tab_array({[0]="token_whitespace",4,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_string = _hx_tab_array({[0]="token_string",5,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_term_end = _hx_tab_array({[0]="token_term_end",6,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_eof = _hx_tab_array({[0]="token_eof",7,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_open_paren = _hx_tab_array({[0]="token_open_paren",8,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_close_paren = _hx_tab_array({[0]="token_close_paren",9,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_open_brace = _hx_tab_array({[0]="token_open_brace",10,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_close_brace = _hx_tab_array({[0]="token_close_brace",11,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_open_bracket = _hx_tab_array({[0]="token_open_bracket",12,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.token_close_bracket = _hx_tab_array({[0]="token_close_bracket",13,__enum__ = __blub_prolog_stopgap_parse_TokenType},2)

__blub_prolog_stopgap_parse_TokenType.__empty_constructs__ = _hx_tab_array({[0] = __blub_prolog_stopgap_parse_TokenType.token_variable,__blub_prolog_stopgap_parse_TokenType.token_atom,__blub_prolog_stopgap_parse_TokenType.token_int,__blub_prolog_stopgap_parse_TokenType.token_float,__blub_prolog_stopgap_parse_TokenType.token_whitespace,__blub_prolog_stopgap_parse_TokenType.token_string,__blub_prolog_stopgap_parse_TokenType.token_term_end,__blub_prolog_stopgap_parse_TokenType.token_eof,__blub_prolog_stopgap_parse_TokenType.token_open_paren,__blub_prolog_stopgap_parse_TokenType.token_close_paren,__blub_prolog_stopgap_parse_TokenType.token_open_brace,__blub_prolog_stopgap_parse_TokenType.token_close_brace,__blub_prolog_stopgap_parse_TokenType.token_open_bracket,__blub_prolog_stopgap_parse_TokenType.token_close_bracket}, 14)

__blub_prolog_terms_ListTerm.new = {}
_hxClasses["blub.prolog.terms.ListTerm"] = __blub_prolog_terms_ListTerm
__blub_prolog_terms_ListTerm.__name__ = "blub.prolog.terms.ListTerm"
__blub_prolog_terms_ListTerm.__interfaces__ = {__blub_prolog_terms_ValueTerm}
__blub_prolog_terms_ListTerm.prototype = _hx_e();
__blub_prolog_terms_ListTerm.prototype.listToArray= nil;

__blub_prolog_terms_ListTerm.prototype.__class__ =  __blub_prolog_terms_ListTerm

__blub_prolog_terms_Atom.new = function(text) 
  local self = _hx_new(__blub_prolog_terms_Atom.prototype)
  __blub_prolog_terms_Atom.super(self,text)
  return self
end
__blub_prolog_terms_Atom.super = function(self,text) 
  self.text = text;
end
_hxClasses["blub.prolog.terms.Atom"] = __blub_prolog_terms_Atom
__blub_prolog_terms_Atom.__name__ = "blub.prolog.terms.Atom"
__blub_prolog_terms_Atom.__interfaces__ = {__blub_prolog_terms_ListTerm,__blub_prolog_terms_ClauseTerm}
__blub_prolog_terms_Atom.newUniqueAtom = function(prefix) 
  local tmp = Std.string(prefix) .. Std.string((function() 
  local _hx_obj = __blub_prolog_terms_Atom;
  local _hx_fld = 'ID_GEN';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)());
  do return __blub_prolog_terms_Atom.new(tmp) end;
end
__blub_prolog_terms_Atom.unregisteredAtom = function(text) 
  do return __blub_prolog_terms_Atom.new(text) end;
end
__blub_prolog_terms_Atom.unquote = function(text) 
  if (StringTools.startsWith(text, "'") and StringTools.endsWith(text, "'")) then 
    local pos = 1;
    local len = __lua_lib_luautf8_Utf8.len(text) - 2;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(text)))) then 
      len = __lua_lib_luautf8_Utf8.len(text);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(text) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(text) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(text, pos + 1, pos + len) end;
  end;
  do return nil end;
end
__blub_prolog_terms_Atom.escape = function(s) 
  if (s == nil) then 
    do return nil end;
  end;
  if (__lua_lib_luautf8_Utf8.len(s) == 0) then 
    do return "''" end;
  end;
  if ((s == "{}") or (s == "[]")) then 
    do return s end;
  end;
  local b = StringBuf.new();
  local needsEscape = false;
  local code = __lua_lib_luautf8_Utf8.byte(s, 1);
  local char = __lua_lib_luautf8_Utf8.sub(s, 1, 1);
  if (((code >= __blub_prolog_terms_Atom.a_CODE) and (code <= __blub_prolog_terms_Atom.z_CODE)) or __blub_prolog_stopgap_parse_Char.isOpChar_(char)) then 
    needsEscape = false;
  else
    needsEscape = true;
  end;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(s);
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    code = __lua_lib_luautf8_Utf8.byte(s, i + 1);
    if ((((code == __blub_prolog_terms_Atom.under_CODE) or ((code >= __blub_prolog_terms_Atom.A_CODE) and (code <= __blub_prolog_terms_Atom.Z_CODE))) or ((code >= __blub_prolog_terms_Atom.a_CODE) and (code <= __blub_prolog_terms_Atom.z_CODE))) or ((code >= __blub_prolog_terms_Atom.zero_CODE) and (code <= __blub_prolog_terms_Atom.nine_CODE))) then 
      _G.table.insert(b.b, __lua_lib_luautf8_Utf8.char(code));
      local b = b;
      b.length = b.length + 1;
      break;
    end;
    char = __lua_lib_luautf8_Utf8.sub(s, i + 1, i + 1);
    if (__blub_prolog_stopgap_parse_Char.isOpChar_(char)) then 
      local str = Std.string(char);
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
      break;
    end;
    needsEscape = true;
    local str;
    local char1 = char;
    if (char1) == "\t" then 
      str = " ";
    elseif (char1) == "\n" then 
      str = " ";
    elseif (char1) == "\r" then 
      str = " ";
    elseif (char1) == "'" then 
      str = "''";
    elseif (char1) == "\\" then 
      str = "\\\\";else
    str = char; end;
    local str = Std.string(str);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (needsEscape) then 
    do return Std.string(Std.string("'") .. Std.string(Std.string(b))) .. Std.string("'") end;
  else
    do return s end;
  end;
end
__blub_prolog_terms_Atom.prototype = _hx_e();
__blub_prolog_terms_Atom.prototype.object= nil;
__blub_prolog_terms_Atom.prototype.text= nil;
__blub_prolog_terms_Atom.prototype.getIndicator = function(self) 
  do return __blub_prolog_PredicateIndicator.new(self, 0) end
end
__blub_prolog_terms_Atom.prototype.getHead = function(self) 
  do return self end
end
__blub_prolog_terms_Atom.prototype.getBody = function(self) 
  do return nil end
end
__blub_prolog_terms_Atom.prototype.getFunctor = function(self) 
  do return Std.string(self.text) .. Std.string("/0") end
end
__blub_prolog_terms_Atom.prototype.getArgs = function(self) 
  do return _hx_tab_array({}, 0) end
end
__blub_prolog_terms_Atom.prototype.getNameText = function(self) 
  do return self.text end
end
__blub_prolog_terms_Atom.prototype.toString = function(self) 
  do return __blub_prolog_terms_Atom.escape(self.text) end
end
__blub_prolog_terms_Atom.prototype.asValueTerm = function(self) 
  do return self end
end
__blub_prolog_terms_Atom.prototype.asAtom = function(self) 
  do return self end
end
__blub_prolog_terms_Atom.prototype.asStructure = function(self) 
  do return nil end
end
__blub_prolog_terms_Atom.prototype.asNumber = function(self) 
  do return nil end
end
__blub_prolog_terms_Atom.prototype.asReference = function(self) 
  do return nil end
end
__blub_prolog_terms_Atom.prototype.asUnchasedReference = function(self) 
  do return nil end
end
__blub_prolog_terms_Atom.prototype.isGround = function(self) 
  do return true end
end
__blub_prolog_terms_Atom.prototype.hasReferences = function(self) 
  do return false end
end
__blub_prolog_terms_Atom.prototype.hasVariables = function(self) 
  do return false end
end
__blub_prolog_terms_Atom.prototype.dereference = function(self) 
  do return self end
end
__blub_prolog_terms_Atom.prototype.toValue = function(self,env) 
  do return self end
end
__blub_prolog_terms_Atom.prototype.commaSeparated = function(self) 
  do return _hx_tab_array({[0]=self}, 1) end
end
__blub_prolog_terms_Atom.prototype.gatherReferences = function(self,refs) 
  if (refs ~= nil) then 
    do return refs end;
  end;
  do return _hx_tab_array({}, 0) end
end
__blub_prolog_terms_Atom.prototype.couldMatch = function(self,arg) 
  if (arg:asReference() ~= nil) then 
    do return true end;
  end;
  do return self:equals(arg) end
end
__blub_prolog_terms_Atom.prototype.match = function(self,other,env,trail) 
  do return self:equals(other:dereference()) end
end
__blub_prolog_terms_Atom.prototype.equals = function(self,other) 
  if (other == nil) then 
    do return false end;
  end;
  local otherAtom = other:asAtom();
  if (otherAtom == nil) then 
    do return false end;
  end;
  if (self == otherAtom) then 
    do return true end;
  end;
  if ((self.object ~= nil) and (otherAtom.object ~= nil)) then 
    do return self.object == otherAtom.object end;
  end;
  do return self.text == otherAtom.text end
end
__blub_prolog_terms_Atom.prototype.unify = function(self,other,trail) 
  if (other:asReference() ~= nil) then 
    do return other:unify(self, trail) end;
  end;
  do return self:equals(other) end
end
__blub_prolog_terms_Atom.prototype.isList = function(self) 
  do return self == __blub_prolog_terms_Structure.EMPTY_LIST end
end
__blub_prolog_terms_Atom.prototype.listToArray = function(self) 
  if (self:isList()) then 
    do return _hx_tab_array({}, 0) end;
  end;
  do return nil end
end

__blub_prolog_terms_Atom.prototype.__class__ =  __blub_prolog_terms_Atom

__blub_prolog_terms_NumberTerm.new = function(value) 
  local self = _hx_new(__blub_prolog_terms_NumberTerm.prototype)
  __blub_prolog_terms_NumberTerm.super(self,value)
  return self
end
__blub_prolog_terms_NumberTerm.super = function(self,value) 
  self.value = value;
end
_hxClasses["blub.prolog.terms.NumberTerm"] = __blub_prolog_terms_NumberTerm
__blub_prolog_terms_NumberTerm.__name__ = "blub.prolog.terms.NumberTerm"
__blub_prolog_terms_NumberTerm.__interfaces__ = {__blub_prolog_terms_ValueTerm}
__blub_prolog_terms_NumberTerm.prototype = _hx_e();
__blub_prolog_terms_NumberTerm.prototype.value= nil;
__blub_prolog_terms_NumberTerm.prototype.asValueTerm = function(self) 
  do return self end
end
__blub_prolog_terms_NumberTerm.prototype.asAtom = function(self) 
  do return nil end
end
__blub_prolog_terms_NumberTerm.prototype.asStructure = function(self) 
  do return nil end
end
__blub_prolog_terms_NumberTerm.prototype.asNumber = function(self) 
  do return self end
end
__blub_prolog_terms_NumberTerm.prototype.asReference = function(self) 
  do return nil end
end
__blub_prolog_terms_NumberTerm.prototype.asUnchasedReference = function(self) 
  do return nil end
end
__blub_prolog_terms_NumberTerm.prototype.isGround = function(self) 
  do return true end
end
__blub_prolog_terms_NumberTerm.prototype.hasReferences = function(self) 
  do return false end
end
__blub_prolog_terms_NumberTerm.prototype.hasVariables = function(self) 
  do return false end
end
__blub_prolog_terms_NumberTerm.prototype.dereference = function(self) 
  do return self end
end
__blub_prolog_terms_NumberTerm.prototype.toValue = function(self,env) 
  do return self end
end
__blub_prolog_terms_NumberTerm.prototype.commaSeparated = function(self) 
  do return _hx_tab_array({[0]=self}, 1) end
end
__blub_prolog_terms_NumberTerm.prototype.gatherReferences = function(self,refs) 
  if (refs ~= nil) then 
    do return refs end;
  end;
  do return _hx_tab_array({}, 0) end
end
__blub_prolog_terms_NumberTerm.prototype.toString = function(self) 
  do return Std.string(self.value) end
end
__blub_prolog_terms_NumberTerm.prototype.equals = function(self,other) 
  local otherNum = other:asNumber();
  if (otherNum == nil) then 
    do return false end;
  end;
  do return otherNum.value == self.value end
end
__blub_prolog_terms_NumberTerm.prototype.match = function(self,other,env,trail) 
  do return self:equals(other:dereference()) end
end
__blub_prolog_terms_NumberTerm.prototype.couldMatch = function(self,arg) 
  if (arg:asReference() ~= nil) then 
    do return true end;
  end;
  do return self:equals(arg) end
end
__blub_prolog_terms_NumberTerm.prototype.unify = function(self,other,trail) 
  if (other:asReference() ~= nil) then 
    do return other:unify(self, trail) end;
  end;
  do return self:equals(other) end
end

__blub_prolog_terms_NumberTerm.prototype.__class__ =  __blub_prolog_terms_NumberTerm

__blub_prolog_terms_Structure.new = function(name,arguments) 
  local self = _hx_new(__blub_prolog_terms_Structure.prototype)
  __blub_prolog_terms_Structure.super(self,name,arguments)
  return self
end
__blub_prolog_terms_Structure.super = function(self,name,arguments) 
  self.atom = name;
  if (arguments ~= nil) then 
    self.args = arguments;
    local _g = 0;
    local _g1 = self.args;
    while (_g < _g1.length) do 
      local arg = _g1[_g];
      _g = _g + 1;
      self.hasRefs = self.hasRefs or arg:hasReferences();
      self.hasVars = self.hasVars or arg:hasVariables();
    end;
  else
    self.args = Array.new();
  end;
end
_hxClasses["blub.prolog.terms.Structure"] = __blub_prolog_terms_Structure
__blub_prolog_terms_Structure.__name__ = "blub.prolog.terms.Structure"
__blub_prolog_terms_Structure.__interfaces__ = {__blub_prolog_terms_ListTerm,__blub_prolog_terms_ClauseTerm}
__blub_prolog_terms_Structure.make = function(functor,arg) 
  local s = __blub_prolog_terms_Structure.new(functor, _hx_tab_array({[0]=arg}, 1));
  do return s end;
end
__blub_prolog_terms_Structure.make2 = function(functor,arg1,arg2) 
  local s = __blub_prolog_terms_Structure.new(functor, _hx_tab_array({[0]=arg1, arg2}, 2));
  do return s end;
end
__blub_prolog_terms_Structure.makeList = function(elems) 
  if (elems.length == 0) then 
    do return __blub_prolog_terms_Structure.EMPTY_LIST end;
  end;
  local tail = __blub_prolog_terms_Structure.EMPTY_LIST;
  while (elems.length > 0) do 
    local elem = elems:pop();
    local s = __blub_prolog_terms_Structure.new(__blub_prolog_terms_Structure.CONS_LIST);
    s:addArg(elem);
    s:addArg(tail);
    tail = s;
  end;
  do return tail end;
end
__blub_prolog_terms_Structure.prototype = _hx_e();
__blub_prolog_terms_Structure.prototype.args= nil;
__blub_prolog_terms_Structure.prototype.atom= nil;
__blub_prolog_terms_Structure.prototype.hasVars= nil;
__blub_prolog_terms_Structure.prototype.hasRefs= nil;
__blub_prolog_terms_Structure.prototype.varContext= nil;
__blub_prolog_terms_Structure.prototype.variableContext= nil;
__blub_prolog_terms_Structure.prototype.addArg = function(self,t) 
  self.args:push(t);
  self.hasRefs = self.hasRefs or t:hasReferences();
  self.hasVars = self.hasVars or t:hasVariables();
end
__blub_prolog_terms_Structure.prototype.prependArg = function(self,t) 
  self.args:unshift(t);
  self.hasRefs = self.hasRefs or t:hasReferences();
  self.hasVars = self.hasVars or t:hasVariables();
end
__blub_prolog_terms_Structure.prototype.updateArg = function(self,arg) 
  self.hasRefs = self.hasRefs or arg:hasReferences();
  self.hasVars = self.hasVars or arg:hasVariables();
end
__blub_prolog_terms_Structure.prototype.forceHasRefs = function(self) 
  self.hasRefs = true;
end
__blub_prolog_terms_Structure.prototype.asValueTerm = function(self) 
  do return self end
end
__blub_prolog_terms_Structure.prototype.asAtom = function(self) 
  do return nil end
end
__blub_prolog_terms_Structure.prototype.asStructure = function(self) 
  do return self end
end
__blub_prolog_terms_Structure.prototype.asNumber = function(self) 
  do return nil end
end
__blub_prolog_terms_Structure.prototype.asReference = function(self) 
  do return nil end
end
__blub_prolog_terms_Structure.prototype.asUnchasedReference = function(self) 
  do return nil end
end
__blub_prolog_terms_Structure.prototype.hasReferences = function(self) 
  do return self.hasRefs end
end
__blub_prolog_terms_Structure.prototype.hasVariables = function(self) 
  do return self.hasVars end
end
__blub_prolog_terms_Structure.prototype.isGround = function(self) 
  if (self.hasVars) then 
    do return false end;
  end;
  do return not self:hasUnboundRefs() end
end
__blub_prolog_terms_Structure.prototype.equals = function(self,other) 
  local otherS = other:asStructure();
  if (otherS == nil) then 
    do return false end;
  end;
  if (not self.atom:equals(otherS.atom)) then 
    do return false end;
  end;
  if (self.args.length ~= otherS.args.length) then 
    do return false end;
  end;
  local _g = 0;
  local _g1 = self.args.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (not self.args[i]:equals(otherS.args[i])) then 
      do return false end;
    end;
  end;
  do return true end
end
__blub_prolog_terms_Structure.prototype.match = function(self,other,env,trail) 
  local otherStruct = other:asStructure();
  if (otherStruct == nil) then 
    do return false end;
  end;
  if (not self.atom:equals(otherStruct.atom)) then 
    do return false end;
  end;
  if (self.args.length ~= otherStruct.args.length) then 
    do return false end;
  end;
  local otherArgs = otherStruct.args;
  local _g = 0;
  local _g1 = self.args.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (not self.args[i]:match(otherArgs[i]:asValueTerm(), env, trail)) then 
      do return false end;
    end;
  end;
  do return true end
end
__blub_prolog_terms_Structure.prototype.couldMatch = function(self,arg) 
  if (arg:asReference() ~= nil) then 
    do return true end;
  end;
  local argStruct = arg:asStructure();
  if (argStruct == nil) then 
    do return false end;
  end;
  if (argStruct.atom:equals(self.atom)) then 
    do return argStruct:getArity() == self:getArity() end;
  else
    do return false end;
  end;
end
__blub_prolog_terms_Structure.prototype.unify = function(self,other,trail) 
  if (other:asReference() ~= nil) then 
    do return other:unify(self, trail) end;
  end;
  local stru = other:asStructure();
  if (stru == nil) then 
    do return false end;
  end;
  if (not self.atom:equals(stru.atom)) then 
    do return false end;
  end;
  if (self.args.length ~= stru.args.length) then 
    do return false end;
  end;
  local _g = 0;
  local _g1 = self.args.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local arg1 = self.args[i]:asValueTerm();
    local arg2 = stru.args[i]:asValueTerm();
    if (not arg1:unify(arg2, trail)) then 
      do return false end;
    end;
  end;
  do return true end
end
__blub_prolog_terms_Structure.prototype.isConjunction = function(self) 
  if (self.args.length == 2) then 
    do return self.atom.text == "," end;
  else
    do return false end;
  end;
end
__blub_prolog_terms_Structure.prototype.isDisjunction = function(self) 
  if (self.args.length == 2) then 
    do return self.atom.text == ";" end;
  else
    do return false end;
  end;
end
__blub_prolog_terms_Structure.prototype.variablize = function(self,varMap) 
  if (self.hasVars) then 
    do return self end;
  end;
  if (not self.hasRefs) then 
    do return self end;
  end;
  if (varMap == nil) then 
    varMap = __haxe_ds_ObjectMap.new();
  end;
  local copy = __blub_prolog_terms_Structure.new(self.atom);
  local _g = 0;
  local _g1 = self.args;
  while (_g < _g1.length) do 
    local arg = _g1[_g];
    _g = _g + 1;
    local ref = arg:asReference();
    if (ref ~= nil) then 
      local v = varMap.h[ref];
      if (v == nil) then 
        v = __blub_prolog_terms_Variable.new(ref:get_name());
        varMap.h[ref] = v;
        varMap.k[ref] = true;
      end;
      copy:addArg(v);
    else
      local stru = arg:asStructure();
      if (stru ~= nil) then 
        copy:addArg(stru:variablize(varMap));
      else
        copy:addArg(arg);
      end;
    end;
  end;
  do return copy end
end
__blub_prolog_terms_Structure.prototype.unpackParentheses = function(self) 
  if (self.atom.text == "()") then 
    local s = self:argAt(0):asStructure();
    if (s ~= nil) then 
      do return s:unpackParentheses() end;
    end;
    do return self:argAt(0) end;
  end;
  local _g = 0;
  local _g1 = self.args.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local s = self.args[i]:asStructure();
    if (s ~= nil) then 
      self.args[i] = s:unpackParentheses();
    end;
  end;
  do return self end
end
__blub_prolog_terms_Structure.prototype.toValue = function(self,env) 
  if (not self.hasVars) then 
    do return self end;
  end;
  local copy = __blub_prolog_terms_Structure.new(self.atom);
  local _g = 0;
  local _g1 = self.args;
  while (_g < _g1.length) do 
    local arg = _g1[_g];
    _g = _g + 1;
    copy:addArg(arg:toValue(env));
  end;
  do return copy end
end
__blub_prolog_terms_Structure.prototype.varsToReferences = function(self) 
  if (not self.hasVars) then 
    do return self end;
  end;
  local env = self:get_variableContext():createNamedEnvironment();
  do return self:toValue(env) end
end
__blub_prolog_terms_Structure.prototype.hasUnboundRefs = function(self) 
  if (not self.hasRefs) then 
    do return false end;
  end;
  if (self.atom == __blub_prolog_terms_Structure.CONS_LIST) then 
    local queue = __haxe_ds_List.new();
    queue:add(self);
    while (not queue:isEmpty()) do 
      local s = queue:pop();
      local arg1 = s:argAt(0);
      if (not arg1:isGround()) then 
        do return true end;
      end;
      local arg2 = s:argAt(1);
      local str = arg2:asStructure();
      if ((str ~= nil) and (str.atom == __blub_prolog_terms_Structure.CONS_LIST)) then 
        queue:add(str);
      else
        if (not arg2:isGround()) then 
          do return true end;
        end;
      end;
    end;
  else
    local _g = 0;
    local _g1 = self.args;
    while (_g < _g1.length) do 
      local arg = _g1[_g];
      _g = _g + 1;
      if (not arg:isGround()) then 
        do return true end;
      end;
    end;
  end;
  do return false end
end
__blub_prolog_terms_Structure.prototype.gatherReferences = function(self,refs) 
  if (refs == nil) then 
    refs = _hx_tab_array({}, 0);
  end;
  local _g = 0;
  local _g1 = self.args;
  while (_g < _g1.length) do 
    local arg = _g1[_g];
    _g = _g + 1;
    local vt = arg:asValueTerm();
    if (vt ~= nil) then 
      vt:gatherReferences(refs);
    end;
  end;
  do return refs end
end
__blub_prolog_terms_Structure.prototype.dereference = function(self) 
  if (not self.hasRefs) then 
    do return self end;
  end;
  if (self.atom == __blub_prolog_terms_Structure.CONS_LIST) then 
    local elems = _hx_tab_array({}, 0);
    local head = self;
    while (true) do 
      if (not head.hasRefs) then 
        elems:push(head);
        break;
      end;
      local headCopy = __blub_prolog_terms_Structure.new(head:getName());
      headCopy:addArg(head:argAt(0):asValueTerm():dereference());
      elems:push(headCopy);
      if (head:argAt(1) == nil) then 
        break;
      end;
      local next = head:argAt(1):asValueTerm();
      if (next:asStructure() ~= nil) then 
        head = next:asStructure();
      else
        headCopy:addArg(next:dereference());
        break;
      end;
    end;
    local tail = nil;
    while (elems.length > 0) do 
      local elem = elems:pop();
      if (tail ~= nil) then 
        elem:addArg(tail);
      end;
      tail = elem;
    end;
    do return tail:asStructure() end;
  else
    local copy = __blub_prolog_terms_Structure.new(self.atom);
    local _g = 0;
    local _g1 = self.args;
    while (_g < _g1.length) do 
      local arg = _g1[_g];
      _g = _g + 1;
      local valTerm = arg;
      copy:addArg(valTerm:dereference());
    end;
    do return copy end;
  end;
end
__blub_prolog_terms_Structure.prototype.getHead = function(self) 
  if (((self.atom.text == ":-") and (self.args.length == 2)) and __lua_Boot.__instanceof(self.args[0], __blub_prolog_terms_ClauseTerm)) then 
    do return __lua_Boot.__cast(self.args[0] , __blub_prolog_terms_ClauseTerm) end;
  end;
  do return self end
end
__blub_prolog_terms_Structure.prototype.getBody = function(self) 
  if (((self.atom.text == ":-") and (self.args.length == 2)) and __lua_Boot.__instanceof(self.args[1], __blub_prolog_terms_ClauseTerm)) then 
    do return __lua_Boot.__cast(self.args[1] , __blub_prolog_terms_ClauseTerm) end;
  end;
  do return nil end
end
__blub_prolog_terms_Structure.prototype.get_variableContext = function(self) 
  if (self.varContext == nil) then 
    local name2var = __haxe_ds_StringMap.new();
    local index2var = Array.new();
    self:initContext(__blub_prolog_terms_VariableContext.new(self, name2var, index2var), name2var, index2var);
  end;
  do return self.varContext end
end
__blub_prolog_terms_Structure.prototype.useVarContext = function(self,context,name2var,index2var) 
  self:initContext(context, name2var, index2var);
end
__blub_prolog_terms_Structure.prototype.initContext = function(self,context,name2var,index2var) 
  self.varContext = context;
  local _g = 0;
  local _g1 = self.args.length;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local arg = self.args[i];
    if (__lua_Boot.__instanceof(arg, __blub_prolog_terms_Variable)) then 
      local argVar = __lua_Boot.__cast(arg , __blub_prolog_terms_Variable);
      if (argVar:get_name() == "_") then 
        break;
      end;
      local key = argVar:get_name();
      local ret = name2var.h[key];
      if (ret == __haxe_ds_StringMap.tnull) then 
        ret = nil;
      end;
      local v = ret;
      if (v == nil) then 
        if (argVar.index ~= -1) then 
          __haxe_Log.trace(Std.string(Std.string(Std.string("OOPS ") .. Std.string(argVar:get_name())) .. Std.string(" ")) .. Std.string(Std.string(self)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/blub/prolog/terms/Structure.hx",lineNumber=434,className="blub.prolog.terms.Structure",methodName="initContext"}));
        end;
        argVar:initIndex(index2var.length);
        local key = argVar:get_name();
        if (argVar == nil) then 
          name2var.h[key] = __haxe_ds_StringMap.tnull;
        else
          name2var.h[key] = argVar;
        end;
        index2var:push(argVar);
      else
        self.args[i] = v;
      end;
    else
      if (__lua_Boot.__instanceof(arg, __blub_prolog_terms_Structure)) then 
        local argStruct = __lua_Boot.__cast(arg , __blub_prolog_terms_Structure);
        argStruct:initContext(context, name2var, index2var);
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__blub_prolog_terms_Structure.prototype.argAt = function(self,index) 
  do return self.args[index] end
end
__blub_prolog_terms_Structure.prototype.getArgs = function(self) 
  do return self.args end
end
__blub_prolog_terms_Structure.prototype.getArity = function(self) 
  do return self.args.length end
end
__blub_prolog_terms_Structure.prototype.getName = function(self) 
  do return self.atom end
end
__blub_prolog_terms_Structure.prototype.getIndicator = function(self) 
  do return __blub_prolog_PredicateIndicator.new(self.atom, self.args.length) end
end
__blub_prolog_terms_Structure.prototype.getFunctor = function(self) 
  do return Std.string(Std.string(self.atom.text) .. Std.string("/")) .. Std.string(self.args.length) end
end
__blub_prolog_terms_Structure.prototype.getNameText = function(self) 
  do return self.atom.text end
end
__blub_prolog_terms_Structure.prototype.clone = function(self,fn) 
  local s = __blub_prolog_terms_Structure.new(self.atom);
  local _g = 0;
  local _g1 = self.args;
  while (_g < _g1.length) do 
    local a = _g1[_g];
    _g = _g + 1;
    s:addArg(fn(a));
  end;
  do return s end
end
__blub_prolog_terms_Structure.prototype.flattenTree = function(self,func) 
  if (func == nil) then 
    func = self.atom.text;
  end;
  local terms = Array.new();
  local tree = self;
  while (true) do 
    if ((tree.atom.text == func) and (tree.args.length == 2)) then 
      local args = tree.args;
      terms:push(args[0]);
      if (__lua_Boot.__instanceof(args[1], __blub_prolog_terms_Structure)) then 
        tree = __lua_Boot.__cast(args[1] , __blub_prolog_terms_Structure);
      else
        terms:push(args[1]);
        break;
      end;
    else
      terms:push(tree);
      break;
    end;
  end;
  do return terms end
end
__blub_prolog_terms_Structure.prototype.commaSeparated = function(self) 
  do return self:commaList() end
end
__blub_prolog_terms_Structure.prototype.commaList = function(self,array) 
  if (array == nil) then 
    array = Array.new();
  end;
  if (self.atom.text == ",") then 
    array:push(self.args[0]);
    local arg1struct = self.args[1]:asStructure();
    if (arg1struct ~= nil) then 
      arg1struct:commaList(array);
    else
      array:push(self.args[1]);
    end;
    do return array end;
  else
    array:push(self);
  end;
  do return array end
end
__blub_prolog_terms_Structure.prototype.couldBeList = function(self) 
  if (self.atom == __blub_prolog_terms_Structure.CONS_LIST) then 
    do return self:getArity() == 2 end;
  else
    do return false end;
  end;
end
__blub_prolog_terms_Structure.prototype.isList = function(self) 
  local str = self;
  while ((str.atom == __blub_prolog_terms_Structure.CONS_LIST) and (str:getArity() == 2)) do 
    local tail = str:argAt(1);
    local atm = tail:asAtom();
    if (atm ~= nil) then 
      do return atm:isList() end;
    end;
    local ref = tail:asReference();
    if (ref ~= nil) then 
      do return true end;
    end;
    str = tail:asStructure();
    if (str == nil) then 
      do return false end;
    end;
  end;
  do return false end
end
__blub_prolog_terms_Structure.prototype.listIterator = function(self) 
  do return __blub_prolog_terms__Structure_ListIterator.new(self) end
end
__blub_prolog_terms_Structure.prototype.listStructureIterator = function(self) 
  do return __blub_prolog_terms__Structure_ListStructureIterator.new(self) end
end
__blub_prolog_terms_Structure.prototype.listToArray = function(self) 
  do return self:toArray() end
end
__blub_prolog_terms_Structure.prototype.toArray = function(self,array) 
  if (self.atom == __blub_prolog_terms_Structure.CONS_LIST) then 
    if (array == nil) then 
      array = Array.new();
    end;
    array:push(self.args[0]);
    local s = self.args[1]:asStructure();
    if (s ~= nil) then 
      s:toArray(array);
    end;
    do return array end;
  end;
  do return nil end
end
__blub_prolog_terms_Structure.prototype.listToString = function(self) 
  local buf_b = ({});
  local buf_length = 0;
  local str = "[";
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  local stru = self;
  local _hx_continue_1 = false;
  while (true) do repeat 
    local arg0 = stru:argAt(0);
    if (arg0 == nil) then 
      local str = "<???>";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      _hx_continue_1 = true;break;
    end;
    local str = Std.string(arg0:toString());
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    local tail = stru:argAt(1);
    if (tail == nil) then 
      local str = "|<???>";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      _hx_continue_1 = true;break;
    end;
    if (tail:asReference() ~= nil) then 
      tail = tail:asReference():dereference();
    end;
    if (tail == __blub_prolog_terms_Structure.EMPTY_LIST) then 
      _hx_continue_1 = true;break;
    end;
    local tailS = tail:asStructure();
    if ((tailS ~= nil) and (tailS.atom == __blub_prolog_terms_Structure.CONS_LIST)) then 
      local str = ",";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
      stru = tailS;
      break;
    end;
    local str = "|";
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(tail:toString());
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    _hx_continue_1 = true;break;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local str = "]";
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(buf_b) end
end
__blub_prolog_terms_Structure.prototype.commaToString = function(self,s) 
  if (s == nil) then 
    s = "(";
  end;
  if (self.atom.text == ",") then 
    local _g = 0;
    local _g1 = self.args.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (i > 0) then 
        s = Std.string(s) .. Std.string(",");
      end;
      if (__lua_Boot.__instanceof(self.args[i], __blub_prolog_terms_Structure)) then 
        s = (__lua_Boot.__cast(self.args[i] , __blub_prolog_terms_Structure)):commaToString(s);
      else
        s = Std.string(s) .. Std.string((Std.string("") .. Std.string(Std.string(self.args[i]))));
      end;
    end;
  else
    s = Std.string(s) .. Std.string(self:toString());
  end;
  do return s end
end
__blub_prolog_terms_Structure.prototype.toString = function(self) 
  if (self.atom == __blub_prolog_terms_Structure.CONS_LIST) then 
    do return self:listToString() end;
  end;
  if (self.atom.text == ",") then 
    do return Std.string(self:commaToString()) .. Std.string(")") end;
  end;
  local s = self.atom:toString();
  s = Std.string(s) .. Std.string("( ");
  local first = true;
  local _g = 0;
  local _g1 = self.args;
  while (_g < _g1.length) do 
    local t = _g1[_g];
    _g = _g + 1;
    if (first) then 
      first = false;
    else
      s = Std.string(s) .. Std.string(", ");
    end;
    s = Std.string(s) .. Std.string(Std.string(t));
  end;
  s = Std.string(s) .. Std.string(" )");
  do return s end
end

__blub_prolog_terms_Structure.prototype.__class__ =  __blub_prolog_terms_Structure

__blub_prolog_terms_Structure.prototype.__properties__ =  {get_variableContext="get_variableContext"}

__blub_prolog_terms__Structure_ListStructureIterator.new = function(s) 
  local self = _hx_new(__blub_prolog_terms__Structure_ListStructureIterator.prototype)
  __blub_prolog_terms__Structure_ListStructureIterator.super(self,s)
  return self
end
__blub_prolog_terms__Structure_ListStructureIterator.super = function(self,s) 
  self.s = s;
end
_hxClasses["blub.prolog.terms._Structure.ListStructureIterator"] = __blub_prolog_terms__Structure_ListStructureIterator
__blub_prolog_terms__Structure_ListStructureIterator.__name__ = "blub.prolog.terms._Structure.ListStructureIterator"
__blub_prolog_terms__Structure_ListStructureIterator.prototype = _hx_e();
__blub_prolog_terms__Structure_ListStructureIterator.prototype.s= nil;
__blub_prolog_terms__Structure_ListStructureIterator.prototype.next = function(self) 
  if (self.s:getName() == __blub_prolog_terms_Structure.CONS_LIST) then 
    local stru = self.s;
    self.s = self.s:argAt(1):asStructure();
    do return stru end;
  end;
  do return nil end
end
__blub_prolog_terms__Structure_ListStructureIterator.prototype.hasNext = function(self) 
  do return self.s:getName() == __blub_prolog_terms_Structure.CONS_LIST end
end

__blub_prolog_terms__Structure_ListStructureIterator.prototype.__class__ =  __blub_prolog_terms__Structure_ListStructureIterator

__blub_prolog_terms__Structure_ListIterator.new = function(s) 
  local self = _hx_new(__blub_prolog_terms__Structure_ListIterator.prototype)
  __blub_prolog_terms__Structure_ListIterator.super(self,s)
  return self
end
__blub_prolog_terms__Structure_ListIterator.super = function(self,s) 
  self.s = s;
end
_hxClasses["blub.prolog.terms._Structure.ListIterator"] = __blub_prolog_terms__Structure_ListIterator
__blub_prolog_terms__Structure_ListIterator.__name__ = "blub.prolog.terms._Structure.ListIterator"
__blub_prolog_terms__Structure_ListIterator.prototype = _hx_e();
__blub_prolog_terms__Structure_ListIterator.prototype.s= nil;
__blub_prolog_terms__Structure_ListIterator.prototype.next = function(self) 
  if (self.s:getName() == __blub_prolog_terms_Structure.CONS_LIST) then 
    local elem = self.s:argAt(0);
    self.s = self.s:argAt(1):asStructure();
    do return elem end;
  end;
  do return nil end
end
__blub_prolog_terms__Structure_ListIterator.prototype.hasNext = function(self) 
  do return self.s:getName() == __blub_prolog_terms_Structure.CONS_LIST end
end

__blub_prolog_terms__Structure_ListIterator.prototype.__class__ =  __blub_prolog_terms__Structure_ListIterator

__blub_prolog_terms_TermParse.new = {}
_hx_exports["blub"]["prolog"]["terms"]["TermParse"] = __blub_prolog_terms_TermParse
_hxClasses["blub.prolog.terms.TermParse"] = __blub_prolog_terms_TermParse
__blub_prolog_terms_TermParse.__name__ = "blub.prolog.terms.TermParse"
__blub_prolog_terms_TermParse.parse = function(s,context,operators) 
  if (context == nil) then 
    context = __blub_prolog_AtomContext.GLOBALS;
  end;
  if (operators == nil) then 
    operators = __blub_prolog_stopgap_parse_Operators.new();
    operators:addStandardOps();
  end;
  local index = __lua_lib_luautf8_Utf8.len(s) - 1;
  if (__lua_lib_luautf8_Utf8.sub(s, index + 1, index + 1) ~= ".") then 
    s = Std.string(s) .. Std.string(" .");
  end;
  local parser = __blub_prolog_stopgap_parse_Parser.new(context, operators, s, "method=Term.parse()");
  do return parser:nextTerm() end;
end

__blub_prolog_terms_Variable.new = function(name) 
  local self = _hx_new(__blub_prolog_terms_Variable.prototype)
  __blub_prolog_terms_Variable.super(self,name)
  return self
end
__blub_prolog_terms_Variable.super = function(self,name) 
  self._name = name;
  self.index = -1;
end
_hxClasses["blub.prolog.terms.Variable"] = __blub_prolog_terms_Variable
__blub_prolog_terms_Variable.__name__ = "blub.prolog.terms.Variable"
__blub_prolog_terms_Variable.__interfaces__ = {__blub_prolog_terms_Term}
__blub_prolog_terms_Variable.prototype = _hx_e();
__blub_prolog_terms_Variable.prototype.index= nil;
__blub_prolog_terms_Variable.prototype._name= nil;
__blub_prolog_terms_Variable.prototype.name= nil;
__blub_prolog_terms_Variable.prototype.asValueTerm = function(self) 
  do return nil end
end
__blub_prolog_terms_Variable.prototype.asAtom = function(self) 
  do return nil end
end
__blub_prolog_terms_Variable.prototype.asStructure = function(self) 
  do return nil end
end
__blub_prolog_terms_Variable.prototype.asNumber = function(self) 
  do return nil end
end
__blub_prolog_terms_Variable.prototype.asReference = function(self) 
  do return nil end
end
__blub_prolog_terms_Variable.prototype.asUnchasedReference = function(self) 
  do return nil end
end
__blub_prolog_terms_Variable.prototype.isGround = function(self) 
  do return false end
end
__blub_prolog_terms_Variable.prototype.hasReferences = function(self) 
  do return false end
end
__blub_prolog_terms_Variable.prototype.hasVariables = function(self) 
  do return true end
end
__blub_prolog_terms_Variable.prototype.toValue = function(self,env) 
  if (self.index < 0) then 
    do return __blub_prolog_terms_Reference.new() end;
  end;
  do return env[self.index] end
end
__blub_prolog_terms_Variable.prototype.commaSeparated = function(self) 
  do return _hx_tab_array({[0]=self}, 1) end
end
__blub_prolog_terms_Variable.prototype.equals = function(self,other) 
  do return self == other end
end
__blub_prolog_terms_Variable.prototype.match = function(self,other,env,trail) 
  if ((env == nil) or (self:get_name() == "_")) then 
    do return true end;
  end;
  if (self.index >= env.length) then 
    do return false end;
  end;
  local ref = env[self.index];
  do return ref:match(other, env, trail) end
end
__blub_prolog_terms_Variable.prototype.couldMatch = function(self,arg) 
  do return true end
end
__blub_prolog_terms_Variable.prototype.initIndex = function(self,index) 
  if (self.index ~= -1) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string(Std.string(Std.string("Cannot set var index more than once - ") .. Std.string(self._name)) .. Std.string(" was ")) .. Std.string(self.index)) .. Std.string(", setting to ")) .. Std.string(index)),0);
  end;
  self.index = index;
end
__blub_prolog_terms_Variable.prototype.toString = function(self) 
  do return self:get_name() end
end
__blub_prolog_terms_Variable.prototype.get_name = function(self) 
  if (self._name == nil) then 
    self._name = Std.string("_G") .. Std.string((function() 
    local _hx_obj = __blub_prolog_terms_Variable;
    local _hx_fld = 'nameCount';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)());
  end;
  do return self._name end
end

__blub_prolog_terms_Variable.prototype.__class__ =  __blub_prolog_terms_Variable

__blub_prolog_terms_Variable.prototype.__properties__ =  {get_name="get_name"}

__blub_prolog_terms_VariableContext.new = function(root,name2var,index2var) 
  local self = _hx_new(__blub_prolog_terms_VariableContext.prototype)
  __blub_prolog_terms_VariableContext.super(self,root,name2var,index2var)
  return self
end
__blub_prolog_terms_VariableContext.super = function(self,root,name2var,index2var) 
  self.root = root;
  self.index2var = index2var;
  self.name2var = name2var;
end
_hxClasses["blub.prolog.terms.VariableContext"] = __blub_prolog_terms_VariableContext
__blub_prolog_terms_VariableContext.__name__ = "blub.prolog.terms.VariableContext"
__blub_prolog_terms_VariableContext.prototype = _hx_e();
__blub_prolog_terms_VariableContext.prototype.root= nil;
__blub_prolog_terms_VariableContext.prototype.count= nil;
__blub_prolog_terms_VariableContext.prototype.name2var= nil;
__blub_prolog_terms_VariableContext.prototype.index2var= nil;
__blub_prolog_terms_VariableContext.prototype.varNamed = function(self,name) 
  local ret = self.name2var.h[name];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__blub_prolog_terms_VariableContext.prototype.varAt = function(self,index) 
  do return self.index2var[index] end
end
__blub_prolog_terms_VariableContext.prototype.variables = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self.index2var) end
end
__blub_prolog_terms_VariableContext.prototype.variableNames = function(self) 
  local names = Array.new();
  local v = self:variables();
  while (v:hasNext()) do 
    local v = v:next();
    names:push(v:get_name());
  end;
  do return names end
end
__blub_prolog_terms_VariableContext.prototype.createEnvironment = function(self) 
  local c = self:get_count();
  if (c == 0) then 
    do return nil end;
  end;
  local environment = Array.new();
  local _g = 0;
  local _g1 = c;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    environment:push(__blub_prolog_terms_Reference.new());
  end;
  do return environment end
end
__blub_prolog_terms_VariableContext.prototype.createNamedEnvironment = function(self) 
  if (self:get_count() == 0) then 
    do return nil end;
  end;
  local environment = Array.new();
  local _g = 0;
  local _g1 = self.index2var;
  while (_g < _g1.length) do 
    local v = _g1[_g];
    _g = _g + 1;
    environment:push(__blub_prolog_terms_Reference.new(v:get_name()));
  end;
  do return environment end
end
__blub_prolog_terms_VariableContext.prototype.get_count = function(self) 
  do return self.index2var.length end
end
__blub_prolog_terms_VariableContext.prototype.toString = function(self) 
  do return Std.string("VariableContext:") .. Std.string(Std.string(self.index2var)) end
end

__blub_prolog_terms_VariableContext.prototype.__class__ =  __blub_prolog_terms_VariableContext

__blub_prolog_terms_VariableContext.prototype.__properties__ =  {get_count="get_count"}

__blub_prolog_util_DLListListener.new = {}
_hxClasses["blub.prolog.util.DLListListener"] = __blub_prolog_util_DLListListener
__blub_prolog_util_DLListListener.__name__ = "blub.prolog.util.DLListListener"
__blub_prolog_util_DLListListener.prototype = _hx_e();
__blub_prolog_util_DLListListener.prototype.entryHasBeenAdded= nil;
__blub_prolog_util_DLListListener.prototype.entryWillBeRemoved= nil;
__blub_prolog_util_DLListListener.prototype.listWillBeCleared= nil;

__blub_prolog_util_DLListListener.prototype.__class__ =  __blub_prolog_util_DLListListener

__blub_prolog_util_TailIterable.new = function(list) 
  local self = _hx_new(__blub_prolog_util_TailIterable.prototype)
  __blub_prolog_util_TailIterable.super(self,list)
  return self
end
__blub_prolog_util_TailIterable.super = function(self,list) 
  self.list = list;
  self.entry = list:get_first();
end
_hxClasses["blub.prolog.util.TailIterable"] = __blub_prolog_util_TailIterable
__blub_prolog_util_TailIterable.__name__ = "blub.prolog.util.TailIterable"
__blub_prolog_util_TailIterable.prototype = _hx_e();
__blub_prolog_util_TailIterable.prototype.entry= nil;
__blub_prolog_util_TailIterable.prototype.list= nil;
__blub_prolog_util_TailIterable.prototype.iterator = function(self) 
  do return __blub_prolog_util__DLList_ItemIter.new(self.list, self.entry) end
end

__blub_prolog_util_TailIterable.prototype.__class__ =  __blub_prolog_util_TailIterable

__blub_prolog_util_EntryDeletionListener.new = function(callBack) 
  local self = _hx_new(__blub_prolog_util_EntryDeletionListener.prototype)
  __blub_prolog_util_EntryDeletionListener.super(self,callBack)
  return self
end
__blub_prolog_util_EntryDeletionListener.super = function(self,callBack) 
  self.callBack = _hx_funcToField(callBack);
end
_hxClasses["blub.prolog.util.EntryDeletionListener"] = __blub_prolog_util_EntryDeletionListener
__blub_prolog_util_EntryDeletionListener.__name__ = "blub.prolog.util.EntryDeletionListener"
__blub_prolog_util_EntryDeletionListener.__interfaces__ = {__blub_prolog_util_DLListListener}
__blub_prolog_util_EntryDeletionListener.prototype = _hx_e();
__blub_prolog_util_EntryDeletionListener.prototype.callBack= nil;
__blub_prolog_util_EntryDeletionListener.prototype.entryHasBeenAdded = function(self,entry) 
end
__blub_prolog_util_EntryDeletionListener.prototype.entryWillBeRemoved = function(self,entry) 
  self:callBack(entry.item);
end
__blub_prolog_util_EntryDeletionListener.prototype.listWillBeCleared = function(self,list) 
end

__blub_prolog_util_EntryDeletionListener.prototype.__class__ =  __blub_prolog_util_EntryDeletionListener

__blub_prolog_util_DLList.new = function() 
  local self = _hx_new(__blub_prolog_util_DLList.prototype)
  __blub_prolog_util_DLList.super(self)
  return self
end
__blub_prolog_util_DLList.super = function(self) 
  self.size = 0;
  self.internals = _hx_o({__fields__={remove=true,setFirst=true,setLast=true},remove=function(_,...) return _hx_bind(self,self.removeEntry)(...) end,setFirst=function(_,...) return _hx_bind(self,self.setFirst)(...) end,setLast=function(_,...) return _hx_bind(self,self.setLast)(...) end});
end
_hxClasses["blub.prolog.util.DLList"] = __blub_prolog_util_DLList
__blub_prolog_util_DLList.__name__ = "blub.prolog.util.DLList"
__blub_prolog_util_DLList.prototype = _hx_e();
__blub_prolog_util_DLList.prototype.first= nil;
__blub_prolog_util_DLList.prototype.last= nil;
__blub_prolog_util_DLList.prototype.size= nil;
__blub_prolog_util_DLList.prototype.items= nil;
__blub_prolog_util_DLList.prototype.entries= nil;
__blub_prolog_util_DLList.prototype._first= nil;
__blub_prolog_util_DLList.prototype._last= nil;
__blub_prolog_util_DLList.prototype.listeners= nil;
__blub_prolog_util_DLList.prototype.internals= nil;
__blub_prolog_util_DLList.prototype.get_first = function(self) 
  do return self._first end
end
__blub_prolog_util_DLList.prototype.get_last = function(self) 
  do return self._last end
end
__blub_prolog_util_DLList.prototype.listen = function(self,listener) 
  if (self.listeners == nil) then 
    self.listeners = Array.new();
  end;
  self.listeners:push(listener);
end
__blub_prolog_util_DLList.prototype.clear = function(self) 
  if (self.listeners ~= nil) then 
    local _g = 0;
    local _g1 = self.listeners;
    while (_g < _g1.length) do 
      local listener = _g1[_g];
      _g = _g + 1;
      listener:listWillBeCleared(self);
    end;
  end;
  self.size = 0;
  self._last = nil;
  self._first = nil;
end
__blub_prolog_util_DLList.prototype.removeFirst = function(self) 
  if (self._first == nil) then 
    do return nil end;
  end;
  do return self._first:remove() end
end
__blub_prolog_util_DLList.prototype.removeLast = function(self) 
  if (self._last == nil) then 
    do return nil end;
  end;
  do return self._last:remove() end
end
__blub_prolog_util_DLList.prototype.remove = function(self,entry) 
  if ((entry == nil) or (entry.list ~= self)) then 
    do return nil end;
  end;
  do return entry:remove() end
end
__blub_prolog_util_DLList.prototype.append = function(self,item) 
  do return self:insertAfter(item, self._last) end
end
__blub_prolog_util_DLList.prototype.prepend = function(self,item) 
  do return self:insertAfter(item, nil) end
end
__blub_prolog_util_DLList.prototype.removeItem = function(self,item) 
  local e = self:get_entries();
  while (e:hasNext()) do 
    local e = e:next();
    if (e.item == item) then 
      e:remove();
      do return true end;
    end;
  end;
  do return false end
end
__blub_prolog_util_DLList.prototype.removeEntry = function(self,e) 
  if (e == nil) then 
    do return end;
  end;
  if (e.list ~= self) then 
    do return end;
  end;
  if (self.listeners ~= nil) then 
    local _g = 0;
    local _g1 = self.listeners;
    while (_g < _g1.length) do 
      local listener = _g1[_g];
      _g = _g + 1;
      listener:entryWillBeRemoved(e);
    end;
  end;
  if (e:get_prev() == nil) then 
    self._first = e:get_next();
  end;
  if (e:get_next() == nil) then 
    self._last = e:get_prev();
  end;
  self.size = self.size - 1;
end
__blub_prolog_util_DLList.prototype.insertAfter = function(self,item,entry) 
  local prev = (function() 
    local _hx_1
    if (entry ~= nil) then 
    _hx_1 = entry; else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  if ((prev ~= nil) and (prev.list ~= self)) then 
    do return nil end;
  end;
  local next = (function() 
    local _hx_2
    if (prev ~= nil) then 
    _hx_2 = prev:get_next(); else 
    _hx_2 = self._first; end
    return _hx_2
  end )();
  local entry = __blub_prolog_util__DLList_EntryImpl.new(item, self, prev, next, self.internals);
  if (prev == nil) then 
    self._first = entry;
  end;
  if (next == nil) then 
    self._last = entry;
  end;
  self.size = self.size + 1;
  if (self.listeners ~= nil) then 
    local _g = 0;
    local _g1 = self.listeners;
    while (_g < _g1.length) do 
      local listener = _g1[_g];
      _g = _g + 1;
      listener:entryHasBeenAdded(entry);
    end;
  end;
  do return entry end
end
__blub_prolog_util_DLList.prototype.iterator = function(self) 
  do return self:get_items() end
end
__blub_prolog_util_DLList.prototype.get_items = function(self) 
  do return __blub_prolog_util__DLList_ItemIter.new(self) end
end
__blub_prolog_util_DLList.prototype.get_entries = function(self) 
  do return __blub_prolog_util__DLList_EntryIter.new(self) end
end
__blub_prolog_util_DLList.prototype.setFirst = function(self,entry) 
  self._first = entry;
  if (self._last == nil) then 
    self._last = entry;
  end;
end
__blub_prolog_util_DLList.prototype.setLast = function(self,entry) 
  self._last = entry;
  if (self._first == nil) then 
    self._first = entry;
  end;
end
__blub_prolog_util_DLList.prototype.toString = function(self) 
  local buf_b = ({});
  local buf_length = 0;
  local str = "[ ";
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  local first = true;
  local i = self:get_items();
  while (i:hasNext()) do 
    local i = i:next();
    if (first) then 
      first = false;
    else
      local str = ", ";
      _G.table.insert(buf_b, str);
      buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local str = Std.string(i);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  local str = " ]";
  _G.table.insert(buf_b, str);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(buf_b) end
end

__blub_prolog_util_DLList.prototype.__class__ =  __blub_prolog_util_DLList

__blub_prolog_util_DLList.prototype.__properties__ =  {get_entries="get_entries",get_items="get_items",get_last="get_last",get_first="get_first"}

__blub_prolog_util_Entry.new = {}
_hxClasses["blub.prolog.util.Entry"] = __blub_prolog_util_Entry
__blub_prolog_util_Entry.__name__ = "blub.prolog.util.Entry"
__blub_prolog_util_Entry.prototype = _hx_e();
__blub_prolog_util_Entry.prototype.item= nil;
__blub_prolog_util_Entry.prototype.prev= nil;
__blub_prolog_util_Entry.prototype.next= nil;
__blub_prolog_util_Entry.prototype.list= nil;
__blub_prolog_util_Entry.prototype.remove= nil;
__blub_prolog_util_Entry.prototype.get_prev= nil;
__blub_prolog_util_Entry.prototype.get_next= nil;
__blub_prolog_util_Entry.prototype.moveToFirst= nil;
__blub_prolog_util_Entry.prototype.moveToLast= nil;

__blub_prolog_util_Entry.prototype.__class__ =  __blub_prolog_util_Entry

__blub_prolog_util_Entry.prototype.__properties__ =  {get_next="get_next",get_prev="get_prev"}

__blub_prolog_util__DLList_ItemIter.new = function(list,first) 
  local self = _hx_new(__blub_prolog_util__DLList_ItemIter.prototype)
  __blub_prolog_util__DLList_ItemIter.super(self,list,first)
  return self
end
__blub_prolog_util__DLList_ItemIter.super = function(self,list,first) 
  self.iter = __blub_prolog_util__DLList_EntryIter.new(list, first);
end
_hxClasses["blub.prolog.util._DLList.ItemIter"] = __blub_prolog_util__DLList_ItemIter
__blub_prolog_util__DLList_ItemIter.__name__ = "blub.prolog.util._DLList.ItemIter"
__blub_prolog_util__DLList_ItemIter.prototype = _hx_e();
__blub_prolog_util__DLList_ItemIter.prototype.iter= nil;
__blub_prolog_util__DLList_ItemIter.prototype.hasNext = function(self) 
  do return self.iter:hasNext() end
end
__blub_prolog_util__DLList_ItemIter.prototype.next = function(self) 
  local entry = self.iter:next();
  if (entry == nil) then 
    do return nil end;
  else
    do return entry.item end;
  end;
end

__blub_prolog_util__DLList_ItemIter.prototype.__class__ =  __blub_prolog_util__DLList_ItemIter

__blub_prolog_util__DLList_EntryIter.new = function(list,first) 
  local self = _hx_new(__blub_prolog_util__DLList_EntryIter.prototype)
  __blub_prolog_util__DLList_EntryIter.super(self,list,first)
  return self
end
__blub_prolog_util__DLList_EntryIter.super = function(self,list,first) 
  self.nextEntry = (function() 
    local _hx_1
    if (first == nil) then 
    _hx_1 = list:get_first(); else 
    _hx_1 = first; end
    return _hx_1
  end )();
end
_hxClasses["blub.prolog.util._DLList.EntryIter"] = __blub_prolog_util__DLList_EntryIter
__blub_prolog_util__DLList_EntryIter.__name__ = "blub.prolog.util._DLList.EntryIter"
__blub_prolog_util__DLList_EntryIter.prototype = _hx_e();
__blub_prolog_util__DLList_EntryIter.prototype.nextEntry= nil;
__blub_prolog_util__DLList_EntryIter.prototype.hasNext = function(self) 
  self:advanceToLiveEntry();
  do return self.nextEntry ~= nil end
end
__blub_prolog_util__DLList_EntryIter.prototype.advanceToLiveEntry = function(self) 
  while ((self.nextEntry ~= nil) and (self.nextEntry.list == nil)) do 
    self.nextEntry = self.nextEntry:get_next();
  end;
end
__blub_prolog_util__DLList_EntryIter.prototype.next = function(self) 
  self:advanceToLiveEntry();
  if (self.nextEntry == nil) then 
    do return nil end;
  end;
  local result = self.nextEntry;
  self.nextEntry = result:get_next();
  do return result end
end

__blub_prolog_util__DLList_EntryIter.prototype.__class__ =  __blub_prolog_util__DLList_EntryIter

__blub_prolog_util__DLList_EntryImpl.new = function(item,list,prev,next,internals) 
  local self = _hx_new(__blub_prolog_util__DLList_EntryImpl.prototype)
  __blub_prolog_util__DLList_EntryImpl.super(self,item,list,prev,next,internals)
  return self
end
__blub_prolog_util__DLList_EntryImpl.super = function(self,item,list,prev,next,internals) 
  self.item = item;
  self.list = list;
  self._prev = prev;
  self._next = next;
  self._internals = internals;
  if (prev ~= nil) then 
    prev._next = self;
  end;
  if (next ~= nil) then 
    next._prev = self;
  end;
end
_hxClasses["blub.prolog.util._DLList.EntryImpl"] = __blub_prolog_util__DLList_EntryImpl
__blub_prolog_util__DLList_EntryImpl.__name__ = "blub.prolog.util._DLList.EntryImpl"
__blub_prolog_util__DLList_EntryImpl.__interfaces__ = {__blub_prolog_util_Entry}
__blub_prolog_util__DLList_EntryImpl.prototype = _hx_e();
__blub_prolog_util__DLList_EntryImpl.prototype.item= nil;
__blub_prolog_util__DLList_EntryImpl.prototype.prev= nil;
__blub_prolog_util__DLList_EntryImpl.prototype.next= nil;
__blub_prolog_util__DLList_EntryImpl.prototype.list= nil;
__blub_prolog_util__DLList_EntryImpl.prototype._prev= nil;
__blub_prolog_util__DLList_EntryImpl.prototype._next= nil;
__blub_prolog_util__DLList_EntryImpl.prototype._internals= nil;
__blub_prolog_util__DLList_EntryImpl.prototype.get_prev = function(self) 
  do return self._prev end
end
__blub_prolog_util__DLList_EntryImpl.prototype.get_next = function(self) 
  do return self._next end
end
__blub_prolog_util__DLList_EntryImpl.prototype.moveToFirst = function(self) 
  if (self.list == nil) then 
    do return end;
  end;
  if (self._prev == nil) then 
    do return end;
  end;
  self:yank();
  self._next = self.list:get_first();
  self._next._prev = self;
  self._internals:setFirst(self);
end
__blub_prolog_util__DLList_EntryImpl.prototype.moveToLast = function(self) 
  if (self.list == nil) then 
    do return end;
  end;
  if (self._next == nil) then 
    do return end;
  end;
  self:yank();
  self._next = nil;
  self._prev = self.list:get_last();
  self._prev._next = self;
  self._internals:setLast(self);
end
__blub_prolog_util__DLList_EntryImpl.prototype.yank = function(self) 
  if (self._prev ~= nil) then 
    self._prev._next = self._next;
  else
    self._internals:setFirst(self._next);
  end;
  if (self._next ~= nil) then 
    self._next._prev = self._prev;
  else
    self._internals:setLast(self._prev);
  end;
  self._prev = nil;
end
__blub_prolog_util__DLList_EntryImpl.prototype.remove = function(self) 
  if (self.list == nil) then 
    do return self.item end;
  end;
  self._internals:remove(self);
  self:yank();
  self.list = nil;
  local it = self.item;
  self.item = nil;
  do return it end
end

__blub_prolog_util__DLList_EntryImpl.prototype.__class__ =  __blub_prolog_util__DLList_EntryImpl

__blub_prolog_util__DLList_EntryImpl.prototype.__properties__ =  {get_next="get_next",get_prev="get_prev"}
_hxClasses["haxe.StackItem"] = __haxe_StackItem;
_hxClasses["haxe.StackItem"] = { __ename__ = "haxe.StackItem", __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
__haxe_StackItem = _hxClasses["haxe.StackItem"];
__haxe_StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = __haxe_StackItem},2)

__haxe_StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.FilePos = function(s,file,line,column) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,column,__enum__=__haxe_StackItem}, 6); return _x; end 
__haxe_StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=__haxe_StackItem}, 4); return _x; end 
__haxe_StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.__empty_constructs__ = _hx_tab_array({[0] = __haxe_StackItem.CFunction}, 1)

__haxe__CallStack_CallStack_Impl_.new = {}
_hxClasses["haxe._CallStack.CallStack_Impl_"] = __haxe__CallStack_CallStack_Impl_
__haxe__CallStack_CallStack_Impl_.__name__ = "haxe._CallStack.CallStack_Impl_"
__haxe__CallStack_CallStack_Impl_.__properties__ = {get_length="get_length"}
__haxe__CallStack_CallStack_Impl_.get_length = function(this1) 
  do return this1.length end;
end
__haxe__CallStack_CallStack_Impl_.callStack = function() 
  do return __haxe_NativeStackTrace.toHaxe(__haxe_NativeStackTrace.callStack()) end;
end
__haxe__CallStack_CallStack_Impl_.exceptionStack = function() 
  local eStack = __haxe_NativeStackTrace.toHaxe(__haxe_NativeStackTrace.exceptionStack());
  do return __haxe__CallStack_CallStack_Impl_.subtract(eStack, __haxe__CallStack_CallStack_Impl_.callStack()) end;
end
__haxe__CallStack_CallStack_Impl_.toString = function(stack) 
  local b = StringBuf.new();
  local _g = 0;
  local _g1 = stack;
  while (_g < _g1.length) do 
    local s = _g1[_g];
    _g = _g + 1;
    local str = "\nCalled from ";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    __haxe__CallStack_CallStack_Impl_.itemToString(b, s);
  end;
  do return _G.table.concat(b.b) end;
end
__haxe__CallStack_CallStack_Impl_.subtract = function(this1,stack) 
  local startIndex = -1;
  local i = -1;
  while (true) do 
    i = i + 1;
    if (not (i < this1.length)) then 
      break;
    end;
    local _g = 0;
    local _g1 = stack.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local j = _g - 1;
      if (__haxe__CallStack_CallStack_Impl_.equalItems(this1[i], stack[j])) then 
        if (startIndex < 0) then 
          startIndex = i;
        end;
        i = i + 1;
        if (i >= this1.length) then 
          break;
        end;
      else
        startIndex = -1;
      end;
    end;
    if (startIndex >= 0) then 
      break;
    end;
  end;
  if (startIndex >= 0) then 
    do return this1:slice(0, startIndex) end;
  else
    do return this1 end;
  end;
end
__haxe__CallStack_CallStack_Impl_.copy = function(this1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = this1;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
__haxe__CallStack_CallStack_Impl_.get = function(this1,index) 
  do return this1[index] end;
end
__haxe__CallStack_CallStack_Impl_.asArray = function(this1) 
  do return this1 end;
end
__haxe__CallStack_CallStack_Impl_.equalItems = function(item1,item2) 
  if (item1 == nil) then 
    if (item2 == nil) then 
      do return true end;
    else
      do return false end;
    end;
  else
    local tmp = item1[1];
    if (tmp) == 0 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 0) then 
          do return true end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 1 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 1) then 
          local m1 = item1[2];
          local m2 = item2[2];
          do return m1 == m2 end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 2 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 2) then 
          local item11 = item1[2];
          local file1 = item1[3];
          local line1 = item1[4];
          local col1 = item1[5];
          local col2 = item2[5];
          local line2 = item2[4];
          local file2 = item2[3];
          local item2 = item2[2];
          if (((file1 == file2) and (line1 == line2)) and (col1 == col2)) then 
            do return __haxe__CallStack_CallStack_Impl_.equalItems(item11, item2) end;
          else
            do return false end;
          end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 3 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 3) then 
          local class1 = item1[2];
          local method1 = item1[3];
          local method2 = item2[3];
          local class2 = item2[2];
          if (class1 == class2) then 
            do return method1 == method2 end;
          else
            do return false end;
          end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 4 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 4) then 
          local v1 = item1[2];
          local v2 = item2[2];
          do return v1 == v2 end;
        else
          do return false end;
        end;
      end; end;
  end;
end
__haxe__CallStack_CallStack_Impl_.exceptionToString = function(e) 
  if (e:get_previous() == nil) then 
    local tmp = Std.string("Exception: ") .. Std.string(e:get_message());
    local tmp1 = e:get_stack();
    do return Std.string(tmp) .. Std.string(((function() 
      local _hx_1
      if (tmp1 == nil) then 
      _hx_1 = "null"; else 
      _hx_1 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp1); end
      return _hx_1
    end )())) end;
  end;
  local result = "";
  local e = e;
  local prev = nil;
  while (e ~= nil) do 
    if (prev == nil) then 
      local result1 = Std.string("Exception: ") .. Std.string(e:get_message());
      local tmp = e:get_stack();
      result = Std.string(Std.string(result1) .. Std.string(((function() 
        local _hx_2
        if (tmp == nil) then 
        _hx_2 = "null"; else 
        _hx_2 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp); end
        return _hx_2
      end )()))) .. Std.string(result);
    else
      local prevStack = __haxe__CallStack_CallStack_Impl_.subtract(e:get_stack(), prev:get_stack());
      result = Std.string(Std.string(Std.string(Std.string("Exception: ") .. Std.string(e:get_message())) .. Std.string(((function() 
        local _hx_3
        if (prevStack == nil) then 
        _hx_3 = "null"; else 
        _hx_3 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(prevStack); end
        return _hx_3
      end )()))) .. Std.string("\n\nNext ")) .. Std.string(result);
    end;
    prev = e;
    e = e:get_previous();
  end;
  do return result end;
end
__haxe__CallStack_CallStack_Impl_.itemToString = function(b,s) 
  local tmp = s[1];
  if (tmp) == 0 then 
    local str = "a C function";
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 1 then 
    local m = s[2];
    local str = "module ";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(m);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 2 then 
    local col = s[5];
    local line = s[4];
    local file = s[3];
    local s = s[2];
    if (s ~= nil) then 
      __haxe__CallStack_CallStack_Impl_.itemToString(b, s);
      local str = " (";
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local str = Std.string(file);
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = " line ";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(line);
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    if (col ~= nil) then 
      local str = " column ";
      _G.table.insert(b.b, str);
      local b1 = b;
      b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
      local str = Std.string(col);
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
    end;
    if (s ~= nil) then 
      local str = ")";
      _G.table.insert(b.b, str);
      local b = b;
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
    end;
  elseif (tmp) == 3 then 
    local meth = s[3];
    local cname = s[2];
    local str = Std.string((function() 
      local _hx_1
      if (cname == nil) then 
      _hx_1 = "<unknown>"; else 
      _hx_1 = cname; end
      return _hx_1
    end )());
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = ".";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(meth);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 4 then 
    local n = s[2];
    local str = "local function #";
    _G.table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(n);
    _G.table.insert(b.b, str);
    local b = b;
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str); end;
end

__haxe_IMap.new = {}
_hxClasses["haxe.IMap"] = __haxe_IMap
__haxe_IMap.__name__ = "haxe.IMap"
__haxe_IMap.prototype = _hx_e();
__haxe_IMap.prototype.get= nil;
__haxe_IMap.prototype.set= nil;
__haxe_IMap.prototype.exists= nil;
__haxe_IMap.prototype.remove= nil;
__haxe_IMap.prototype.keys= nil;
__haxe_IMap.prototype.iterator= nil;
__haxe_IMap.prototype.keyValueIterator= nil;
__haxe_IMap.prototype.copy= nil;
__haxe_IMap.prototype.toString= nil;
__haxe_IMap.prototype.clear= nil;

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe__EntryPoint_Lock.new = function() 
  local self = _hx_new(__haxe__EntryPoint_Lock.prototype)
  __haxe__EntryPoint_Lock.super(self)
  return self
end
__haxe__EntryPoint_Lock.super = function(self) 
end
_hxClasses["haxe._EntryPoint.Lock"] = __haxe__EntryPoint_Lock
__haxe__EntryPoint_Lock.__name__ = "haxe._EntryPoint.Lock"
__haxe__EntryPoint_Lock.prototype = _hx_e();
__haxe__EntryPoint_Lock.prototype.release = function(self) 
end
__haxe__EntryPoint_Lock.prototype.wait = function(self,t) 
end

__haxe__EntryPoint_Lock.prototype.__class__ =  __haxe__EntryPoint_Lock

__haxe__EntryPoint_Mutex.new = function() 
  local self = _hx_new(__haxe__EntryPoint_Mutex.prototype)
  __haxe__EntryPoint_Mutex.super(self)
  return self
end
__haxe__EntryPoint_Mutex.super = function(self) 
end
_hxClasses["haxe._EntryPoint.Mutex"] = __haxe__EntryPoint_Mutex
__haxe__EntryPoint_Mutex.__name__ = "haxe._EntryPoint.Mutex"
__haxe__EntryPoint_Mutex.prototype = _hx_e();
__haxe__EntryPoint_Mutex.prototype.acquire = function(self) 
end
__haxe__EntryPoint_Mutex.prototype.release = function(self) 
end

__haxe__EntryPoint_Mutex.prototype.__class__ =  __haxe__EntryPoint_Mutex

__haxe__EntryPoint_Thread.new = {}
_hxClasses["haxe._EntryPoint.Thread"] = __haxe__EntryPoint_Thread
__haxe__EntryPoint_Thread.__name__ = "haxe._EntryPoint.Thread"
__haxe__EntryPoint_Thread.create = function(f) 
  f();
end

__haxe_EntryPoint.new = {}
_hxClasses["haxe.EntryPoint"] = __haxe_EntryPoint
__haxe_EntryPoint.__name__ = "haxe.EntryPoint"
__haxe_EntryPoint.wakeup = function() 
end
__haxe_EntryPoint.runInMainThread = function(f) 
  __haxe_EntryPoint.pending:push(f);
  __haxe_EntryPoint.wakeup();
end
__haxe_EntryPoint.addThread = function(f) 
  __haxe_EntryPoint.threadCount = __haxe_EntryPoint.threadCount + 1;
  __haxe__EntryPoint_Thread.create(function() 
    f();
    __haxe_EntryPoint.threadCount = __haxe_EntryPoint.threadCount - 1;
    if (__haxe_EntryPoint.threadCount == 0) then 
      __haxe_EntryPoint.wakeup();
    end;
  end);
end
__haxe_EntryPoint.processEvents = function() 
  while (true) do 
    local f = __haxe_EntryPoint.pending:shift();
    if (f == nil) then 
      break;
    end;
    f();
  end;
  local time = __haxe_MainLoop.tick();
  if (not __haxe_MainLoop.hasEvents() and (__haxe_EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return time end;
end
__haxe_EntryPoint.run = function() 
  while (true) do 
    local nextTick = __haxe_EntryPoint.processEvents();
    if (nextTick < 0) then 
      break;
    end;
    local tmp = nextTick > 0;
  end;
end

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
_hxClasses["haxe.Exception"] = __haxe_Exception
__haxe_Exception.__name__ = "haxe.Exception"
__haxe_Exception.caught = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value end;
  else
    do return __haxe_ValueException.new(value, nil, value) end;
  end;
end
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.__exceptionMessage= nil;
__haxe_Exception.prototype.__exceptionStack= nil;
__haxe_Exception.prototype.__nativeStack= nil;
__haxe_Exception.prototype.__skipStack= nil;
__haxe_Exception.prototype.__nativeException= nil;
__haxe_Exception.prototype.__previousException= nil;
__haxe_Exception.prototype.unwrap = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.toString = function(self) 
  do return self:get_message() end
end
__haxe_Exception.prototype.details = function(self) 
  if (self:get_previous() == nil) then 
    local tmp = Std.string("Exception: ") .. Std.string(self:get_message());
    local tmp1 = self:get_stack();
    do return Std.string(tmp) .. Std.string(((function() 
      local _hx_1
      if (tmp1 == nil) then 
      _hx_1 = "null"; else 
      _hx_1 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp1); end
      return _hx_1
    end )())) end;
  else
    local result = "";
    local e = self;
    local prev = nil;
    while (e ~= nil) do 
      if (prev == nil) then 
        local result1 = Std.string("Exception: ") .. Std.string(e:get_message());
        local tmp = e:get_stack();
        result = Std.string(Std.string(result1) .. Std.string(((function() 
          local _hx_2
          if (tmp == nil) then 
          _hx_2 = "null"; else 
          _hx_2 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp); end
          return _hx_2
        end )()))) .. Std.string(result);
      else
        local prevStack = __haxe__CallStack_CallStack_Impl_.subtract(e:get_stack(), prev:get_stack());
        result = Std.string(Std.string(Std.string(Std.string("Exception: ") .. Std.string(e:get_message())) .. Std.string(((function() 
          local _hx_3
          if (prevStack == nil) then 
          _hx_3 = "null"; else 
          _hx_3 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(prevStack); end
          return _hx_3
        end )()))) .. Std.string("\n\nNext ")) .. Std.string(result);
      end;
      prev = e;
      e = e:get_previous();
    end;
    do return result end;
  end;
end
__haxe_Exception.prototype.__shiftStack = function(self) 
  self.__skipStack = self.__skipStack + 1;
end
__haxe_Exception.prototype.get_message = function(self) 
  do return self.__exceptionMessage end
end
__haxe_Exception.prototype.get_previous = function(self) 
  do return self.__previousException end
end
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.get_stack = function(self) 
  local _g = self.__exceptionStack;
  if (_g == nil) then 
    self.__exceptionStack = __haxe_NativeStackTrace.toHaxe(self.__nativeStack, self.__skipStack) do return self.__exceptionStack end;
  else
    local s = _g;
    do return s end;
  end;
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_Exception.prototype.__properties__ =  {get_native="get_native",get_previous="get_previous",get_stack="get_stack",get_message="get_message"}

__haxe__Int32_Int32_Impl_.new = {}
_hxClasses["haxe._Int32.Int32_Impl_"] = __haxe__Int32_Int32_Impl_
__haxe__Int32_Int32_Impl_.__name__ = "haxe._Int32.Int32_Impl_"
__haxe__Int32_Int32_Impl_.negate = function(this1) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(this1) + 1) end;
end
__haxe__Int32_Int32_Impl_.preIncrement = function(this1) 
  this1 = this1 + 1;
  this1 = __haxe__Int32_Int32_Impl_.clamp(this1);
  do return this1 end;
end
__haxe__Int32_Int32_Impl_.postIncrement = function(this1) 
  this1 = this1 + 1;
  local ret = this1 - 1;
  this1 = __haxe__Int32_Int32_Impl_.clamp(this1);
  do return ret end;
end
__haxe__Int32_Int32_Impl_.preDecrement = function(this1) 
  this1 = this1 - 1;
  this1 = __haxe__Int32_Int32_Impl_.clamp(this1);
  do return this1 end;
end
__haxe__Int32_Int32_Impl_.postDecrement = function(this1) 
  this1 = this1 - 1;
  local ret = this1 + 1;
  this1 = __haxe__Int32_Int32_Impl_.clamp(this1);
  do return ret end;
end
__haxe__Int32_Int32_Impl_.add = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(a + b) end;
end
__haxe__Int32_Int32_Impl_.addInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(a + b) end;
end
__haxe__Int32_Int32_Impl_.sub = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(a - b) end;
end
__haxe__Int32_Int32_Impl_.subInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(a - b) end;
end
__haxe__Int32_Int32_Impl_.intSub = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(a - b) end;
end
__haxe__Int32_Int32_Impl_.mul = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp((a * (_hx_bit.band(b,65535))) + __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a * (_hx_bit.rshift(b,16)),16))) end;
end
__haxe__Int32_Int32_Impl_.mulInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.mul(a, b) end;
end
__haxe__Int32_Int32_Impl_.complement = function(a) 
  do return _hx_bit_clamp(_hx_bit.bnot(a)) end;
end
__haxe__Int32_Int32_Impl_["or"] = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.orInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.xor = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bxor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.xorInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bxor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.shr = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.shrInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.intShr = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.shl = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.shlInt = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.intShl = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.toFloat = function(this1) 
  do return this1 end;
end
__haxe__Int32_Int32_Impl_.ucompare = function(a,b) 
  if (a < 0) then 
    if (b < 0) then 
      do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit_clamp(_hx_bit.bnot(b)) - _hx_bit_clamp(_hx_bit.bnot(a))) end;
    else
      do return 1 end;
    end;
  end;
  if (b < 0) then 
    do return -1 end;
  else
    do return __haxe__Int32_Int32_Impl_.clamp(a - b) end;
  end;
end
__haxe__Int32_Int32_Impl_.clamp = function(x) 
  do return _hx_bit_clamp(x) end;
end

__haxe__Int64_Int64_Impl_.new = {}
_hxClasses["haxe._Int64.Int64_Impl_"] = __haxe__Int64_Int64_Impl_
__haxe__Int64_Int64_Impl_.__name__ = "haxe._Int64.Int64_Impl_"
__haxe__Int64_Int64_Impl_.__properties__ = {get_low="get_low",get_high="get_high"}
__haxe__Int64_Int64_Impl_._new = function(x) 
  local this1 = x;
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.copy = function(this1) 
  local this1 = __haxe__Int64____Int64.new(this1.high, this1.low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.make = function(high,low) 
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.ofInt = function(x) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(x, 31), x);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.toInt = function(x) 
  if (x.high ~= __haxe__Int32_Int32_Impl_.shr(x.low, 31)) then 
    _G.error(__haxe_Exception.thrown("Overflow"),0);
  end;
  do return x.low end;
end
__haxe__Int64_Int64_Impl_.is = function(val) 
  do return __lua_Boot.__instanceof(val, __haxe__Int64____Int64) end;
end
__haxe__Int64_Int64_Impl_.isInt64 = function(val) 
  do return __lua_Boot.__instanceof(val, __haxe__Int64____Int64) end;
end
__haxe__Int64_Int64_Impl_.getHigh = function(x) 
  do return x.high end;
end
__haxe__Int64_Int64_Impl_.getLow = function(x) 
  do return x.low end;
end
__haxe__Int64_Int64_Impl_.isNeg = function(x) 
  do return x.high < 0 end;
end
__haxe__Int64_Int64_Impl_.isZero = function(x) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(0, 31);
  local b_low = 0;
  if (x.high == b_high) then 
    do return x.low == b_low end;
  else
    do return false end;
  end;
end
__haxe__Int64_Int64_Impl_.compare = function(a,b) 
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b.low);
  end;
  if (a.high < 0) then 
    if (b.high < 0) then 
      do return v end;
    else
      do return -1 end;
    end;
  else
    if (b.high >= 0) then 
      do return v end;
    else
      do return 1 end;
    end;
  end;
end
__haxe__Int64_Int64_Impl_.ucompare = function(a,b) 
  local v = __haxe__Int32_Int32_Impl_.ucompare(a.high, b.high);
  if (v ~= 0) then 
    do return v end;
  else
    do return __haxe__Int32_Int32_Impl_.ucompare(a.low, b.low) end;
  end;
end
__haxe__Int64_Int64_Impl_.toStr = function(x) 
  do return _hx_wrap_if_string_field(__haxe__Int64_Int64_Impl_,'toString')(x) end;
end
__haxe__Int64_Int64_Impl_.toString = function(this1) 
  local i = this1;
  local b_high = __haxe__Int32_Int32_Impl_.shr(0, 31);
  local b_low = 0;
  if ((i.high == b_high) and (i.low == b_low)) then 
    do return "0" end;
  end;
  local str = "";
  local neg = false;
  if (i.high < 0) then 
    neg = true;
  end;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(10, 31), 10);
  local ten = this1;
  while (true) do 
    local b_high = __haxe__Int32_Int32_Impl_.shr(0, 31);
    local b_low = 0;
    if (not ((i.high ~= b_high) or (i.low ~= b_low))) then 
      break;
    end;
    local r = __haxe__Int64_Int64_Impl_.divMod(i, ten);
    if (r.modulus.high < 0) then 
      local x = r.modulus;
      local a = x.high;
      local high = _hx_bit_clamp(_hx_bit.bnot(a));
      local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(x.low) + 1);
      if (low == 0) then 
        high = high + 1;
        local ret = high - 1;
        high = __haxe__Int32_Int32_Impl_.clamp(high);
      end;
      local this_high = high;
      local this_low = low;
      str = Std.string(this_low) .. Std.string(str);
      local x = r.quotient;
      local a = x.high;
      local high = _hx_bit_clamp(_hx_bit.bnot(a));
      local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(x.low) + 1);
      if (low == 0) then 
        high = high + 1;
        local ret = high - 1;
        high = __haxe__Int32_Int32_Impl_.clamp(high);
      end;
      local this1 = __haxe__Int64____Int64.new(high, low);
      i = this1;
    else
      str = Std.string(r.modulus.low) .. Std.string(str);
      i = r.quotient;
    end;
  end;
  if (neg) then 
    str = Std.string("-") .. Std.string(str);
  end;
  do return str end;
end
__haxe__Int64_Int64_Impl_.parseString = function(sParam) 
  do return __haxe_Int64Helper.parseString(sParam) end;
end
__haxe__Int64_Int64_Impl_.fromFloat = function(f) 
  do return __haxe_Int64Helper.fromFloat(f) end;
end
__haxe__Int64_Int64_Impl_.divMod = function(dividend,divisor) 
  if (divisor.high == 0) then 
    local _g = divisor.low;
    if (_g) == 0 then 
      _G.error(__haxe_Exception.thrown("divide by zero"),0);
    elseif (_g) == 1 then 
      local this1 = __haxe__Int64____Int64.new(dividend.high, dividend.low);
      local this2 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(0, 31), 0);
      do return _hx_o({__fields__={quotient=true,modulus=true},quotient=this1,modulus=this2}) end; end;
  end;
  local divSign = (dividend.high < 0) ~= (divisor.high < 0);
  local modulus;
  if (dividend.high < 0) then 
    local a = dividend.high;
    local high = _hx_bit_clamp(_hx_bit.bnot(a));
    local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(dividend.low) + 1);
    if (low == 0) then 
      high = high + 1;
      local ret = high - 1;
      high = __haxe__Int32_Int32_Impl_.clamp(high);
    end;
    local this1 = __haxe__Int64____Int64.new(high, low);
    modulus = this1;
  else
    local this1 = __haxe__Int64____Int64.new(dividend.high, dividend.low);
    modulus = this1;
  end;
  if (divisor.high < 0) then 
    local a = divisor.high;
    local high = _hx_bit_clamp(_hx_bit.bnot(a));
    local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(divisor.low) + 1);
    if (low == 0) then 
      high = high + 1;
      local ret = high - 1;
      high = __haxe__Int32_Int32_Impl_.clamp(high);
    end;
    local this1 = __haxe__Int64____Int64.new(high, low);
    divisor = this1;
  end;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(0, 31), 0);
  local quotient = this1;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(1, 31), 1);
  local mask = this1;
  while (not (divisor.high < 0)) do 
    local v = __haxe__Int32_Int32_Impl_.ucompare(divisor.high, modulus.high);
    local cmp = (function() 
      local _hx_1
      if (v ~= 0) then 
      _hx_1 = v; else 
      _hx_1 = __haxe__Int32_Int32_Impl_.ucompare(divisor.low, modulus.low); end
      return _hx_1
    end )();
    local b = 1;
    b = _hx_bit.band(b,63);
    if (b == 0) then 
      local this1 = __haxe__Int64____Int64.new(divisor.high, divisor.low);
      divisor = this1;
    else
      if (b < 32) then 
        local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(divisor.high,b)), _hx_bit.rshift(divisor.low,32 - b)), __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(divisor.low,b)));
        divisor = this1;
      else
        local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(divisor.low,b - 32)), 0);
        divisor = this1;
      end;
    end;
    local b = 1;
    b = _hx_bit.band(b,63);
    if (b == 0) then 
      local this1 = __haxe__Int64____Int64.new(mask.high, mask.low);
      mask = this1;
    else
      if (b < 32) then 
        local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(mask.high,b)), _hx_bit.rshift(mask.low,32 - b)), __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(mask.low,b)));
        mask = this1;
      else
        local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(mask.low,b - 32)), 0);
        mask = this1;
      end;
    end;
    if (cmp >= 0) then 
      break;
    end;
  end;
  while (true) do 
    local b_high = __haxe__Int32_Int32_Impl_.shr(0, 31);
    local b_low = 0;
    if (not ((mask.high ~= b_high) or (mask.low ~= b_low))) then 
      break;
    end;
    local v = __haxe__Int32_Int32_Impl_.ucompare(modulus.high, divisor.high);
    if ((function() 
      local _hx_2
      if (v ~= 0) then 
      _hx_2 = v; else 
      _hx_2 = __haxe__Int32_Int32_Impl_.ucompare(modulus.low, divisor.low); end
      return _hx_2
    end )() >= 0) then 
      local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](quotient.high, mask.high), __haxe__Int32_Int32_Impl_["or"](quotient.low, mask.low));
      quotient = this1;
      local high = __haxe__Int32_Int32_Impl_.clamp(modulus.high - divisor.high);
      local low = __haxe__Int32_Int32_Impl_.clamp(modulus.low - divisor.low);
      if (__haxe__Int32_Int32_Impl_.ucompare(modulus.low, divisor.low) < 0) then 
        high = high - 1;
        local ret = high + 1;
        high = __haxe__Int32_Int32_Impl_.clamp(high);
      end;
      local this1 = __haxe__Int64____Int64.new(high, low);
      modulus = this1;
    end;
    local b = 1;
    b = _hx_bit.band(b,63);
    if (b == 0) then 
      local this1 = __haxe__Int64____Int64.new(mask.high, mask.low);
      mask = this1;
    else
      if (b < 32) then 
        local this1 = __haxe__Int64____Int64.new(_hx_bit.rshift(mask.high,b), __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(mask.high,32 - b)), _hx_bit.rshift(mask.low,b)));
        mask = this1;
      else
        local this1 = __haxe__Int64____Int64.new(0, _hx_bit.rshift(mask.high,b - 32));
        mask = this1;
      end;
    end;
    local b = 1;
    b = _hx_bit.band(b,63);
    if (b == 0) then 
      local this1 = __haxe__Int64____Int64.new(divisor.high, divisor.low);
      divisor = this1;
    else
      if (b < 32) then 
        local this1 = __haxe__Int64____Int64.new(_hx_bit.rshift(divisor.high,b), __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(divisor.high,32 - b)), _hx_bit.rshift(divisor.low,b)));
        divisor = this1;
      else
        local this1 = __haxe__Int64____Int64.new(0, _hx_bit.rshift(divisor.high,b - 32));
        divisor = this1;
      end;
    end;
  end;
  if (divSign) then 
    local a = quotient.high;
    local high = _hx_bit_clamp(_hx_bit.bnot(a));
    local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(quotient.low) + 1);
    if (low == 0) then 
      high = high + 1;
      local ret = high - 1;
      high = __haxe__Int32_Int32_Impl_.clamp(high);
    end;
    local this1 = __haxe__Int64____Int64.new(high, low);
    quotient = this1;
  end;
  if (dividend.high < 0) then 
    local a = modulus.high;
    local high = _hx_bit_clamp(_hx_bit.bnot(a));
    local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(modulus.low) + 1);
    if (low == 0) then 
      high = high + 1;
      local ret = high - 1;
      high = __haxe__Int32_Int32_Impl_.clamp(high);
    end;
    local this1 = __haxe__Int64____Int64.new(high, low);
    modulus = this1;
  end;
  do return _hx_o({__fields__={quotient=true,modulus=true},quotient=quotient,modulus=modulus}) end;
end
__haxe__Int64_Int64_Impl_.neg = function(x) 
  local a = x.high;
  local high = _hx_bit_clamp(_hx_bit.bnot(a));
  local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(x.low) + 1);
  if (low == 0) then 
    high = high + 1;
    local ret = high - 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.preIncrement = function(this1) 
  local this2 = __haxe__Int64____Int64.new(this1.high, this1.low);
  this1 = this2;
  local ret = (function() 
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  this1.low = __haxe__Int32_Int32_Impl_.clamp(this1.low);
  if (this1.low == 0) then 
    local ret = (function() 
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    this1.high = __haxe__Int32_Int32_Impl_.clamp(this1.high);
  end;
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.postIncrement = function(this1) 
  local ret = this1;
  local this2 = __haxe__Int64____Int64.new(this1.high, this1.low);
  this1 = this2;
  local ret1 = (function() 
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  this1.low = __haxe__Int32_Int32_Impl_.clamp(this1.low);
  if (this1.low == 0) then 
    local ret = (function() 
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    this1.high = __haxe__Int32_Int32_Impl_.clamp(this1.high);
  end;
  do return ret end;
end
__haxe__Int64_Int64_Impl_.preDecrement = function(this1) 
  local this2 = __haxe__Int64____Int64.new(this1.high, this1.low);
  this1 = this2;
  if (this1.low == 0) then 
    local ret = (function() 
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
     return _;
     end)();
    this1.high = __haxe__Int32_Int32_Impl_.clamp(this1.high);
  end;
  local ret = (function() 
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
   return _;
   end)();
  this1.low = __haxe__Int32_Int32_Impl_.clamp(this1.low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.postDecrement = function(this1) 
  local ret = this1;
  local this2 = __haxe__Int64____Int64.new(this1.high, this1.low);
  this1 = this2;
  if (this1.low == 0) then 
    local ret = (function() 
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
     return _;
     end)();
    this1.high = __haxe__Int32_Int32_Impl_.clamp(this1.high);
  end;
  local ret1 = (function() 
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
   return _;
   end)();
  this1.low = __haxe__Int32_Int32_Impl_.clamp(this1.low);
  do return ret end;
end
__haxe__Int64_Int64_Impl_.add = function(a,b) 
  local high = __haxe__Int32_Int32_Impl_.clamp(a.high + b.high);
  local low = __haxe__Int32_Int32_Impl_.clamp(a.low + b.low);
  if (__haxe__Int32_Int32_Impl_.ucompare(low, a.low) < 0) then 
    high = high + 1;
    local ret = high - 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.addInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  local high = __haxe__Int32_Int32_Impl_.clamp(a.high + b_high);
  local low = __haxe__Int32_Int32_Impl_.clamp(a.low + b_low);
  if (__haxe__Int32_Int32_Impl_.ucompare(low, a.low) < 0) then 
    high = high + 1;
    local ret = high - 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.sub = function(a,b) 
  local high = __haxe__Int32_Int32_Impl_.clamp(a.high - b.high);
  local low = __haxe__Int32_Int32_Impl_.clamp(a.low - b.low);
  if (__haxe__Int32_Int32_Impl_.ucompare(a.low, b.low) < 0) then 
    high = high - 1;
    local ret = high + 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.subInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  local high = __haxe__Int32_Int32_Impl_.clamp(a.high - b_high);
  local low = __haxe__Int32_Int32_Impl_.clamp(a.low - b_low);
  if (__haxe__Int32_Int32_Impl_.ucompare(a.low, b_low) < 0) then 
    high = high - 1;
    local ret = high + 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.intSub = function(a,b) 
  local a_high = __haxe__Int32_Int32_Impl_.shr(a, 31);
  local a_low = a;
  local high = __haxe__Int32_Int32_Impl_.clamp(a_high - b.high);
  local low = __haxe__Int32_Int32_Impl_.clamp(a_low - b.low);
  if (__haxe__Int32_Int32_Impl_.ucompare(a_low, b.low) < 0) then 
    high = high - 1;
    local ret = high + 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.mul = function(a,b) 
  local mask = 65535;
  local al = _hx_bit.band(a.low,mask);
  local ah = _hx_bit.rshift(a.low,16);
  local bl = _hx_bit.band(b.low,mask);
  local bh = _hx_bit.rshift(b.low,16);
  local p00 = __haxe__Int32_Int32_Impl_.mul(al, bl);
  local p10 = __haxe__Int32_Int32_Impl_.mul(ah, bl);
  local p01 = __haxe__Int32_Int32_Impl_.mul(al, bh);
  local p11 = __haxe__Int32_Int32_Impl_.mul(ah, bh);
  local low = p00;
  local high = __haxe__Int32_Int32_Impl_.clamp(__haxe__Int32_Int32_Impl_.clamp(p11 + (_hx_bit.rshift(p01,16))) + (_hx_bit.rshift(p10,16)));
  p01 = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(p01,16));
  low = __haxe__Int32_Int32_Impl_.clamp(low + p01);
  if (__haxe__Int32_Int32_Impl_.ucompare(low, p01) < 0) then 
    high = high + 1;
    local ret = high - 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  p10 = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(p10,16));
  low = __haxe__Int32_Int32_Impl_.clamp(low + p10);
  if (__haxe__Int32_Int32_Impl_.ucompare(low, p10) < 0) then 
    high = high + 1;
    local ret = high - 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  high = __haxe__Int32_Int32_Impl_.clamp(high + __haxe__Int32_Int32_Impl_.clamp(__haxe__Int32_Int32_Impl_.mul(a.low, b.high) + __haxe__Int32_Int32_Impl_.mul(a.high, b.low)));
  local this1 = __haxe__Int64____Int64.new(high, low);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.mulInt = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(b, 31), b);
  do return __haxe__Int64_Int64_Impl_.mul(a, this1) end;
end
__haxe__Int64_Int64_Impl_.div = function(a,b) 
  do return __haxe__Int64_Int64_Impl_.divMod(a, b).quotient end;
end
__haxe__Int64_Int64_Impl_.divInt = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(b, 31), b);
  do return __haxe__Int64_Int64_Impl_.divMod(a, this1).quotient end;
end
__haxe__Int64_Int64_Impl_.intDiv = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(a, 31), a);
  local x = __haxe__Int64_Int64_Impl_.divMod(this1, b).quotient;
  if (x.high ~= __haxe__Int32_Int32_Impl_.shr(x.low, 31)) then 
    _G.error(__haxe_Exception.thrown("Overflow"),0);
  end;
  local x = x.low;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(x, 31), x);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.mod = function(a,b) 
  do return __haxe__Int64_Int64_Impl_.divMod(a, b).modulus end;
end
__haxe__Int64_Int64_Impl_.modInt = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(b, 31), b);
  local x = __haxe__Int64_Int64_Impl_.divMod(a, this1).modulus;
  if (x.high ~= __haxe__Int32_Int32_Impl_.shr(x.low, 31)) then 
    _G.error(__haxe_Exception.thrown("Overflow"),0);
  end;
  local x = x.low;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(x, 31), x);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.intMod = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(a, 31), a);
  local x = __haxe__Int64_Int64_Impl_.divMod(this1, b).modulus;
  if (x.high ~= __haxe__Int32_Int32_Impl_.shr(x.low, 31)) then 
    _G.error(__haxe_Exception.thrown("Overflow"),0);
  end;
  local x = x.low;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(x, 31), x);
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.eq = function(a,b) 
  if (a.high == b.high) then 
    do return a.low == b.low end;
  else
    do return false end;
  end;
end
__haxe__Int64_Int64_Impl_.eqInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  if (a.high == b_high) then 
    do return a.low == b_low end;
  else
    do return false end;
  end;
end
__haxe__Int64_Int64_Impl_.neq = function(a,b) 
  if (a.high == b.high) then 
    do return a.low ~= b.low end;
  else
    do return true end;
  end;
end
__haxe__Int64_Int64_Impl_.neqInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  if (a.high == b_high) then 
    do return a.low ~= b_low end;
  else
    do return true end;
  end;
end
__haxe__Int64_Int64_Impl_.lt = function(a,b) 
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() < 0 end;
end
__haxe__Int64_Int64_Impl_.ltInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b_high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b_low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b_high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b_high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() < 0 end;
end
__haxe__Int64_Int64_Impl_.intLt = function(a,b) 
  local a_high = __haxe__Int32_Int32_Impl_.shr(a, 31);
  local a_low = a;
  local v = __haxe__Int32_Int32_Impl_.clamp(a_high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a_low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a_high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() < 0 end;
end
__haxe__Int64_Int64_Impl_.lte = function(a,b) 
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() <= 0 end;
end
__haxe__Int64_Int64_Impl_.lteInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b_high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b_low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b_high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b_high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() <= 0 end;
end
__haxe__Int64_Int64_Impl_.intLte = function(a,b) 
  local a_high = __haxe__Int32_Int32_Impl_.shr(a, 31);
  local a_low = a;
  local v = __haxe__Int32_Int32_Impl_.clamp(a_high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a_low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a_high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() <= 0 end;
end
__haxe__Int64_Int64_Impl_.gt = function(a,b) 
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() > 0 end;
end
__haxe__Int64_Int64_Impl_.gtInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b_high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b_low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b_high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b_high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() > 0 end;
end
__haxe__Int64_Int64_Impl_.intGt = function(a,b) 
  local a_high = __haxe__Int32_Int32_Impl_.shr(a, 31);
  local a_low = a;
  local v = __haxe__Int32_Int32_Impl_.clamp(a_high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a_low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a_high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() > 0 end;
end
__haxe__Int64_Int64_Impl_.gte = function(a,b) 
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() >= 0 end;
end
__haxe__Int64_Int64_Impl_.gteInt = function(a,b) 
  local b_high = __haxe__Int32_Int32_Impl_.shr(b, 31);
  local b_low = b;
  local v = __haxe__Int32_Int32_Impl_.clamp(a.high - b_high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a.low, b_low);
  end;
  do return (function() 
    local _hx_1
    if (a.high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b_high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b_high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() >= 0 end;
end
__haxe__Int64_Int64_Impl_.intGte = function(a,b) 
  local a_high = __haxe__Int32_Int32_Impl_.shr(a, 31);
  local a_low = a;
  local v = __haxe__Int32_Int32_Impl_.clamp(a_high - b.high);
  if (v == 0) then 
    v = __haxe__Int32_Int32_Impl_.ucompare(a_low, b.low);
  end;
  do return (function() 
    local _hx_1
    if (a_high < 0) then 
    _hx_1 = (function() 
      local _hx_2
      if (b.high < 0) then 
      _hx_2 = v; else 
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then 
    _hx_1 = v; else 
    _hx_1 = 1; end
    return _hx_1
  end )() >= 0 end;
end
__haxe__Int64_Int64_Impl_.complement = function(a) 
  local a1 = a.high;
  local high = _hx_bit_clamp(_hx_bit.bnot(a1));
  local a = a.low;
  local this1 = __haxe__Int64____Int64.new(high, _hx_bit_clamp(_hx_bit.bnot(a)));
  do return this1 end;
end
__haxe__Int64_Int64_Impl_["and"] = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(_hx_bit.band(a.high,b.high), _hx_bit.band(a.low,b.low));
  do return this1 end;
end
__haxe__Int64_Int64_Impl_["or"] = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](a.high, b.high), __haxe__Int32_Int32_Impl_["or"](a.low, b.low));
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.xor = function(a,b) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.xor(a.high, b.high), __haxe__Int32_Int32_Impl_.xor(a.low, b.low));
  do return this1 end;
end
__haxe__Int64_Int64_Impl_.shl = function(a,b) 
  b = _hx_bit.band(b,63);
  if (b == 0) then 
    local this1 = __haxe__Int64____Int64.new(a.high, a.low);
    do return this1 end;
  else
    if (b < 32) then 
      local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a.high,b)), _hx_bit.rshift(a.low,32 - b)), __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a.low,b)));
      do return this1 end;
    else
      local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a.low,b - 32)), 0);
      do return this1 end;
    end;
  end;
end
__haxe__Int64_Int64_Impl_.shr = function(a,b) 
  b = _hx_bit.band(b,63);
  if (b == 0) then 
    local this1 = __haxe__Int64____Int64.new(a.high, a.low);
    do return this1 end;
  else
    if (b < 32) then 
      local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(a.high, b), __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a.high,32 - b)), _hx_bit.rshift(a.low,b)));
      do return this1 end;
    else
      local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(a.high, 31), __haxe__Int32_Int32_Impl_.shr(a.high, b - 32));
      do return this1 end;
    end;
  end;
end
__haxe__Int64_Int64_Impl_.ushr = function(a,b) 
  b = _hx_bit.band(b,63);
  if (b == 0) then 
    local this1 = __haxe__Int64____Int64.new(a.high, a.low);
    do return this1 end;
  else
    if (b < 32) then 
      local this1 = __haxe__Int64____Int64.new(_hx_bit.rshift(a.high,b), __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a.high,32 - b)), _hx_bit.rshift(a.low,b)));
      do return this1 end;
    else
      local this1 = __haxe__Int64____Int64.new(0, _hx_bit.rshift(a.high,b - 32));
      do return this1 end;
    end;
  end;
end
__haxe__Int64_Int64_Impl_.get_high = function(this1) 
  do return this1.high end;
end
__haxe__Int64_Int64_Impl_.set_high = function(this1,x) 
  this1.high = x do return this1.high end;
end
__haxe__Int64_Int64_Impl_.get_low = function(this1) 
  do return this1.low end;
end
__haxe__Int64_Int64_Impl_.set_low = function(this1,x) 
  this1.low = x do return this1.low end;
end

__haxe__Int64____Int64.new = function(high,low) 
  local self = _hx_new(__haxe__Int64____Int64.prototype)
  __haxe__Int64____Int64.super(self,high,low)
  return self
end
__haxe__Int64____Int64.super = function(self,high,low) 
  self.high = high;
  self.low = low;
end
_hxClasses["haxe._Int64.___Int64"] = __haxe__Int64____Int64
__haxe__Int64____Int64.__name__ = "haxe._Int64.___Int64"
__haxe__Int64____Int64.prototype = _hx_e();
__haxe__Int64____Int64.prototype.high= nil;
__haxe__Int64____Int64.prototype.low= nil;
__haxe__Int64____Int64.prototype.toString = function(self) 
  do return _hx_wrap_if_string_field(__haxe__Int64_Int64_Impl_,'toString')(self) end
end

__haxe__Int64____Int64.prototype.__class__ =  __haxe__Int64____Int64

__haxe_Int64Helper.new = {}
_hxClasses["haxe.Int64Helper"] = __haxe_Int64Helper
__haxe_Int64Helper.__name__ = "haxe.Int64Helper"
__haxe_Int64Helper.parseString = function(sParam) 
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(10, 31), 10);
  local base = this1;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(0, 31), 0);
  local current = this1;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(1, 31), 1);
  local multiplier = this1;
  local sIsNegative = false;
  local s = StringTools.trim(sParam);
  if (__lua_lib_luautf8_Utf8.sub(s, 1, 1) == "-") then 
    sIsNegative = true;
    local startIndex = 1;
    local endIndex = __lua_lib_luautf8_Utf8.len(s);
    if (endIndex == nil) then 
      endIndex = __lua_lib_luautf8_Utf8.len(s);
    end;
    if (endIndex < 0) then 
      endIndex = 0;
    end;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
    s = (function() 
      local _hx_1
      if (endIndex < startIndex) then 
      _hx_1 = __lua_lib_luautf8_Utf8.sub(s, endIndex + 1, startIndex); else 
      _hx_1 = __lua_lib_luautf8_Utf8.sub(s, startIndex + 1, endIndex); end
      return _hx_1
    end )();
  end;
  local len = __lua_lib_luautf8_Utf8.len(s);
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local digitInt = __lua_lib_luautf8_Utf8.byte(s, ((len - 1) - i) + 1) - 48;
    if ((digitInt < 0) or (digitInt > 9)) then 
      _G.error(__haxe_Exception.thrown("NumberFormatError"),0);
    end;
    if (digitInt ~= 0) then 
      local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(digitInt, 31), digitInt);
      local digit = this1;
      if (sIsNegative) then 
        local b = __haxe__Int64_Int64_Impl_.mul(multiplier, digit);
        local high = __haxe__Int32_Int32_Impl_.clamp(current.high - b.high);
        local low = __haxe__Int32_Int32_Impl_.clamp(current.low - b.low);
        if (__haxe__Int32_Int32_Impl_.ucompare(current.low, b.low) < 0) then 
          high = high - 1;
          local ret = high + 1;
          high = __haxe__Int32_Int32_Impl_.clamp(high);
        end;
        local this1 = __haxe__Int64____Int64.new(high, low);
        current = this1;
        if (not (current.high < 0)) then 
          _G.error(__haxe_Exception.thrown("NumberFormatError: Underflow"),0);
        end;
      else
        local b = __haxe__Int64_Int64_Impl_.mul(multiplier, digit);
        local high = __haxe__Int32_Int32_Impl_.clamp(current.high + b.high);
        local low = __haxe__Int32_Int32_Impl_.clamp(current.low + b.low);
        if (__haxe__Int32_Int32_Impl_.ucompare(low, current.low) < 0) then 
          high = high + 1;
          local ret = high - 1;
          high = __haxe__Int32_Int32_Impl_.clamp(high);
        end;
        local this1 = __haxe__Int64____Int64.new(high, low);
        current = this1;
        if (current.high < 0) then 
          _G.error(__haxe_Exception.thrown("NumberFormatError: Overflow"),0);
        end;
      end;
    end;
    multiplier = __haxe__Int64_Int64_Impl_.mul(multiplier, base);
  end;
  do return current end;
end
__haxe_Int64Helper.fromFloat = function(f) 
  if (Math.isNaN(f) or not Math.isFinite(f)) then 
    _G.error(__haxe_Exception.thrown("Number is NaN or Infinite"),0);
  end;
  local noFractions = f - (_G.math.fmod(f, 1));
  if (noFractions > 9007199254740991) then 
    _G.error(__haxe_Exception.thrown("Conversion overflow"),0);
  end;
  if (noFractions < -9007199254740991) then 
    _G.error(__haxe_Exception.thrown("Conversion underflow"),0);
  end;
  local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(0, 31), 0);
  local result = this1;
  local neg = noFractions < 0;
  local rest = (function() 
    local _hx_1
    if (neg) then 
    _hx_1 = -noFractions; else 
    _hx_1 = noFractions; end
    return _hx_1
  end )();
  local i = 0;
  while (rest >= 1) do 
    local curr = _G.math.fmod(rest, 2);
    rest = rest / 2;
    if (curr >= 1) then 
      local a_high = __haxe__Int32_Int32_Impl_.shr(1, 31);
      local a_low = 1;
      local b = i;
      b = _hx_bit.band(b,63);
      local b1;
      if (b == 0) then 
        local this1 = __haxe__Int64____Int64.new(a_high, a_low);
        b1 = this1;
      else
        if (b < 32) then 
          local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a_high,b)), _hx_bit.rshift(a_low,32 - b)), __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a_low,b)));
          b1 = this1;
        else
          local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a_low,b - 32)), 0);
          b1 = this1;
        end;
      end;
      local high = __haxe__Int32_Int32_Impl_.clamp(result.high + b1.high);
      local low = __haxe__Int32_Int32_Impl_.clamp(result.low + b1.low);
      if (__haxe__Int32_Int32_Impl_.ucompare(low, result.low) < 0) then 
        high = high + 1;
        local ret = high - 1;
        high = __haxe__Int32_Int32_Impl_.clamp(high);
      end;
      local this1 = __haxe__Int64____Int64.new(high, low);
      result = this1;
    end;
    i = i + 1;
  end;
  if (neg) then 
    local a = result.high;
    local high = _hx_bit_clamp(_hx_bit.bnot(a));
    local low = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(result.low) + 1);
    if (low == 0) then 
      high = high + 1;
      local ret = high - 1;
      high = __haxe__Int32_Int32_Impl_.clamp(high);
    end;
    local this1 = __haxe__Int64____Int64.new(high, low);
    result = this1;
  end;
  do return result end;
end

__haxe_Log.new = {}
_hxClasses["haxe.Log"] = __haxe_Log
__haxe_Log.__name__ = "haxe.Log"
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do 
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_MainEvent.new = function(f,p) 
  local self = _hx_new(__haxe_MainEvent.prototype)
  __haxe_MainEvent.super(self,f,p)
  return self
end
__haxe_MainEvent.super = function(self,f,p) 
  self.isBlocking = true;
  self.f = _hx_funcToField(f);
  self.priority = p;
  self.nextRun = -_G.math.huge;
end
_hxClasses["haxe.MainEvent"] = __haxe_MainEvent
__haxe_MainEvent.__name__ = "haxe.MainEvent"
__haxe_MainEvent.prototype = _hx_e();
__haxe_MainEvent.prototype.f= nil;
__haxe_MainEvent.prototype.prev= nil;
__haxe_MainEvent.prototype.next= nil;
__haxe_MainEvent.prototype.isBlocking= nil;
__haxe_MainEvent.prototype.nextRun= nil;
__haxe_MainEvent.prototype.priority= nil;
__haxe_MainEvent.prototype.delay = function(self,t) 
  self.nextRun = (function() 
    local _hx_1
    if (t == nil) then 
    _hx_1 = -_G.math.huge; else 
    _hx_1 = Sys.time() + t; end
    return _hx_1
  end )();
end
__haxe_MainEvent.prototype.call = function(self) 
  if (self.f ~= nil) then 
    self:f();
  end;
end
__haxe_MainEvent.prototype.stop = function(self) 
  if (self.f == nil) then 
    do return end;
  end;
  self.f = nil;
  self.nextRun = -_G.math.huge;
  if (self.prev == nil) then 
    __haxe_MainLoop.pending = self.next;
  else
    self.prev.next = self.next;
  end;
  if (self.next ~= nil) then 
    self.next.prev = self.prev;
  end;
end

__haxe_MainEvent.prototype.__class__ =  __haxe_MainEvent

__haxe_MainLoop.new = {}
_hxClasses["haxe.MainLoop"] = __haxe_MainLoop
__haxe_MainLoop.__name__ = "haxe.MainLoop"
__haxe_MainLoop.__properties__ = {get_threadCount="get_threadCount"}
__haxe_MainLoop.pending = nil
__haxe_MainLoop.get_threadCount = function() 
  do return __haxe_EntryPoint.threadCount end;
end
__haxe_MainLoop.hasEvents = function() 
  local p = __haxe_MainLoop.pending;
  while (p ~= nil) do 
    if (p.isBlocking) then 
      do return true end;
    end;
    p = p.next;
  end;
  do return false end;
end
__haxe_MainLoop.addThread = function(f) 
  __haxe_EntryPoint.addThread(f);
end
__haxe_MainLoop.runInMainThread = function(f) 
  __haxe_EntryPoint.runInMainThread(f);
end
__haxe_MainLoop.add = function(f,priority) 
  if (priority == nil) then 
    priority = 0;
  end;
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown("Event function is null"),0);
  end;
  local e = __haxe_MainEvent.new(f, priority);
  local head = __haxe_MainLoop.pending;
  if (head ~= nil) then 
    head.prev = e;
  end;
  e.next = head;
  __haxe_MainLoop.pending = e;
  do return e end;
end
__haxe_MainLoop.sortEvents = function() 
  local list = __haxe_MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g = 0;
      local _g1 = insize;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
      end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
      end;
      p = q;
    end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
  end;
  list.prev = nil;
  __haxe_MainLoop.pending = list;
end
__haxe_MainLoop.tick = function() 
  __haxe_MainLoop.sortEvents();
  local e = __haxe_MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if (wt <= 0) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
  end;
  do return wait end;
end

__haxe_NativeStackTrace.new = {}
_hxClasses["haxe.NativeStackTrace"] = __haxe_NativeStackTrace
__haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace"
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len("\n") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(s, "\n", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len("\n");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
        idx = nil;
      end;
    end;
    do return ret:slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end
__haxe_NativeStackTrace.toHaxe = function(native,skip) 
  if (skip == nil) then 
    skip = 0;
  end;
  local stack = _hx_tab_array({}, 0);
  local cnt = -1;
  local _g = 0;
  local _hx_continue_1 = false;
  while (_g < native.length) do repeat 
    local item = native[_g];
    _g = _g + 1;
    local pos = 1;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(item)))) then 
      len = __lua_lib_luautf8_Utf8.len(item);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(item) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(item) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    local _this = __lua_lib_luautf8_Utf8.sub(item, pos + 1, pos + len);
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(_this, ":", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len(":");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
        idx = nil;
      end;
    end;
    local parts = ret;
    local file = parts[0];
    if (file == "[C]") then 
      break;
    end;
    cnt = cnt + 1;
    if (skip > cnt) then 
      break;
    end;
    local line = parts[1];
    local method;
    if (parts.length <= 2) then 
      method = nil;
    else
      local _this = parts[2];
      local startIndex = nil;
      if (startIndex == nil) then 
        startIndex = 1;
      else
        startIndex = startIndex + 1;
      end;
      local r = __lua_lib_luautf8_Utf8.find(_this, "'", startIndex, true);
      local methodPos = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
      if (methodPos < 0) then 
        method = nil;
      else
        local _this = parts[2];
        local startIndex = methodPos + 1;
        local endIndex = __lua_lib_luautf8_Utf8.len(parts[2]) - 1;
        if (endIndex == nil) then 
          endIndex = __lua_lib_luautf8_Utf8.len(_this);
        end;
        if (endIndex < 0) then 
          endIndex = 0;
        end;
        if (startIndex < 0) then 
          startIndex = 0;
        end;
        method = __haxe_StackItem.Method(nil, (function() 
          local _hx_2
          if (endIndex < startIndex) then 
          _hx_2 = __lua_lib_luautf8_Utf8.sub(_this, endIndex + 1, startIndex); else 
          _hx_2 = __lua_lib_luautf8_Utf8.sub(_this, startIndex + 1, endIndex); end
          return _hx_2
        end )());
      end;
    end;
    stack:push(__haxe_StackItem.FilePos(method, file, Std.parseInt(line)));until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return stack end;
end

__haxe_Resource.new = {}
_hxClasses["haxe.Resource"] = __haxe_Resource
__haxe_Resource.__name__ = "haxe.Resource"
__haxe_Resource.content = nil
__haxe_Resource.listNames = function() 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __haxe_Resource.content;
  while (_g1 < _g2.length) do 
    local x = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(x.name);
  end;
  do return _g end;
end
__haxe_Resource.getString = function(name) 
  local _g = 0;
  local _g1 = __haxe_Resource.content;
  while (_g < _g1.length) do 
    local x = _g1[_g];
    _g = _g + 1;
    if (x.name == name) then 
      if (x.str ~= nil) then 
        do return x.str end;
      end;
      local b = __haxe_crypto_Base64.decode(x.data);
      do return b:toString() end;
    end;
  end;
  do return nil end;
end
__haxe_Resource.getBytes = function(name) 
  local _g = 0;
  local _g1 = __haxe_Resource.content;
  while (_g < _g1.length) do 
    local x = _g1[_g];
    _g = _g + 1;
    if (x.name == name) then 
      if (x.str ~= nil) then 
        do return __haxe_io_Bytes.ofString(x.str) end;
      end;
      do return __haxe_crypto_Base64.decode(x.data) end;
    end;
  end;
  do return nil end;
end

__haxe_Timer.new = function(time_ms) 
  local self = _hx_new(__haxe_Timer.prototype)
  __haxe_Timer.super(self,time_ms)
  return self
end
__haxe_Timer.super = function(self,time_ms) 
  local _gthis = self;
  local dt = time_ms / 1000;
  self.event = __haxe_MainLoop.add(function() 
    local _gthis1 = _gthis.event;
    _gthis1.nextRun = _gthis1.nextRun + dt;
    _gthis:run();
  end);
  self.event:delay(dt);
end
_hxClasses["haxe.Timer"] = __haxe_Timer
__haxe_Timer.__name__ = "haxe.Timer"
__haxe_Timer.delay = function(f,time_ms) 
  local t = __haxe_Timer.new(time_ms);
  t.run = function(self) 
    t:stop();
    f();
   end;
  do return t end;
end
__haxe_Timer.measure = function(f,pos) 
  local t0 = Sys.time();
  local r = f();
  __haxe_Log.trace(Std.string(Sys.time() - t0) .. Std.string("s"), pos);
  do return r end;
end
__haxe_Timer.stamp = function() 
  do return Sys.time() end;
end
__haxe_Timer.prototype = _hx_e();
__haxe_Timer.prototype.event= nil;
__haxe_Timer.prototype.stop = function(self) 
  if (self.event ~= nil) then 
    self.event:stop();
    self.event = nil;
  end;
end
__haxe_Timer.prototype.run = function(self) 
end

__haxe_Timer.prototype.__class__ =  __haxe_Timer

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,Std.string(value),previous,native);
  self.value = value;
  self.__skipStack = self.__skipStack + 1;
end
_hxClasses["haxe.ValueException"] = __haxe_ValueException
__haxe_ValueException.__name__ = "haxe.ValueException"
__haxe_ValueException.prototype = _hx_e();
__haxe_ValueException.prototype.value= nil;
__haxe_ValueException.prototype.unwrap = function(self) 
  do return self.value end
end

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})
setmetatable(__haxe_ValueException.prototype.__properties__,{__index=__haxe_Exception.prototype.__properties__})

__haxe_io_Bytes.new = function(length,b) 
  local self = _hx_new(__haxe_io_Bytes.prototype)
  __haxe_io_Bytes.super(self,length,b)
  return self
end
__haxe_io_Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
_hxClasses["haxe.io.Bytes"] = __haxe_io_Bytes
__haxe_io_Bytes.__name__ = "haxe.io.Bytes"
__haxe_io_Bytes.alloc = function(length) 
  local a = Array.new();
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    a:push(0);
  end;
  do return __haxe_io_Bytes.new(length, a) end;
end
__haxe_io_Bytes.ofString = function(s,encoding) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = _G.string.len(s);
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(_G.string.byte(s, i + 1));
  end;
  local bytes = _g;
  do return __haxe_io_Bytes.new(bytes.length, bytes) end;
end
__haxe_io_Bytes.ofData = function(b) 
  do return __haxe_io_Bytes.new(b.length, b) end;
end
__haxe_io_Bytes.ofHex = function(s) 
  local len = __lua_lib_luautf8_Utf8.len(s);
  if ((_hx_bit.band(len,1)) ~= 0) then 
    _G.error(__haxe_Exception.thrown("Not a hex string (odd number of digits)"),0);
  end;
  local ret = __haxe_io_Bytes.alloc(_hx_bit.arshift(len,1));
  local _g = 0;
  local _g1 = ret.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local high = __lua_lib_luautf8_Utf8.byte(s, (i * 2) + 1);
    local low = __lua_lib_luautf8_Utf8.byte(s, ((i * 2) + 1) + 1);
    high = (_hx_bit.band(high,15)) + ((_hx_bit.arshift((_hx_bit.band(high,64)),6)) * 9);
    low = (_hx_bit.band(low,15)) + ((_hx_bit.arshift((_hx_bit.band(low,64)),6)) * 9);
    ret.b[i] = _hx_bit.band(_hx_bit.band((_hx_bit.bor(_hx_bit.lshift(high,4),low)),255),255);
  end;
  do return ret end;
end
__haxe_io_Bytes.fastGet = function(b,pos) 
  do return b[pos] end;
end
__haxe_io_Bytes.prototype = _hx_e();
__haxe_io_Bytes.prototype.length= nil;
__haxe_io_Bytes.prototype.b= nil;
__haxe_io_Bytes.prototype.get = function(self,pos) 
  do return self.b[pos] end
end
__haxe_io_Bytes.prototype.set = function(self,pos,v) 
  self.b[pos] = _hx_bit.band(v,255);
end
__haxe_io_Bytes.prototype.blit = function(self,pos,src,srcpos,len) 
  if (((((pos < 0) or (srcpos < 0)) or (len < 0)) or ((pos + len) > self.length)) or ((srcpos + len) > src.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  local b1 = self.b;
  local b2 = src.b;
  if ((b1 == b2) and (pos > srcpos)) then 
    local i = len;
    while (i > 0) do 
      i = i - 1;
      b1[i + pos] = b2[i + srcpos];
    end;
    do return end;
  end;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    b1[i + pos] = b2[i + srcpos];
  end;
end
__haxe_io_Bytes.prototype.fill = function(self,pos,len,value) 
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    pos = pos + 1;
    self.b[pos - 1] = _hx_bit.band(value,255);
  end;
end
__haxe_io_Bytes.prototype.sub = function(self,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  do return __haxe_io_Bytes.new(len, self.b:slice(pos, pos + len)) end
end
__haxe_io_Bytes.prototype.compare = function(self,other) 
  local b1 = self.b;
  local b2 = other.b;
  local len = (function() 
    local _hx_1
    if (self.length < other.length) then 
    _hx_1 = self.length; else 
    _hx_1 = other.length; end
    return _hx_1
  end )();
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (b1[i] ~= b2[i]) then 
      do return b1[i] - b2[i] end;
    end;
  end;
  do return self.length - other.length end
end
__haxe_io_Bytes.prototype.getDouble = function(self,pos) 
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
  local tmp = _hx_bit_clamp((function() 
    local _hx_1
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_1 = _hx_bit.bor(v,-2147483648); else 
    _hx_1 = v; end
    return _hx_1
  end )());
  local pos = pos + 4;
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
  do return __haxe_io_FPHelper.i64ToDouble(tmp, _hx_bit_clamp((function() 
    local _hx_2
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_2 = _hx_bit.bor(v,-2147483648); else 
    _hx_2 = v; end
    return _hx_2
  end )())) end
end
__haxe_io_Bytes.prototype.getFloat = function(self,pos) 
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
  do return __haxe_io_FPHelper.i32ToFloat(_hx_bit_clamp((function() 
    local _hx_1
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_1 = _hx_bit.bor(v,-2147483648); else 
    _hx_1 = v; end
    return _hx_1
  end )())) end
end
__haxe_io_Bytes.prototype.setDouble = function(self,pos,v) 
  local i = __haxe_io_FPHelper.doubleToI64(v);
  local v = i.low;
  self.b[pos] = _hx_bit.band(v,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
  self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v,16),255);
  self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v,24),255);
  local pos = pos + 4;
  local v = i.high;
  self.b[pos] = _hx_bit.band(v,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
  self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v,16),255);
  self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v,24),255);
end
__haxe_io_Bytes.prototype.setFloat = function(self,pos,v) 
  local v = __haxe_io_FPHelper.floatToI32(v);
  self.b[pos] = _hx_bit.band(v,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
  self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v,16),255);
  self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v,24),255);
end
__haxe_io_Bytes.prototype.getUInt16 = function(self,pos) 
  do return _hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)) end
end
__haxe_io_Bytes.prototype.setUInt16 = function(self,pos,v) 
  self.b[pos] = _hx_bit.band(v,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
end
__haxe_io_Bytes.prototype.getInt32 = function(self,pos) 
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
  do return _hx_bit_clamp((function() 
    local _hx_1
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_1 = _hx_bit.bor(v,-2147483648); else 
    _hx_1 = v; end
    return _hx_1
  end )()) end
end
__haxe_io_Bytes.prototype.getInt64 = function(self,pos) 
  local pos1 = pos + 4;
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos1],_hx_bit.lshift(self.b[pos1 + 1],8)),_hx_bit.lshift(self.b[pos1 + 2],16)),_hx_bit.lshift(self.b[pos1 + 3],24));
  local high = _hx_bit_clamp((function() 
    local _hx_1
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_1 = _hx_bit.bor(v,-2147483648); else 
    _hx_1 = v; end
    return _hx_1
  end )());
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
  local this1 = __haxe__Int64____Int64.new(high, _hx_bit_clamp((function() 
    local _hx_2
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_2 = _hx_bit.bor(v,-2147483648); else 
    _hx_2 = v; end
    return _hx_2
  end )()));
  do return this1 end
end
__haxe_io_Bytes.prototype.setInt32 = function(self,pos,v) 
  self.b[pos] = _hx_bit.band(v,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
  self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v,16),255);
  self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v,24),255);
end
__haxe_io_Bytes.prototype.setInt64 = function(self,pos,v) 
  local v1 = v.low;
  self.b[pos] = _hx_bit.band(v1,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v1,8),255);
  self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v1,16),255);
  self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v1,24),255);
  local pos = pos + 4;
  local v = v.high;
  self.b[pos] = _hx_bit.band(v,255);
  self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
  self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v,16),255);
  self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v,24),255);
end
__haxe_io_Bytes.prototype.getString = function(self,pos,len,encoding) 
  local tmp = encoding == nil;
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  if ((self.b.length - pos) <= __lua_Boot.MAXSTACKSIZE) then 
    local _end = Math.min(self.b.length, pos + len) - 1;
    do return _G.string.char(_hx_table.unpack(self.b, pos, _end)) end;
  else
    local tbl = ({});
    local _g = pos;
    local _g1 = pos + len;
    while (_g < _g1) do 
      _g = _g + 1;
      local idx = _g - 1;
      _G.table.insert(tbl, _G.string.char(self.b[idx]));
    end;
    do return _G.table.concat(tbl, "") end;
  end;
end
__haxe_io_Bytes.prototype.readString = function(self,pos,len) 
  do return self:getString(pos, len) end
end
__haxe_io_Bytes.prototype.toString = function(self) 
  do return self:getString(0, self.length) end
end
__haxe_io_Bytes.prototype.toHex = function(self) 
  local s_b = ({});
  local s_length = 0;
  local chars = _hx_tab_array({}, 0);
  local str = "0123456789abcdef";
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(str);
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    chars:push(__lua_lib_luautf8_Utf8.byte(str, i + 1));
  end;
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local c = self.b[i];
    _G.table.insert(s_b, __lua_lib_luautf8_Utf8.char(chars[_hx_bit.arshift(c,4)]));
    s_length = s_length + 1;
    _G.table.insert(s_b, __lua_lib_luautf8_Utf8.char(chars[_hx_bit.band(c,15)]));
    s_length = s_length + 1;
  end;
  do return _G.table.concat(s_b) end
end
__haxe_io_Bytes.prototype.getData = function(self) 
  do return self.b end
end

__haxe_io_Bytes.prototype.__class__ =  __haxe_io_Bytes

__haxe_crypto_Base64.new = {}
_hxClasses["haxe.crypto.Base64"] = __haxe_crypto_Base64
__haxe_crypto_Base64.__name__ = "haxe.crypto.Base64"
__haxe_crypto_Base64.encode = function(bytes,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  local str = __haxe_crypto_BaseCode.new(__haxe_crypto_Base64.BYTES):encodeBytes(bytes):toString();
  if (complement) then 
    local _g = _G.math.fmod(bytes.length, 3);
    if (_g) == 1 then 
      str = Std.string(str) .. Std.string("==");
    elseif (_g) == 2 then 
      str = Std.string(str) .. Std.string("=");else end;
  end;
  do return str end;
end
__haxe_crypto_Base64.decode = function(str,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  if (complement) then 
    while (__lua_lib_luautf8_Utf8.byte(str, (__lua_lib_luautf8_Utf8.len(str) - 1) + 1) == 61) do 
      local pos = 0;
      local len = -1;
      if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(str)))) then 
        len = __lua_lib_luautf8_Utf8.len(str);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(str) + len;
        end;
      end;
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(str) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      str = __lua_lib_luautf8_Utf8.sub(str, pos + 1, pos + len);
    end;
  end;
  do return __haxe_crypto_BaseCode.new(__haxe_crypto_Base64.BYTES):decodeBytes(__haxe_io_Bytes.ofString(str)) end;
end
__haxe_crypto_Base64.urlEncode = function(bytes,complement) 
  if (complement == nil) then 
    complement = false;
  end;
  local str = __haxe_crypto_BaseCode.new(__haxe_crypto_Base64.URL_BYTES):encodeBytes(bytes):toString();
  if (complement) then 
    local _g = _G.math.fmod(bytes.length, 3);
    if (_g) == 1 then 
      str = Std.string(str) .. Std.string("==");
    elseif (_g) == 2 then 
      str = Std.string(str) .. Std.string("=");else end;
  end;
  do return str end;
end
__haxe_crypto_Base64.urlDecode = function(str,complement) 
  if (complement == nil) then 
    complement = false;
  end;
  if (complement) then 
    while (__lua_lib_luautf8_Utf8.byte(str, (__lua_lib_luautf8_Utf8.len(str) - 1) + 1) == 61) do 
      local pos = 0;
      local len = -1;
      if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(str)))) then 
        len = __lua_lib_luautf8_Utf8.len(str);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(str) + len;
        end;
      end;
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(str) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      str = __lua_lib_luautf8_Utf8.sub(str, pos + 1, pos + len);
    end;
  end;
  do return __haxe_crypto_BaseCode.new(__haxe_crypto_Base64.URL_BYTES):decodeBytes(__haxe_io_Bytes.ofString(str)) end;
end

__haxe_crypto_BaseCode.new = function(base) 
  local self = _hx_new(__haxe_crypto_BaseCode.prototype)
  __haxe_crypto_BaseCode.super(self,base)
  return self
end
__haxe_crypto_BaseCode.super = function(self,base) 
  local len = base.length;
  local nbits = 1;
  while (len > (_hx_bit.lshift(1,nbits))) do 
    nbits = nbits + 1;
  end;
  if ((nbits > 8) or (len ~= (_hx_bit.lshift(1,nbits)))) then 
    _G.error(__haxe_Exception.thrown("BaseCode : base length must be a power of two."),0);
  end;
  self.base = base;
  self.nbits = nbits;
end
_hxClasses["haxe.crypto.BaseCode"] = __haxe_crypto_BaseCode
__haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode"
__haxe_crypto_BaseCode.encode = function(s,base) 
  local b = __haxe_crypto_BaseCode.new(__haxe_io_Bytes.ofString(base));
  do return b:encodeString(s) end;
end
__haxe_crypto_BaseCode.decode = function(s,base) 
  local b = __haxe_crypto_BaseCode.new(__haxe_io_Bytes.ofString(base));
  do return b:decodeString(s) end;
end
__haxe_crypto_BaseCode.prototype = _hx_e();
__haxe_crypto_BaseCode.prototype.base= nil;
__haxe_crypto_BaseCode.prototype.nbits= nil;
__haxe_crypto_BaseCode.prototype.tbl= nil;
__haxe_crypto_BaseCode.prototype.encodeBytes = function(self,b) 
  local nbits = self.nbits;
  local base = self.base;
  local size = Std.int((b.length * 8) / nbits);
  local out = __haxe_io_Bytes.alloc(size + (function() 
    local _hx_1
    if ((_G.math.fmod(b.length * 8, nbits)) == 0) then 
    _hx_1 = 0; else 
    _hx_1 = 1; end
    return _hx_1
  end )());
  local buf = 0;
  local curbits = 0;
  local mask = (_hx_bit.lshift(1,nbits)) - 1;
  local pin = 0;
  local pout = 0;
  while (pout < size) do 
    while (curbits < nbits) do 
      curbits = curbits + 8;
      buf = _hx_bit.lshift(buf,8);
      pin = pin + 1;
      buf = _hx_bit.bor(buf,b.b[pin - 1]);
    end;
    curbits = curbits - nbits;
    pout = pout + 1;
    out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.arshift(buf,curbits),mask)],255);
  end;
  if (curbits > 0) then 
    pout = pout + 1;
    out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.lshift(buf,nbits - curbits),mask)],255);
  end;
  do return out end
end
__haxe_crypto_BaseCode.prototype.initTable = function(self) 
  local tbl = Array.new();
  local _g = 0;
  while (_g < 256) do 
    _g = _g + 1;
    local i = _g - 1;
    tbl[i] = -1;
  end;
  local _g = 0;
  local _g1 = self.base.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    tbl[self.base.b[i]] = i;
  end;
  self.tbl = tbl;
end
__haxe_crypto_BaseCode.prototype.decodeBytes = function(self,b) 
  local nbits = self.nbits;
  local base = self.base;
  if (self.tbl == nil) then 
    self:initTable();
  end;
  local tbl = self.tbl;
  local size = _hx_bit.arshift(b.length * nbits,3);
  local out = __haxe_io_Bytes.alloc(size);
  local buf = 0;
  local curbits = 0;
  local pin = 0;
  local pout = 0;
  while (pout < size) do 
    while (curbits < 8) do 
      curbits = curbits + nbits;
      buf = _hx_bit.lshift(buf,nbits);
      pin = pin + 1;
      local i = tbl[b.b[pin - 1]];
      if (i == -1) then 
        _G.error(__haxe_Exception.thrown("BaseCode : invalid encoded char"),0);
      end;
      buf = _hx_bit.bor(buf,i);
    end;
    curbits = curbits - 8;
    pout = pout + 1;
    out.b[pout - 1] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(buf,curbits),255),255);
  end;
  do return out end
end
__haxe_crypto_BaseCode.prototype.encodeString = function(self,s) 
  do return self:encodeBytes(__haxe_io_Bytes.ofString(s)):toString() end
end
__haxe_crypto_BaseCode.prototype.decodeString = function(self,s) 
  do return self:decodeBytes(__haxe_io_Bytes.ofString(s)):toString() end
end

__haxe_crypto_BaseCode.prototype.__class__ =  __haxe_crypto_BaseCode

__haxe_ds_BalancedTree.new = function() 
  local self = _hx_new(__haxe_ds_BalancedTree.prototype)
  __haxe_ds_BalancedTree.super(self)
  return self
end
__haxe_ds_BalancedTree.super = function(self) 
end
_hxClasses["haxe.ds.BalancedTree"] = __haxe_ds_BalancedTree
__haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree"
__haxe_ds_BalancedTree.__interfaces__ = {__haxe_IMap}
__haxe_ds_BalancedTree.iteratorLoop = function(node,acc) 
  if (node ~= nil) then 
    __haxe_ds_BalancedTree.iteratorLoop(node.left, acc);
    acc:push(node.value);
    __haxe_ds_BalancedTree.iteratorLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype = _hx_e();
__haxe_ds_BalancedTree.prototype.root= nil;
__haxe_ds_BalancedTree.prototype.set = function(self,key,value) 
  self.root = self:setLoop(key, value, self.root);
end
__haxe_ds_BalancedTree.prototype.get = function(self,key) 
  local node = self.root;
  while (node ~= nil) do 
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return node.value end;
    end;
    if (c < 0) then 
      node = node.left;
    else
      node = node.right;
    end;
  end;
  do return nil end
end
__haxe_ds_BalancedTree.prototype.remove = function(self,key) 
  local _hx_status, _hx_result = pcall(function() 
  
      self.root = self:removeLoop(key, self.root);
      do return true end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), String)) then 
      do return false end;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__haxe_ds_BalancedTree.prototype.exists = function(self,key) 
  local node = self.root;
  while (node ~= nil) do 
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return true end;
    else
      if (c < 0) then 
        node = node.left;
      else
        node = node.right;
      end;
    end;
  end;
  do return false end
end
__haxe_ds_BalancedTree.prototype.iterator = function(self) 
  local ret = _hx_tab_array({}, 0);
  __haxe_ds_BalancedTree.iteratorLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_BalancedTree.prototype.keys = function(self) 
  local ret = _hx_tab_array({}, 0);
  self:keysLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.copy = function(self) 
  local copied = __haxe_ds_BalancedTree.new();
  copied.root = self.root;
  do return copied end
end
__haxe_ds_BalancedTree.prototype.setLoop = function(self,k,v,node) 
  if (node == nil) then 
    do return __haxe_ds_TreeNode.new(nil, k, v, nil) end;
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return __haxe_ds_TreeNode.new(node.left, k, v, node.right, (function() 
      local _hx_1
      if (node == nil) then 
      _hx_1 = 0; else 
      _hx_1 = node._height; end
      return _hx_1
    end )()) end;
  else
    if (c < 0) then 
      local nl = self:setLoop(k, v, node.left);
      do return self:balance(nl, node.key, node.value, node.right) end;
    else
      local nr = self:setLoop(k, v, node.right);
      do return self:balance(node.left, node.key, node.value, nr) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.removeLoop = function(self,k,node) 
  if (node == nil) then 
    _G.error(__haxe_Exception.thrown("Not_found"),0);
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return self:merge(node.left, node.right) end;
  else
    if (c < 0) then 
      do return self:balance(self:removeLoop(k, node.left), node.key, node.value, node.right) end;
    else
      do return self:balance(node.left, node.key, node.value, self:removeLoop(k, node.right)) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.keysLoop = function(self,node,acc) 
  if (node ~= nil) then 
    self:keysLoop(node.left, acc);
    acc:push(node.key);
    self:keysLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype.merge = function(self,t1,t2) 
  if (t1 == nil) then 
    do return t2 end;
  end;
  if (t2 == nil) then 
    do return t1 end;
  end;
  local t = self:minBinding(t2);
  do return self:balance(t1, t.key, t.value, self:removeMinBinding(t2)) end
end
__haxe_ds_BalancedTree.prototype.minBinding = function(self,t) 
  if (t == nil) then 
    _G.error(__haxe_Exception.thrown("Not_found"),0);
  else
    if (t.left == nil) then 
      do return t end;
    else
      do return self:minBinding(t.left) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.removeMinBinding = function(self,t) 
  if (t.left == nil) then 
    do return t.right end;
  else
    do return self:balance(self:removeMinBinding(t.left), t.key, t.value, t.right) end;
  end;
end
__haxe_ds_BalancedTree.prototype.balance = function(self,l,k,v,r) 
  local hl = (function() 
    local _hx_1
    if (l == nil) then 
    _hx_1 = 0; else 
    _hx_1 = l._height; end
    return _hx_1
  end )();
  local hr = (function() 
    local _hx_2
    if (r == nil) then 
    _hx_2 = 0; else 
    _hx_2 = r._height; end
    return _hx_2
  end )();
  if (hl > (hr + 2)) then 
    local _this = l.left;
    local _this1 = l.right;
    if ((function() 
      local _hx_3
      if (_this == nil) then 
      _hx_3 = 0; else 
      _hx_3 = _this._height; end
      return _hx_3
    end )() >= (function() 
      local _hx_4
      if (_this1 == nil) then 
      _hx_4 = 0; else 
      _hx_4 = _this1._height; end
      return _hx_4
    end )()) then 
      do return __haxe_ds_TreeNode.new(l.left, l.key, l.value, __haxe_ds_TreeNode.new(l.right, k, v, r)) end;
    else
      do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, __haxe_ds_TreeNode.new(l.right.right, k, v, r)) end;
    end;
  else
    if (hr > (hl + 2)) then 
      local _this = r.right;
      local _this1 = r.left;
      if ((function() 
        local _hx_5
        if (_this == nil) then 
        _hx_5 = 0; else 
        _hx_5 = _this._height; end
        return _hx_5
      end )() > (function() 
        local _hx_6
        if (_this1 == nil) then 
        _hx_6 = 0; else 
        _hx_6 = _this1._height; end
        return _hx_6
      end )()) then 
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left), r.key, r.value, r.right) end;
      else
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left.left), r.left.key, r.left.value, __haxe_ds_TreeNode.new(r.left.right, r.key, r.value, r.right)) end;
      end;
    else
      do return __haxe_ds_TreeNode.new(l, k, v, r, (function() 
        local _hx_7
        if (hl > hr) then 
        _hx_7 = hl; else 
        _hx_7 = hr; end
        return _hx_7
      end )() + 1) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.compare = function(self,k1,k2) 
  do return Reflect.compare(k1, k2) end
end
__haxe_ds_BalancedTree.prototype.toString = function(self) 
  if (self.root == nil) then 
    do return "{}" end;
  else
    do return Std.string(Std.string("{") .. Std.string(self.root:toString())) .. Std.string("}") end;
  end;
end
__haxe_ds_BalancedTree.prototype.clear = function(self) 
  self.root = nil;
end

__haxe_ds_BalancedTree.prototype.__class__ =  __haxe_ds_BalancedTree

__haxe_ds_TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(__haxe_ds_TreeNode.prototype)
  __haxe_ds_TreeNode.super(self,l,k,v,r,h)
  return self
end
__haxe_ds_TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this = self.left;
      tmp = (function() 
        local _hx_3
        if (_this == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this._height; end
        return _hx_3
      end )();
    else
      local _this = self.right;
      tmp = (function() 
        local _hx_4
        if (_this == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this._height; end
        return _hx_4
      end )();
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
_hxClasses["haxe.ds.TreeNode"] = __haxe_ds_TreeNode
__haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode"
__haxe_ds_TreeNode.prototype = _hx_e();
__haxe_ds_TreeNode.prototype.left= nil;
__haxe_ds_TreeNode.prototype.right= nil;
__haxe_ds_TreeNode.prototype.key= nil;
__haxe_ds_TreeNode.prototype.value= nil;
__haxe_ds_TreeNode.prototype._height= nil;
__haxe_ds_TreeNode.prototype.toString = function(self) 
  do return Std.string(Std.string(((function() 
    local _hx_1
    if (self.left == nil) then 
    _hx_1 = ""; else 
    _hx_1 = Std.string(self.left:toString()) .. Std.string(", "); end
    return _hx_1
  end )())) .. Std.string((Std.string(Std.string(Std.string("") .. Std.string(Std.string(self.key))) .. Std.string("=")) .. Std.string(Std.string(self.value))))) .. Std.string(((function() 
    local _hx_2
    if (self.right == nil) then 
    _hx_2 = ""; else 
    _hx_2 = Std.string(", ") .. Std.string(self.right:toString()); end
    return _hx_2
  end )())) end
end

__haxe_ds_TreeNode.prototype.__class__ =  __haxe_ds_TreeNode

__haxe_ds_EnumValueMap.new = function() 
  local self = _hx_new(__haxe_ds_EnumValueMap.prototype)
  __haxe_ds_EnumValueMap.super(self)
  return self
end
__haxe_ds_EnumValueMap.super = function(self) 
  __haxe_ds_BalancedTree.super(self);
end
_hxClasses["haxe.ds.EnumValueMap"] = __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap"
__haxe_ds_EnumValueMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_EnumValueMap.prototype = _hx_e();
__haxe_ds_EnumValueMap.prototype.compare = function(self,k1,k2) 
  local d = k1[1] - k2[1];
  if (d ~= 0) then 
    do return d end;
  end;
  local p1 = k1:slice(2);
  local p2 = k2:slice(2);
  if ((p1.length == 0) and (p2.length == 0)) then 
    do return 0 end;
  end;
  do return self:compareArgs(p1, p2) end
end
__haxe_ds_EnumValueMap.prototype.compareArgs = function(self,a1,a2) 
  local ld = a1.length - a2.length;
  if (ld ~= 0) then 
    do return ld end;
  end;
  local _g = 0;
  local _g1 = a1.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local d = self:compareArg(a1[i], a2[i]);
    if (d ~= 0) then 
      do return d end;
    end;
  end;
  do return 0 end
end
__haxe_ds_EnumValueMap.prototype.compareArg = function(self,v1,v2) 
  if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
    do return self:compare(v1, v2) end;
  else
    if (__lua_Boot.__instanceof(v1, Array) and __lua_Boot.__instanceof(v2, Array)) then 
      do return self:compareArgs(v1, v2) end;
    else
      do return Reflect.compare(v1, v2) end;
    end;
  end;
end
__haxe_ds_EnumValueMap.prototype.copy = function(self) 
  local copied = __haxe_ds_EnumValueMap.new();
  copied.root = self.root;
  do return copied end
end

__haxe_ds_EnumValueMap.prototype.__class__ =  __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__super__ = __haxe_ds_BalancedTree
setmetatable(__haxe_ds_EnumValueMap.prototype,{__index=__haxe_ds_BalancedTree.prototype})

__haxe_ds__HashMap_HashMap_Impl_.new = {}
_hxClasses["haxe.ds._HashMap.HashMap_Impl_"] = __haxe_ds__HashMap_HashMap_Impl_
__haxe_ds__HashMap_HashMap_Impl_.__name__ = "haxe.ds._HashMap.HashMap_Impl_"
__haxe_ds__HashMap_HashMap_Impl_._new = function() 
  local this1 = __haxe_ds__HashMap_HashMapData.new();
  do return this1 end;
end
__haxe_ds__HashMap_HashMap_Impl_.set = function(this1,k,v) 
  local _this = this1.keys;
  local key = k:hashCode();
  if (k == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = k;
  end;
  local _this = this1.values;
  local key = k:hashCode();
  if (v == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = v;
  end;
end
__haxe_ds__HashMap_HashMap_Impl_.get = function(this1,k) 
  local _this = this1.values;
  local key = k:hashCode();
  local ret = _this.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end;
end
__haxe_ds__HashMap_HashMap_Impl_.exists = function(this1,k) 
  local _this = this1.values;
  local key = k:hashCode();
  do return _this.h[key] ~= nil end;
end
__haxe_ds__HashMap_HashMap_Impl_.remove = function(this1,k) 
  this1.values:remove(k:hashCode());
  do return this1.keys:remove(k:hashCode()) end;
end
__haxe_ds__HashMap_HashMap_Impl_.keys = function(this1) 
  do return this1.keys:iterator() end;
end
__haxe_ds__HashMap_HashMap_Impl_.copy = function(this1) 
  local copied = __haxe_ds__HashMap_HashMapData.new();
  copied.keys = this1.keys:copy();
  copied.values = this1.values:copy();
  do return copied end;
end
__haxe_ds__HashMap_HashMap_Impl_.iterator = function(this1) 
  do return this1.values:iterator() end;
end
__haxe_ds__HashMap_HashMap_Impl_.keyValueIterator = function(this1) 
  do return __haxe_iterators_HashMapKeyValueIterator.new(this1) end;
end
__haxe_ds__HashMap_HashMap_Impl_.clear = function(this1) 
  this1.keys.h = ({});
  this1.values.h = ({});
end

__haxe_ds__HashMap_HashMapData.new = function() 
  local self = _hx_new(__haxe_ds__HashMap_HashMapData.prototype)
  __haxe_ds__HashMap_HashMapData.super(self)
  return self
end
__haxe_ds__HashMap_HashMapData.super = function(self) 
  self.keys = __haxe_ds_IntMap.new();
  self.values = __haxe_ds_IntMap.new();
end
_hxClasses["haxe.ds._HashMap.HashMapData"] = __haxe_ds__HashMap_HashMapData
__haxe_ds__HashMap_HashMapData.__name__ = "haxe.ds._HashMap.HashMapData"
__haxe_ds__HashMap_HashMapData.prototype = _hx_e();
__haxe_ds__HashMap_HashMapData.prototype.keys= nil;
__haxe_ds__HashMap_HashMapData.prototype.values= nil;

__haxe_ds__HashMap_HashMapData.prototype.__class__ =  __haxe_ds__HashMap_HashMapData

__haxe_ds_IntMap.new = function() 
  local self = _hx_new(__haxe_ds_IntMap.prototype)
  __haxe_ds_IntMap.super(self)
  return self
end
__haxe_ds_IntMap.super = function(self) 
  self.h = ({});
end
_hxClasses["haxe.ds.IntMap"] = __haxe_ds_IntMap
__haxe_ds_IntMap.__name__ = "haxe.ds.IntMap"
__haxe_ds_IntMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_IntMap.prototype = _hx_e();
__haxe_ds_IntMap.prototype.h= nil;
__haxe_ds_IntMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_IntMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_IntMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_IntMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_IntMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_IntMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_IntMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end
__haxe_ds_IntMap.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_IntMap.prototype.copy = function(self) 
  local copied = __haxe_ds_IntMap.new();
  local key = self:keys();
  while (key:hasNext()) do 
    local key = key:next();
    local ret = self.h[key];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local value = ret;
    if (value == nil) then 
      copied.h[key] = __haxe_ds_IntMap.tnull;
    else
      copied.h[key] = value;
    end;
  end;
  do return copied end
end
__haxe_ds_IntMap.prototype.toString = function(self) 
  local s_b = ({});
  local s_length = 0;
  local str = "{";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  local it = self:keys();
  local i = it;
  while (i:hasNext()) do 
    local i = i:next();
    local str = Std.string(i);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    local str = " => ";
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    local ret = self.h[i];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local str = Std.string(ret);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    if (it:hasNext()) then 
      local str = ", ";
      _G.table.insert(s_b, str);
      s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    end;
  end;
  local str = "}";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(s_b) end
end
__haxe_ds_IntMap.prototype.clear = function(self) 
  self.h = ({});
end

__haxe_ds_IntMap.prototype.__class__ =  __haxe_ds_IntMap

__haxe_ds_List.new = function() 
  local self = _hx_new(__haxe_ds_List.prototype)
  __haxe_ds_List.super(self)
  return self
end
__haxe_ds_List.super = function(self) 
  self.length = 0;
end
_hxClasses["haxe.ds.List"] = __haxe_ds_List
__haxe_ds_List.__name__ = "haxe.ds.List"
__haxe_ds_List.prototype = _hx_e();
__haxe_ds_List.prototype.h= nil;
__haxe_ds_List.prototype.q= nil;
__haxe_ds_List.prototype.length= nil;
__haxe_ds_List.prototype.add = function(self,item) 
  local next = nil;
  local x = __haxe_ds__List_ListNode.new(item, next);
  if (self.h == nil) then 
    self.h = x;
  else
    self.q.next = x;
  end;
  self.q = x;
  self.length = self.length + 1;
end
__haxe_ds_List.prototype.push = function(self,item) 
  local x = __haxe_ds__List_ListNode.new(item, self.h);
  self.h = x;
  if (self.q == nil) then 
    self.q = x;
  end;
  self.length = self.length + 1;
end
__haxe_ds_List.prototype.first = function(self) 
  if (self.h == nil) then 
    do return nil end;
  else
    do return self.h.item end;
  end;
end
__haxe_ds_List.prototype.last = function(self) 
  if (self.q == nil) then 
    do return nil end;
  else
    do return self.q.item end;
  end;
end
__haxe_ds_List.prototype.pop = function(self) 
  if (self.h == nil) then 
    do return nil end;
  end;
  local x = self.h.item;
  self.h = self.h.next;
  if (self.h == nil) then 
    self.q = nil;
  end;
  self.length = self.length - 1;
  do return x end
end
__haxe_ds_List.prototype.isEmpty = function(self) 
  do return self.h == nil end
end
__haxe_ds_List.prototype.clear = function(self) 
  self.h = nil;
  self.q = nil;
  self.length = 0;
end
__haxe_ds_List.prototype.remove = function(self,v) 
  local prev = nil;
  local l = self.h;
  while (l ~= nil) do 
    if (l.item == v) then 
      if (prev == nil) then 
        self.h = l.next;
      else
        prev.next = l.next;
      end;
      if (self.q == l) then 
        self.q = prev;
      end;
      self.length = self.length - 1;
      do return true end;
    end;
    prev = l;
    l = l.next;
  end;
  do return false end
end
__haxe_ds_List.prototype.iterator = function(self) 
  do return __haxe_ds__List_ListIterator.new(self.h) end
end
__haxe_ds_List.prototype.keyValueIterator = function(self) 
  do return __haxe_ds__List_ListKeyValueIterator.new(self.h) end
end
__haxe_ds_List.prototype.toString = function(self) 
  local s_b = ({});
  local s_length = 0;
  local first = true;
  local l = self.h;
  local str = "{";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  while (l ~= nil) do 
    if (first) then 
      first = false;
    else
      local str = ", ";
      _G.table.insert(s_b, str);
      s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local str = Std.string(l.item);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    l = l.next;
  end;
  local str = "}";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(s_b) end
end
__haxe_ds_List.prototype.join = function(self,sep) 
  local s_b = ({});
  local s_length = 0;
  local first = true;
  local l = self.h;
  while (l ~= nil) do 
    if (first) then 
      first = false;
    else
      local str = Std.string(sep);
      _G.table.insert(s_b, str);
      s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local str = Std.string(l.item);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    l = l.next;
  end;
  do return _G.table.concat(s_b) end
end
__haxe_ds_List.prototype.filter = function(self,f) 
  local l2 = __haxe_ds_List.new();
  local l = self.h;
  while (l ~= nil) do 
    local v = l.item;
    l = l.next;
    if (f(v)) then 
      l2:add(v);
    end;
  end;
  do return l2 end
end
__haxe_ds_List.prototype.map = function(self,f) 
  local b = __haxe_ds_List.new();
  local l = self.h;
  while (l ~= nil) do 
    local v = l.item;
    l = l.next;
    b:add(f(v));
  end;
  do return b end
end

__haxe_ds_List.prototype.__class__ =  __haxe_ds_List

__haxe_ds__List_ListNode.new = function(item,next) 
  local self = _hx_new(__haxe_ds__List_ListNode.prototype)
  __haxe_ds__List_ListNode.super(self,item,next)
  return self
end
__haxe_ds__List_ListNode.super = function(self,item,next) 
  self.item = item;
  self.next = next;
end
_hxClasses["haxe.ds._List.ListNode"] = __haxe_ds__List_ListNode
__haxe_ds__List_ListNode.__name__ = "haxe.ds._List.ListNode"
__haxe_ds__List_ListNode.prototype = _hx_e();
__haxe_ds__List_ListNode.prototype.item= nil;
__haxe_ds__List_ListNode.prototype.next= nil;

__haxe_ds__List_ListNode.prototype.__class__ =  __haxe_ds__List_ListNode

__haxe_ds__List_ListIterator.new = function(head) 
  local self = _hx_new(__haxe_ds__List_ListIterator.prototype)
  __haxe_ds__List_ListIterator.super(self,head)
  return self
end
__haxe_ds__List_ListIterator.super = function(self,head) 
  self.head = head;
end
_hxClasses["haxe.ds._List.ListIterator"] = __haxe_ds__List_ListIterator
__haxe_ds__List_ListIterator.__name__ = "haxe.ds._List.ListIterator"
__haxe_ds__List_ListIterator.prototype = _hx_e();
__haxe_ds__List_ListIterator.prototype.head= nil;
__haxe_ds__List_ListIterator.prototype.hasNext = function(self) 
  do return self.head ~= nil end
end
__haxe_ds__List_ListIterator.prototype.next = function(self) 
  local val = self.head.item;
  self.head = self.head.next;
  do return val end
end

__haxe_ds__List_ListIterator.prototype.__class__ =  __haxe_ds__List_ListIterator

__haxe_ds__List_ListKeyValueIterator.new = function(head) 
  local self = _hx_new(__haxe_ds__List_ListKeyValueIterator.prototype)
  __haxe_ds__List_ListKeyValueIterator.super(self,head)
  return self
end
__haxe_ds__List_ListKeyValueIterator.super = function(self,head) 
  self.head = head;
  self.idx = 0;
end
_hxClasses["haxe.ds._List.ListKeyValueIterator"] = __haxe_ds__List_ListKeyValueIterator
__haxe_ds__List_ListKeyValueIterator.__name__ = "haxe.ds._List.ListKeyValueIterator"
__haxe_ds__List_ListKeyValueIterator.prototype = _hx_e();
__haxe_ds__List_ListKeyValueIterator.prototype.idx= nil;
__haxe_ds__List_ListKeyValueIterator.prototype.head= nil;
__haxe_ds__List_ListKeyValueIterator.prototype.hasNext = function(self) 
  do return self.head ~= nil end
end
__haxe_ds__List_ListKeyValueIterator.prototype.next = function(self) 
  local val = self.head.item;
  self.head = self.head.next;
  do return _hx_o({__fields__={value=true,key=true},value=val,key=(function() 
  local _hx_obj = self;
  local _hx_fld = 'idx';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()}) end
end

__haxe_ds__List_ListKeyValueIterator.prototype.__class__ =  __haxe_ds__List_ListKeyValueIterator

__haxe_ds_ObjectMap.new = function() 
  local self = _hx_new(__haxe_ds_ObjectMap.prototype)
  __haxe_ds_ObjectMap.super(self)
  return self
end
__haxe_ds_ObjectMap.super = function(self) 
  self.h = ({});
  self.k = ({});
end
_hxClasses["haxe.ds.ObjectMap"] = __haxe_ds_ObjectMap
__haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap"
__haxe_ds_ObjectMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_ObjectMap.assignId = function(obj) 
  obj.__id__ = (function() 
  local _hx_obj = __haxe_ds_ObjectMap;
  local _hx_fld = 'count';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)() do return obj.__id__ end;
end
__haxe_ds_ObjectMap.getId = function(obj) 
  do return obj.__id__ end;
end
__haxe_ds_ObjectMap.prototype = _hx_e();
__haxe_ds_ObjectMap.prototype.h= nil;
__haxe_ds_ObjectMap.prototype.k= nil;
__haxe_ds_ObjectMap.prototype.set = function(self,key,value) 
  self.h[key] = value;
  self.k[key] = true;
end
__haxe_ds_ObjectMap.prototype.get = function(self,key) 
  do return self.h[key] end
end
__haxe_ds_ObjectMap.prototype.exists = function(self,key) 
  do return self.k[key] ~= nil end
end
__haxe_ds_ObjectMap.prototype.remove = function(self,key) 
  if (self.k[key] == nil) then 
    do return false end;
  end;
  self.k[key] = nil;
  self.h[key] = nil;
  do return true end
end
__haxe_ds_ObjectMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.k, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.iterator = function(self) 
  local _gthis = self;
  local itr = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end,next=function(self) 
    do return _gthis.h[itr:next()] end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_ObjectMap.prototype.copy = function(self) 
  local copied = __haxe_ds_ObjectMap.new();
  local key = self:keys();
  while (key:hasNext()) do 
    local key = key:next();
    copied.h[key] = self.h[key];
    copied.k[key] = true;
  end;
  do return copied end
end
__haxe_ds_ObjectMap.prototype.toString = function(self) 
  local s_b = ({});
  local s_length = 0;
  local str = "{";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  local it = self:keys();
  local i = it;
  while (i:hasNext()) do 
    local i = i:next();
    local str = Std.string(i);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    local str = " => ";
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    local str = Std.string(self.h[i]);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    if (it:hasNext()) then 
      local str = ", ";
      _G.table.insert(s_b, str);
      s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    end;
  end;
  local str = "}";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(s_b) end
end
__haxe_ds_ObjectMap.prototype.clear = function(self) 
  self.h = ({});
  self.k = ({});
end

__haxe_ds_ObjectMap.prototype.__class__ =  __haxe_ds_ObjectMap

__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.new = {}
_hxClasses["haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_"] = __haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.__name__ = "haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_"
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.__properties__ = {get_length="get_length"}
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.get_length = function(this1) 
  do return this1.length end;
end
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.get = function(this1,i) 
  do return this1[i] end;
end

__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
_hxClasses["haxe.ds.StringMap"] = __haxe_ds_StringMap
__haxe_ds_StringMap.__name__ = "haxe.ds.StringMap"
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.h= nil;
__haxe_ds_StringMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_StringMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_StringMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_StringMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end
__haxe_ds_StringMap.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_StringMap.prototype.copy = function(self) 
  local copied = __haxe_ds_StringMap.new();
  local key = self:keys();
  while (key:hasNext()) do 
    local key = key:next();
    local ret = self.h[key];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local value = ret;
    if (value == nil) then 
      copied.h[key] = __haxe_ds_StringMap.tnull;
    else
      copied.h[key] = value;
    end;
  end;
  do return copied end
end
__haxe_ds_StringMap.prototype.toString = function(self) 
  local s_b = ({});
  local s_length = 0;
  local str = "{";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  local it = self:keys();
  local i = it;
  while (i:hasNext()) do 
    local i = i:next();
    local str = Std.string(i);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    local str = " => ";
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    local ret = self.h[i];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local str = Std.string(ret);
    _G.table.insert(s_b, str);
    s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    if (it:hasNext()) then 
      local str = ", ";
      _G.table.insert(s_b, str);
      s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
    end;
  end;
  local str = "}";
  _G.table.insert(s_b, str);
  s_length = s_length + __lua_lib_luautf8_Utf8.len(str);
  do return _G.table.concat(s_b) end
end
__haxe_ds_StringMap.prototype.clear = function(self) 
  self.h = ({});
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_ds_WeakMap.new = function() 
  local self = _hx_new(__haxe_ds_WeakMap.prototype)
  __haxe_ds_WeakMap.super(self)
  return self
end
__haxe_ds_WeakMap.super = function(self) 
  _G.error(__haxe_Exception.thrown("Not implemented for this platform"),0);
end
_hxClasses["haxe.ds.WeakMap"] = __haxe_ds_WeakMap
__haxe_ds_WeakMap.__name__ = "haxe.ds.WeakMap"
__haxe_ds_WeakMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_WeakMap.prototype = _hx_e();
__haxe_ds_WeakMap.prototype.set = function(self,key,value) 
end
__haxe_ds_WeakMap.prototype.get = function(self,key) 
  do return nil end
end
__haxe_ds_WeakMap.prototype.exists = function(self,key) 
  do return false end
end
__haxe_ds_WeakMap.prototype.remove = function(self,key) 
  do return false end
end
__haxe_ds_WeakMap.prototype.keys = function(self) 
  do return nil end
end
__haxe_ds_WeakMap.prototype.iterator = function(self) 
  do return nil end
end
__haxe_ds_WeakMap.prototype.keyValueIterator = function(self) 
  do return nil end
end
__haxe_ds_WeakMap.prototype.copy = function(self) 
  do return nil end
end
__haxe_ds_WeakMap.prototype.toString = function(self) 
  do return nil end
end
__haxe_ds_WeakMap.prototype.clear = function(self) 
end

__haxe_ds_WeakMap.prototype.__class__ =  __haxe_ds_WeakMap

__haxe_io_BytesBuffer.new = function() 
  local self = _hx_new(__haxe_io_BytesBuffer.prototype)
  __haxe_io_BytesBuffer.super(self)
  return self
end
__haxe_io_BytesBuffer.super = function(self) 
  self.b = Array.new();
end
_hxClasses["haxe.io.BytesBuffer"] = __haxe_io_BytesBuffer
__haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer"
__haxe_io_BytesBuffer.prototype = _hx_e();
__haxe_io_BytesBuffer.prototype.b= nil;
__haxe_io_BytesBuffer.prototype.get_length = function(self) 
  do return self.b.length end
end
__haxe_io_BytesBuffer.prototype.addByte = function(self,byte) 
  self.b:push(byte);
end
__haxe_io_BytesBuffer.prototype.add = function(self,src) 
  local b1 = self.b;
  local b2 = src.b;
  local _g = 0;
  local _g1 = src.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self.b:push(b2[i]);
  end;
end
__haxe_io_BytesBuffer.prototype.addString = function(self,v,encoding) 
  local src = __haxe_io_Bytes.ofString(v, encoding);
  local b1 = self.b;
  local b2 = src.b;
  local _g = 0;
  local _g1 = src.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self.b:push(b2[i]);
  end;
end
__haxe_io_BytesBuffer.prototype.addInt32 = function(self,v) 
  self.b:push(_hx_bit.band(v,255));
  self.b:push(_hx_bit.band(_hx_bit.arshift(v,8),255));
  self.b:push(_hx_bit.band(_hx_bit.arshift(v,16),255));
  self.b:push(_hx_bit.rshift(v,24));
end
__haxe_io_BytesBuffer.prototype.addInt64 = function(self,v) 
  self:addInt32(v.low);
  self:addInt32(v.high);
end
__haxe_io_BytesBuffer.prototype.addFloat = function(self,v) 
  self:addInt32(__haxe_io_FPHelper.floatToI32(v));
end
__haxe_io_BytesBuffer.prototype.addDouble = function(self,v) 
  self:addInt64(__haxe_io_FPHelper.doubleToI64(v));
end
__haxe_io_BytesBuffer.prototype.addBytes = function(self,src,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > src.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  local b1 = self.b;
  local b2 = src.b;
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self.b:push(b2[i]);
  end;
end
__haxe_io_BytesBuffer.prototype.getBytes = function(self) 
  local bytes = __haxe_io_Bytes.new(self.b.length, self.b);
  self.b = nil;
  do return bytes end
end

__haxe_io_BytesBuffer.prototype.__class__ =  __haxe_io_BytesBuffer

__haxe_io_BytesBuffer.prototype.__properties__ =  {get_length="get_length"}
_hxClasses["haxe.io.Encoding"] = __haxe_io_Encoding;
_hxClasses["haxe.io.Encoding"] = { __ename__ = "haxe.io.Encoding", __constructs__ = _hx_tab_array({[0]="UTF8","RawNative"},2)}
__haxe_io_Encoding = _hxClasses["haxe.io.Encoding"];
__haxe_io_Encoding.UTF8 = _hx_tab_array({[0]="UTF8",0,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.RawNative = _hx_tab_array({[0]="RawNative",1,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.__empty_constructs__ = _hx_tab_array({[0] = __haxe_io_Encoding.UTF8,__haxe_io_Encoding.RawNative}, 2)

__haxe_io_Eof.new = function() 
  local self = _hx_new(__haxe_io_Eof.prototype)
  __haxe_io_Eof.super(self)
  return self
end
__haxe_io_Eof.super = function(self) 
end
_hxClasses["haxe.io.Eof"] = __haxe_io_Eof
__haxe_io_Eof.__name__ = "haxe.io.Eof"
__haxe_io_Eof.prototype = _hx_e();
__haxe_io_Eof.prototype.toString = function(self) 
  do return "Eof" end
end

__haxe_io_Eof.prototype.__class__ =  __haxe_io_Eof
_hxClasses["haxe.io.Error"] = __haxe_io_Error;
_hxClasses["haxe.io.Error"] = { __ename__ = "haxe.io.Error", __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
__haxe_io_Error = _hxClasses["haxe.io.Error"];
__haxe_io_Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=__haxe_io_Error}, 3); return _x; end 
__haxe_io_Error.__empty_constructs__ = _hx_tab_array({[0] = __haxe_io_Error.Blocked,__haxe_io_Error.Overflow,__haxe_io_Error.OutsideBounds}, 3)

__haxe_io_FPHelper.new = {}
_hxClasses["haxe.io.FPHelper"] = __haxe_io_FPHelper
__haxe_io_FPHelper.__name__ = "haxe.io.FPHelper"
__haxe_io_FPHelper._i32ToFloat = function(i) 
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(i,31),1));
  local e = _hx_bit.band(_hx_bit.arshift(i,23),255);
  if (e == 255) then 
    if ((_hx_bit.band(i,8388607)) == 0) then 
      if (sign > 0) then 
        do return _G.math.huge end;
      else
        do return -_G.math.huge end;
      end;
    else
      do return (0/0) end;
    end;
  end;
  local m = (function() 
    local _hx_1
    if (e == 0) then 
    _hx_1 = _hx_bit.lshift((_hx_bit.band(i,8388607)),1); else 
    _hx_1 = _hx_bit.bor(_hx_bit.band(i,8388607),8388608); end
    return _hx_1
  end )();
  do return (sign * m) * _G.math.pow(2, e - 150) end;
end
__haxe_io_FPHelper._i64ToDouble = function(lo,hi) 
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(hi,31),1));
  local e = _hx_bit.band(_hx_bit.arshift(hi,20),2047);
  if (e == 2047) then 
    if ((lo == 0) and ((_hx_bit.band(hi,1048575)) == 0)) then 
      if (sign > 0) then 
        do return _G.math.huge end;
      else
        do return -_G.math.huge end;
      end;
    else
      do return (0/0) end;
    end;
  end;
  local m = 2.220446049250313e-16 * ((((_hx_bit.band(hi,1048575)) * 4294967296.) + ((_hx_bit.rshift(lo,31)) * 2147483648.)) + (_hx_bit.band(lo,2147483647)));
  m = (function() 
    local _hx_1
    if (e == 0) then 
    _hx_1 = m * 2.0; else 
    _hx_1 = m + 1.0; end
    return _hx_1
  end )();
  do return (sign * m) * _G.math.pow(2, e - 1023) end;
end
__haxe_io_FPHelper._floatToI32 = function(f) 
  if (f == 0) then 
    do return 0 end;
  end;
  local af = (function() 
    local _hx_1
    if (f < 0) then 
    _hx_1 = -f; else 
    _hx_1 = f; end
    return _hx_1
  end )();
  local exp = _G.math.floor(_G.math.log(af) / 0.6931471805599453);
  if (exp > 127) then 
    do return 2139095040 end;
  else
    if (exp <= -127) then 
      exp = -127;
      af = af * 7.1362384635298e+44;
    else
      af = ((af / _G.math.pow(2, exp)) - 1.0) * 8388608;
    end;
    do return _hx_bit.bor(_hx_bit.bor(((function() 
      local _hx_2
      if (f < 0) then 
      _hx_2 = -2147483648; else 
      _hx_2 = 0; end
      return _hx_2
    end )()),_hx_bit.lshift(exp + 127,23)),_G.math.floor(af + 0.5)) end;
  end;
end
__haxe_io_FPHelper._doubleToI64 = function(v) 
  local i64 = __haxe_io_FPHelper.i64tmp;
  if (v == 0) then 
    i64.low = 0;
    i64.high = 0;
  else
    if (not Math.isFinite(v)) then 
      i64.low = 0;
      i64.high = (function() 
        local _hx_1
        if (v > 0) then 
        _hx_1 = 2146435072; else 
        _hx_1 = -1048576; end
        return _hx_1
      end )();
    else
      local av = (function() 
        local _hx_2
        if (v < 0) then 
        _hx_2 = -v; else 
        _hx_2 = v; end
        return _hx_2
      end )();
      local exp = _G.math.floor(_G.math.log(av) / 0.6931471805599453);
      if (exp > 1023) then 
        i64.low = -1;
        i64.high = 2146435071;
      else
        if (exp <= -1023) then 
          exp = -1023;
          av = av / 2.2250738585072014e-308;
        else
          av = (av / _G.math.pow(2, exp)) - 1.0;
        end;
        local sig = _G.math.floor((av * 4503599627370496.) + 0.5);
        local sig_l = Std.int(sig);
        local sig_h = Std.int(sig / 4294967296.0);
        i64.low = sig_l;
        i64.high = _hx_bit.bor(_hx_bit.bor(((function() 
          local _hx_3
          if (v < 0) then 
          _hx_3 = -2147483648; else 
          _hx_3 = 0; end
          return _hx_3
        end )()),_hx_bit.lshift(exp + 1023,20)),sig_h);
      end;
    end;
  end;
  do return i64 end;
end
__haxe_io_FPHelper.i32ToFloat = function(i) 
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(i,31),1));
  local e = _hx_bit.band(_hx_bit.arshift(i,23),255);
  if (e == 255) then 
    if ((_hx_bit.band(i,8388607)) == 0) then 
      if (sign > 0) then 
        do return _G.math.huge end;
      else
        do return -_G.math.huge end;
      end;
    else
      do return (0/0) end;
    end;
  else
    local m = (function() 
      local _hx_1
      if (e == 0) then 
      _hx_1 = _hx_bit.lshift((_hx_bit.band(i,8388607)),1); else 
      _hx_1 = _hx_bit.bor(_hx_bit.band(i,8388607),8388608); end
      return _hx_1
    end )();
    do return (sign * m) * _G.math.pow(2, e - 150) end;
  end;
end
__haxe_io_FPHelper.floatToI32 = function(f) 
  if (f == 0) then 
    do return 0 end;
  else
    local af = (function() 
      local _hx_1
      if (f < 0) then 
      _hx_1 = -f; else 
      _hx_1 = f; end
      return _hx_1
    end )();
    local exp = _G.math.floor(_G.math.log(af) / 0.6931471805599453);
    if (exp > 127) then 
      do return 2139095040 end;
    else
      if (exp <= -127) then 
        exp = -127;
        af = af * 7.1362384635298e+44;
      else
        af = ((af / _G.math.pow(2, exp)) - 1.0) * 8388608;
      end;
      do return _hx_bit.bor(_hx_bit.bor(((function() 
        local _hx_2
        if (f < 0) then 
        _hx_2 = -2147483648; else 
        _hx_2 = 0; end
        return _hx_2
      end )()),_hx_bit.lshift(exp + 127,23)),_G.math.floor(af + 0.5)) end;
    end;
  end;
end
__haxe_io_FPHelper.i64ToDouble = function(low,high) 
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(high,31),1));
  local e = _hx_bit.band(_hx_bit.arshift(high,20),2047);
  if (e == 2047) then 
    if ((low == 0) and ((_hx_bit.band(high,1048575)) == 0)) then 
      if (sign > 0) then 
        do return _G.math.huge end;
      else
        do return -_G.math.huge end;
      end;
    else
      do return (0/0) end;
    end;
  else
    local m = 2.220446049250313e-16 * ((((_hx_bit.band(high,1048575)) * 4294967296.) + ((_hx_bit.rshift(low,31)) * 2147483648.)) + (_hx_bit.band(low,2147483647)));
    m = (function() 
      local _hx_1
      if (e == 0) then 
      _hx_1 = m * 2.0; else 
      _hx_1 = m + 1.0; end
      return _hx_1
    end )();
    do return (sign * m) * _G.math.pow(2, e - 1023) end;
  end;
end
__haxe_io_FPHelper.doubleToI64 = function(v) 
  local i64 = __haxe_io_FPHelper.i64tmp;
  if (v == 0) then 
    i64.low = 0;
    i64.high = 0;
  else
    if (not Math.isFinite(v)) then 
      i64.low = 0;
      i64.high = (function() 
        local _hx_1
        if (v > 0) then 
        _hx_1 = 2146435072; else 
        _hx_1 = -1048576; end
        return _hx_1
      end )();
    else
      local av = (function() 
        local _hx_2
        if (v < 0) then 
        _hx_2 = -v; else 
        _hx_2 = v; end
        return _hx_2
      end )();
      local exp = _G.math.floor(_G.math.log(av) / 0.6931471805599453);
      if (exp > 1023) then 
        i64.low = -1;
        i64.high = 2146435071;
      else
        if (exp <= -1023) then 
          exp = -1023;
          av = av / 2.2250738585072014e-308;
        else
          av = (av / _G.math.pow(2, exp)) - 1.0;
        end;
        local sig = _G.math.floor((av * 4503599627370496.) + 0.5);
        local sig_l = Std.int(sig);
        local sig_h = Std.int(sig / 4294967296.0);
        i64.low = sig_l;
        i64.high = _hx_bit.bor(_hx_bit.bor(((function() 
          local _hx_3
          if (v < 0) then 
          _hx_3 = -2147483648; else 
          _hx_3 = 0; end
          return _hx_3
        end )()),_hx_bit.lshift(exp + 1023,20)),sig_h);
      end;
    end;
  end;
  do return i64 end;
end

__haxe_io_Input.new = {}
_hxClasses["haxe.io.Input"] = __haxe_io_Input
__haxe_io_Input.__name__ = "haxe.io.Input"
__haxe_io_Input.prototype = _hx_e();
__haxe_io_Input.prototype.bigEndian= nil;
__haxe_io_Input.prototype.readByte = function(self) 
  _G.error(__haxe_Exception.thrown("Not implemented"),0);
end
__haxe_io_Input.prototype.readBytes = function(self,s,pos,len) 
  local k = len;
  local b = s.b;
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      while (k > 0) do 
        b[pos] = self:readByte();
        pos = pos + 1;
        k = k - 1;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (not __lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), __haxe_io_Eof)) then 
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return len - k end
end
__haxe_io_Input.prototype.close = function(self) 
end
__haxe_io_Input.prototype.set_bigEndian = function(self,b) 
  self.bigEndian = b;
  do return b end
end
__haxe_io_Input.prototype.readAll = function(self,bufsize) 
  if (bufsize == nil) then 
    bufsize = 16384;
  end;
  local buf = __haxe_io_Bytes.alloc(bufsize);
  local total = __haxe_io_BytesBuffer.new();
  local _hx_status, _hx_result = pcall(function() 
  
      while (true) do 
        local len = self:readBytes(buf, 0, bufsize);
        if (len == 0) then 
          _G.error(__haxe_Exception.thrown(__haxe_io_Error.Blocked),0);
        end;
        if ((len < 0) or (len > buf.length)) then 
          _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
        end;
        local b1 = total.b;
        local b2 = buf.b;
        local _g = 0;
        local _g1 = len;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          total.b:push(b2[i]);
        end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (not __lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), __haxe_io_Eof)) then 
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return total:getBytes() end
end
__haxe_io_Input.prototype.readFullBytes = function(self,s,pos,len) 
  while (len > 0) do 
    local k = self:readBytes(s, pos, len);
    if (k == 0) then 
      _G.error(__haxe_Exception.thrown(__haxe_io_Error.Blocked),0);
    end;
    pos = pos + k;
    len = len - k;
  end;
end
__haxe_io_Input.prototype.read = function(self,nbytes) 
  local s = __haxe_io_Bytes.alloc(nbytes);
  local p = 0;
  while (nbytes > 0) do 
    local k = self:readBytes(s, p, nbytes);
    if (k == 0) then 
      _G.error(__haxe_Exception.thrown(__haxe_io_Error.Blocked),0);
    end;
    p = p + k;
    nbytes = nbytes - k;
  end;
  do return s end
end
__haxe_io_Input.prototype.readUntil = function(self,_end) 
  local buf = __haxe_io_BytesBuffer.new();
  local last;
  while (true) do 
    last = self:readByte();
    if (not (last ~= _end)) then 
      break;
    end;
    buf.b:push(last);
  end;
  do return buf:getBytes():toString() end
end
__haxe_io_Input.prototype.readLine = function(self) 
  local buf = __haxe_io_BytesBuffer.new();
  local last;
  local s;
  local _hx_status, _hx_result = pcall(function() 
  
      while (true) do 
        last = self:readByte();
        if (not (last ~= 10)) then 
          break;
        end;
        buf.b:push(last);
      end;
      s = buf:getBytes():toString();
      if (__lua_lib_luautf8_Utf8.byte(s, (__lua_lib_luautf8_Utf8.len(s) - 1) + 1) == 13) then 
        local pos = 0;
        local len = -1;
        if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
          len = __lua_lib_luautf8_Utf8.len(s);
        else
          if (len < 0) then 
            len = __lua_lib_luautf8_Utf8.len(s) + len;
          end;
        end;
        if (pos < 0) then 
          pos = __lua_lib_luautf8_Utf8.len(s) + pos;
        end;
        if (pos < 0) then 
          pos = 0;
        end;
        s = __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len);
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    local _g1 = __haxe_Exception.caught(_g):unwrap();
    if (__lua_Boot.__instanceof(_g1, __haxe_io_Eof)) then 
      local e = _g1;
      s = buf:getBytes():toString();
      if (__lua_lib_luautf8_Utf8.len(s) == 0) then 
        _G.error(__haxe_Exception.thrown(e),0);
      end;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return s end
end
__haxe_io_Input.prototype.readFloat = function(self) 
  do return __haxe_io_FPHelper.i32ToFloat(self:readInt32()) end
end
__haxe_io_Input.prototype.readDouble = function(self) 
  local i1 = self:readInt32();
  local i2 = self:readInt32();
  if (self.bigEndian) then 
    do return __haxe_io_FPHelper.i64ToDouble(i2, i1) end;
  else
    do return __haxe_io_FPHelper.i64ToDouble(i1, i2) end;
  end;
end
__haxe_io_Input.prototype.readInt8 = function(self) 
  local n = self:readByte();
  if (n >= 128) then 
    do return n - 256 end;
  end;
  do return n end
end
__haxe_io_Input.prototype.readInt16 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  local n = (function() 
    local _hx_1
    if (self.bigEndian) then 
    _hx_1 = _hx_bit.bor(ch2,_hx_bit.lshift(ch1,8)); else 
    _hx_1 = _hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)); end
    return _hx_1
  end )();
  if ((_hx_bit.band(n,32768)) ~= 0) then 
    do return n - 65536 end;
  end;
  do return n end
end
__haxe_io_Input.prototype.readUInt16 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  if (self.bigEndian) then 
    do return _hx_bit.bor(ch2,_hx_bit.lshift(ch1,8)) end;
  else
    do return _hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)) end;
  end;
end
__haxe_io_Input.prototype.readInt24 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  local ch3 = self:readByte();
  local n = (function() 
    local _hx_1
    if (self.bigEndian) then 
    _hx_1 = _hx_bit.bor(_hx_bit.bor(ch3,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch1,16)); else 
    _hx_1 = _hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)); end
    return _hx_1
  end )();
  if ((_hx_bit.band(n,8388608)) ~= 0) then 
    do return n - 16777216 end;
  end;
  do return n end
end
__haxe_io_Input.prototype.readUInt24 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  local ch3 = self:readByte();
  if (self.bigEndian) then 
    do return _hx_bit.bor(_hx_bit.bor(ch3,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch1,16)) end;
  else
    do return _hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)) end;
  end;
end
__haxe_io_Input.prototype.readInt32 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  local ch3 = self:readByte();
  local ch4 = self:readByte();
  local n = (function() 
    local _hx_1
    if (self.bigEndian) then 
    _hx_1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(ch4,_hx_bit.lshift(ch3,8)),_hx_bit.lshift(ch2,16)),_hx_bit.lshift(ch1,24)); else 
    _hx_1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)),_hx_bit.lshift(ch4,24)); end
    return _hx_1
  end )();
  do return _hx_bit_clamp(n) end
end
__haxe_io_Input.prototype.readString = function(self,len,encoding) 
  local b = __haxe_io_Bytes.alloc(len);
  self:readFullBytes(b, 0, len);
  do return b:getString(0, len, encoding) end
end

__haxe_io_Input.prototype.__class__ =  __haxe_io_Input

__haxe_io_Input.prototype.__properties__ =  {set_bigEndian="set_bigEndian"}

__haxe_io_Output.new = {}
_hxClasses["haxe.io.Output"] = __haxe_io_Output
__haxe_io_Output.__name__ = "haxe.io.Output"
__haxe_io_Output.prototype = _hx_e();
__haxe_io_Output.prototype.bigEndian= nil;
__haxe_io_Output.prototype.writeByte = function(self,c) 
  _G.error(__haxe_Exception.thrown("Not implemented"),0);
end
__haxe_io_Output.prototype.writeBytes = function(self,s,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  local b = s.b;
  local k = len;
  while (k > 0) do 
    self:writeByte(b[pos]);
    pos = pos + 1;
    k = k - 1;
  end;
  do return len end
end
__haxe_io_Output.prototype.flush = function(self) 
end
__haxe_io_Output.prototype.close = function(self) 
end
__haxe_io_Output.prototype.set_bigEndian = function(self,b) 
  self.bigEndian = b;
  do return b end
end
__haxe_io_Output.prototype.write = function(self,s) 
  local l = s.length;
  local p = 0;
  while (l > 0) do 
    local k = self:writeBytes(s, p, l);
    if (k == 0) then 
      _G.error(__haxe_Exception.thrown(__haxe_io_Error.Blocked),0);
    end;
    p = p + k;
    l = l - k;
  end;
end
__haxe_io_Output.prototype.writeFullBytes = function(self,s,pos,len) 
  while (len > 0) do 
    local k = self:writeBytes(s, pos, len);
    pos = pos + k;
    len = len - k;
  end;
end
__haxe_io_Output.prototype.writeFloat = function(self,x) 
  self:writeInt32(__haxe_io_FPHelper.floatToI32(x));
end
__haxe_io_Output.prototype.writeDouble = function(self,x) 
  local i64 = __haxe_io_FPHelper.doubleToI64(x);
  if (self.bigEndian) then 
    self:writeInt32(i64.high);
    self:writeInt32(i64.low);
  else
    self:writeInt32(i64.low);
    self:writeInt32(i64.high);
  end;
end
__haxe_io_Output.prototype.writeInt8 = function(self,x) 
  if ((x < -128) or (x >= 128)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.Overflow),0);
  end;
  self:writeByte(_hx_bit.band(x,255));
end
__haxe_io_Output.prototype.writeInt16 = function(self,x) 
  if ((x < -32768) or (x >= 32768)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.Overflow),0);
  end;
  self:writeUInt16(_hx_bit.band(x,65535));
end
__haxe_io_Output.prototype.writeUInt16 = function(self,x) 
  if ((x < 0) or (x >= 65536)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.Overflow),0);
  end;
  if (self.bigEndian) then 
    self:writeByte(_hx_bit.arshift(x,8));
    self:writeByte(_hx_bit.band(x,255));
  else
    self:writeByte(_hx_bit.band(x,255));
    self:writeByte(_hx_bit.arshift(x,8));
  end;
end
__haxe_io_Output.prototype.writeInt24 = function(self,x) 
  if ((x < -8388608) or (x >= 8388608)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.Overflow),0);
  end;
  self:writeUInt24(_hx_bit.band(x,16777215));
end
__haxe_io_Output.prototype.writeUInt24 = function(self,x) 
  if ((x < 0) or (x >= 16777216)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.Overflow),0);
  end;
  if (self.bigEndian) then 
    self:writeByte(_hx_bit.arshift(x,16));
    self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
    self:writeByte(_hx_bit.band(x,255));
  else
    self:writeByte(_hx_bit.band(x,255));
    self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
    self:writeByte(_hx_bit.arshift(x,16));
  end;
end
__haxe_io_Output.prototype.writeInt32 = function(self,x) 
  if (self.bigEndian) then 
    self:writeByte(_hx_bit.rshift(x,24));
    self:writeByte(_hx_bit.band(_hx_bit.arshift(x,16),255));
    self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
    self:writeByte(_hx_bit.band(x,255));
  else
    self:writeByte(_hx_bit.band(x,255));
    self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
    self:writeByte(_hx_bit.band(_hx_bit.arshift(x,16),255));
    self:writeByte(_hx_bit.rshift(x,24));
  end;
end
__haxe_io_Output.prototype.prepare = function(self,nbytes) 
end
__haxe_io_Output.prototype.writeInput = function(self,i,bufsize) 
  if (bufsize == nil) then 
    bufsize = 4096;
  end;
  local buf = __haxe_io_Bytes.alloc(bufsize);
  local _hx_status, _hx_result = pcall(function() 
  
      while (true) do 
        local len = i:readBytes(buf, 0, bufsize);
        if (len == 0) then 
          _G.error(__haxe_Exception.thrown(__haxe_io_Error.Blocked),0);
        end;
        local p = 0;
        while (len > 0) do 
          local k = self:writeBytes(buf, p, len);
          if (k == 0) then 
            _G.error(__haxe_Exception.thrown(__haxe_io_Error.Blocked),0);
          end;
          p = p + k;
          len = len - k;
        end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (not __lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), __haxe_io_Eof)) then 
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__haxe_io_Output.prototype.writeString = function(self,s,encoding) 
  local b = __haxe_io_Bytes.ofString(s, encoding);
  self:writeFullBytes(b, 0, b.length);
end

__haxe_io_Output.prototype.__class__ =  __haxe_io_Output

__haxe_io_Output.prototype.__properties__ =  {set_bigEndian="set_bigEndian"}

__haxe_io_Path.new = function(path) 
  local self = _hx_new(__haxe_io_Path.prototype)
  __haxe_io_Path.super(self,path)
  return self
end
__haxe_io_Path.super = function(self,path) 
  local path1 = path;
  if (path1) == "." or (path1) == ".." then 
    self.dir = path;
    self.file = "";
    do return end; end;
  local startIndex = nil;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(path);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(path, "/", startIndex1, true);
    local p = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  local c1 = ret;
  local startIndex = nil;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(path);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(path, "\\", startIndex1, true);
    local p = (function() 
      local _hx_2
      if ((r ~= nil) and (r > 0)) then 
      _hx_2 = r - 1; else 
      _hx_2 = -1; end
      return _hx_2
    end )();
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  local c2 = ret;
  if (c1 < c2) then 
    local pos = 0;
    local len = c2;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
      len = __lua_lib_luautf8_Utf8.len(path);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(path) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(path) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    self.dir = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);
    local pos = c2 + 1;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
      len = __lua_lib_luautf8_Utf8.len(path);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(path) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(path) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    path = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);
    self.backslash = true;
  else
    if (c2 < c1) then 
      local pos = 0;
      local len = c1;
      if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
        len = __lua_lib_luautf8_Utf8.len(path);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(path) + len;
        end;
      end;
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(path) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      self.dir = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);
      local pos = c1 + 1;
      local len = nil;
      if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
        len = __lua_lib_luautf8_Utf8.len(path);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(path) + len;
        end;
      end;
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(path) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      path = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);
    else
      self.dir = nil;
    end;
  end;
  local startIndex = nil;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(path);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(path, ".", startIndex1, true);
    local p = (function() 
      local _hx_3
      if ((r ~= nil) and (r > 0)) then 
      _hx_3 = r - 1; else 
      _hx_3 = -1; end
      return _hx_3
    end )();
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  local cp = ret;
  if (cp ~= -1) then 
    local pos = cp + 1;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
      len = __lua_lib_luautf8_Utf8.len(path);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(path) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(path) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    self.ext = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);
    local pos = 0;
    local len = cp;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
      len = __lua_lib_luautf8_Utf8.len(path);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(path) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(path) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    self.file = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);
  else
    self.ext = nil;
    self.file = path;
  end;
end
_hxClasses["haxe.io.Path"] = __haxe_io_Path
__haxe_io_Path.__name__ = "haxe.io.Path"
__haxe_io_Path.withoutExtension = function(path) 
  local s = __haxe_io_Path.new(path);
  s.ext = nil;
  do return s:toString() end;
end
__haxe_io_Path.withoutDirectory = function(path) 
  local s = __haxe_io_Path.new(path);
  s.dir = nil;
  do return s:toString() end;
end
__haxe_io_Path.directory = function(path) 
  local s = __haxe_io_Path.new(path);
  if (s.dir == nil) then 
    do return "" end;
  end;
  do return s.dir end;
end
__haxe_io_Path.extension = function(path) 
  local s = __haxe_io_Path.new(path);
  if (s.ext == nil) then 
    do return "" end;
  end;
  do return s.ext end;
end
__haxe_io_Path.withExtension = function(path,ext) 
  local s = __haxe_io_Path.new(path);
  s.ext = ext;
  do return s:toString() end;
end
__haxe_io_Path.join = function(paths) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = paths;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if ((i ~= nil) and (i ~= "")) then 
      _g:push(i);
    end;
  end;
  local paths = _g;
  if (paths.length == 0) then 
    do return "" end;
  end;
  local path = paths[0];
  local _g = 1;
  local _g1 = paths.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    path = __haxe_io_Path.addTrailingSlash(path);
    path = Std.string(path) .. Std.string(paths[i]);
  end;
  do return __haxe_io_Path.normalize(path) end;
end
__haxe_io_Path.normalize = function(path) 
  local slash = "/";
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("\\") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(path, "\\", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(path)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(path, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("\\");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(path, idx, __lua_lib_luautf8_Utf8.len(path)));
      idx = nil;
    end;
  end;
  path = ret:join(slash);
  if (path == slash) then 
    do return slash end;
  end;
  local target = _hx_tab_array({}, 0);
  local _g = 0;
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(slash) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(path, slash, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(path)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(path, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(slash);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(path, idx, __lua_lib_luautf8_Utf8.len(path)));
      idx = nil;
    end;
  end;
  local _g1 = ret;
  while (_g < _g1.length) do 
    local token = _g1[_g];
    _g = _g + 1;
    if (((token == "..") and (target.length > 0)) and (target[target.length - 1] ~= "..")) then 
      target:pop();
    else
      if (token == "") then 
        if ((target.length > 0) or (__lua_lib_luautf8_Utf8.byte(path, 1) == 47)) then 
          target:push(token);
        end;
      else
        if (token ~= ".") then 
          target:push(token);
        end;
      end;
    end;
  end;
  local tmp = target:join(slash);
  local acc_b = ({});
  local acc_length = 0;
  local colon = false;
  local slashes = false;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(tmp);
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g = __lua_lib_luautf8_Utf8.byte(tmp, i + 1);
    local _g1 = _g;
    if (_g1) == 47 then 
      if (not colon) then 
        slashes = true;
      else
        local i = _g;
        colon = false;
        if (slashes) then 
          local str = "/";
          _G.table.insert(acc_b, str);
          acc_length = acc_length + __lua_lib_luautf8_Utf8.len(str);
          slashes = false;
        end;
        _G.table.insert(acc_b, __lua_lib_luautf8_Utf8.char(i));
        acc_length = acc_length + 1;
      end;
    elseif (_g1) == 58 then 
      local str = ":";
      _G.table.insert(acc_b, str);
      acc_length = acc_length + __lua_lib_luautf8_Utf8.len(str);
      colon = true;else
    local i = _g;
    colon = false;
    if (slashes) then 
      local str = "/";
      _G.table.insert(acc_b, str);
      acc_length = acc_length + __lua_lib_luautf8_Utf8.len(str);
      slashes = false;
    end;
    _G.table.insert(acc_b, __lua_lib_luautf8_Utf8.char(i));
    acc_length = acc_length + 1; end;
  end;
  do return _G.table.concat(acc_b) end;
end
__haxe_io_Path.addTrailingSlash = function(path) 
  if (__lua_lib_luautf8_Utf8.len(path) == 0) then 
    do return "/" end;
  end;
  local startIndex = nil;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(path);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(path, "/", startIndex1, true);
    local p = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  local c1 = ret;
  local startIndex = nil;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(path);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(path, "\\", startIndex1, true);
    local p = (function() 
      local _hx_2
      if ((r ~= nil) and (r > 0)) then 
      _hx_2 = r - 1; else 
      _hx_2 = -1; end
      return _hx_2
    end )();
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  local c2 = ret;
  if (c1 < c2) then 
    if (c2 ~= (__lua_lib_luautf8_Utf8.len(path) - 1)) then 
      do return Std.string(path) .. Std.string("\\") end;
    else
      do return path end;
    end;
  else
    if (c1 ~= (__lua_lib_luautf8_Utf8.len(path) - 1)) then 
      do return Std.string(path) .. Std.string("/") end;
    else
      do return path end;
    end;
  end;
end
__haxe_io_Path.removeTrailingSlashes = function(path) 
  while (true) do 
    local _g = __lua_lib_luautf8_Utf8.byte(path, (__lua_lib_luautf8_Utf8.len(path) - 1) + 1);
    if (_g == nil) then 
      break;
    else
      local _g = _g;
      if (_g) == 47 or (_g) == 92 then 
        local pos = 0;
        local len = -1;
        if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(path)))) then 
          len = __lua_lib_luautf8_Utf8.len(path);
        else
          if (len < 0) then 
            len = __lua_lib_luautf8_Utf8.len(path) + len;
          end;
        end;
        if (pos < 0) then 
          pos = __lua_lib_luautf8_Utf8.len(path) + pos;
        end;
        if (pos < 0) then 
          pos = 0;
        end;
        path = __lua_lib_luautf8_Utf8.sub(path, pos + 1, pos + len);else
      break; end;
    end;
  end;
  do return path end;
end
__haxe_io_Path.isAbsolute = function(path) 
  if (StringTools.startsWith(path, "/")) then 
    do return true end;
  end;
  if (__lua_lib_luautf8_Utf8.sub(path, 2, 2) == ":") then 
    do return true end;
  end;
  if (StringTools.startsWith(path, "\\\\")) then 
    do return true end;
  end;
  do return false end;
end
__haxe_io_Path.unescape = function(path) 
  local regex = EReg.new("-x([0-9][0-9])", "g");
  do return regex:map(path, function(regex) 
    do return __lua_lib_luautf8_Utf8.char(Std.parseInt(regex:matched(1))) end;
  end) end;
end
__haxe_io_Path.escape = function(path,allowSlashes) 
  if (allowSlashes == nil) then 
    allowSlashes = false;
  end;
  local regex = (function() 
    local _hx_1
    if (allowSlashes) then 
    _hx_1 = EReg.new("[^A-Za-z0-9_/\\\\\\.]", "g"); else 
    _hx_1 = EReg.new("[^A-Za-z0-9_\\.]", "g"); end
    return _hx_1
  end )();
  do return regex:map(path, function(v) 
    do return Std.string("-x") .. Std.string(__lua_lib_luautf8_Utf8.byte(v:matched(0), 1)) end;
  end) end;
end
__haxe_io_Path.prototype = _hx_e();
__haxe_io_Path.prototype.dir= nil;
__haxe_io_Path.prototype.file= nil;
__haxe_io_Path.prototype.ext= nil;
__haxe_io_Path.prototype.backslash= nil;
__haxe_io_Path.prototype.toString = function(self) 
  do return Std.string(Std.string(((function() 
    local _hx_1
    if (self.dir == nil) then 
    _hx_1 = ""; else 
    _hx_1 = Std.string(self.dir) .. Std.string(((function() 
      local _hx_2
      if (self.backslash) then 
      _hx_2 = "\\"; else 
      _hx_2 = "/"; end
      return _hx_2
    end )())); end
    return _hx_1
  end )())) .. Std.string(self.file)) .. Std.string(((function() 
    local _hx_3
    if (self.ext == nil) then 
    _hx_3 = ""; else 
    _hx_3 = Std.string(".") .. Std.string(self.ext); end
    return _hx_3
  end )())) end
end

__haxe_io_Path.prototype.__class__ =  __haxe_io_Path

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
_hxClasses["haxe.iterators.ArrayIterator"] = __haxe_iterators_ArrayIterator
__haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator"
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.array= nil;
__haxe_iterators_ArrayIterator.prototype.current= nil;
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
_hxClasses["haxe.iterators.ArrayKeyValueIterator"] = __haxe_iterators_ArrayKeyValueIterator
__haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator"
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();
__haxe_iterators_ArrayKeyValueIterator.prototype.current= nil;
__haxe_iterators_ArrayKeyValueIterator.prototype.array= nil;
__haxe_iterators_ArrayKeyValueIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayKeyValueIterator.prototype.next = function(self) 
  do return _hx_o({__fields__={value=true,key=true},value=self.array[self.current],key=(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()}) end
end

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__haxe_iterators_HashMapKeyValueIterator.new = function(map) 
  local self = _hx_new(__haxe_iterators_HashMapKeyValueIterator.prototype)
  __haxe_iterators_HashMapKeyValueIterator.super(self,map)
  return self
end
__haxe_iterators_HashMapKeyValueIterator.super = function(self,map) 
  self.map = map;
  self.keys = map.keys:iterator();
end
_hxClasses["haxe.iterators.HashMapKeyValueIterator"] = __haxe_iterators_HashMapKeyValueIterator
__haxe_iterators_HashMapKeyValueIterator.__name__ = "haxe.iterators.HashMapKeyValueIterator"
__haxe_iterators_HashMapKeyValueIterator.prototype = _hx_e();
__haxe_iterators_HashMapKeyValueIterator.prototype.map= nil;
__haxe_iterators_HashMapKeyValueIterator.prototype.keys= nil;
__haxe_iterators_HashMapKeyValueIterator.prototype.hasNext = function(self) 
  do return self.keys:hasNext() end
end
__haxe_iterators_HashMapKeyValueIterator.prototype.next = function(self) 
  local key = self.keys:next();
  local _this = self.map.values;
  local key1 = key:hashCode();
  local ret = _this.h[key1];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return _hx_o({__fields__={value=true,key=true},value=ret,key=key}) end
end

__haxe_iterators_HashMapKeyValueIterator.prototype.__class__ =  __haxe_iterators_HashMapKeyValueIterator

__haxe_iterators_MapKeyValueIterator.new = function(map) 
  local self = _hx_new(__haxe_iterators_MapKeyValueIterator.prototype)
  __haxe_iterators_MapKeyValueIterator.super(self,map)
  return self
end
__haxe_iterators_MapKeyValueIterator.super = function(self,map) 
  self.map = map;
  self.keys = map:keys();
end
_hxClasses["haxe.iterators.MapKeyValueIterator"] = __haxe_iterators_MapKeyValueIterator
__haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator"
__haxe_iterators_MapKeyValueIterator.prototype = _hx_e();
__haxe_iterators_MapKeyValueIterator.prototype.map= nil;
__haxe_iterators_MapKeyValueIterator.prototype.keys= nil;
__haxe_iterators_MapKeyValueIterator.prototype.hasNext = function(self) 
  do return self.keys:hasNext() end
end
__haxe_iterators_MapKeyValueIterator.prototype.next = function(self) 
  local key = self.keys:next();
  do return _hx_o({__fields__={value=true,key=true},value=self.map:get(key),key=key}) end
end

__haxe_iterators_MapKeyValueIterator.prototype.__class__ =  __haxe_iterators_MapKeyValueIterator

__haxe_iterators_StringIterator.new = function(s) 
  local self = _hx_new(__haxe_iterators_StringIterator.prototype)
  __haxe_iterators_StringIterator.super(self,s)
  return self
end
__haxe_iterators_StringIterator.super = function(self,s) 
  self.codes = __lua_lib_luautf8_Utf8.codes(s);
  self.str = s;
  local _hx_1_cp_position, _hx_1_cp_codepoint = self:codes(self.str, 0);
  self.codepoint = _hx_1_cp_codepoint;
  self.position = _hx_1_cp_position;
end
_hxClasses["haxe.iterators.StringIterator"] = __haxe_iterators_StringIterator
__haxe_iterators_StringIterator.__name__ = "haxe.iterators.StringIterator"
__haxe_iterators_StringIterator.prototype = _hx_e();
__haxe_iterators_StringIterator.prototype.codes= nil;
__haxe_iterators_StringIterator.prototype.codepoint= nil;
__haxe_iterators_StringIterator.prototype.str= nil;
__haxe_iterators_StringIterator.prototype.position= nil;
__haxe_iterators_StringIterator.prototype.hasNext = function(self) 
  do return self.codepoint ~= nil end
end
__haxe_iterators_StringIterator.prototype.next = function(self) 
  local ret = self.codepoint;
  local _hx_1_cp_position, _hx_1_cp_codepoint = self:codes(self.str, self.position);
  self.codepoint = _hx_1_cp_codepoint;
  self.position = _hx_1_cp_position;
  do return ret end
end

__haxe_iterators_StringIterator.prototype.__class__ =  __haxe_iterators_StringIterator

__haxe_iterators_StringIteratorUnicode.new = function(s) 
  local self = _hx_new(__haxe_iterators_StringIteratorUnicode.prototype)
  __haxe_iterators_StringIteratorUnicode.super(self,s)
  return self
end
__haxe_iterators_StringIteratorUnicode.super = function(self,s) 
  self.offset = 0;
  self.s = s;
end
_hxClasses["haxe.iterators.StringIteratorUnicode"] = __haxe_iterators_StringIteratorUnicode
__haxe_iterators_StringIteratorUnicode.__name__ = "haxe.iterators.StringIteratorUnicode"
__haxe_iterators_StringIteratorUnicode.unicodeIterator = function(s) 
  do return __haxe_iterators_StringIteratorUnicode.new(s) end;
end
__haxe_iterators_StringIteratorUnicode.prototype = _hx_e();
__haxe_iterators_StringIteratorUnicode.prototype.offset= nil;
__haxe_iterators_StringIteratorUnicode.prototype.s= nil;
__haxe_iterators_StringIteratorUnicode.prototype.hasNext = function(self) 
  do return self.offset < __lua_lib_luautf8_Utf8.len(self.s) end
end
__haxe_iterators_StringIteratorUnicode.prototype.next = function(self) 
  local index = (function() 
  local _hx_obj = self;
  local _hx_fld = 'offset';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  do return __lua_lib_luautf8_Utf8.byte(self.s, index + 1) end
end

__haxe_iterators_StringIteratorUnicode.prototype.__class__ =  __haxe_iterators_StringIteratorUnicode

__haxe_iterators_StringKeyValueIterator.new = function(s) 
  local self = _hx_new(__haxe_iterators_StringKeyValueIterator.prototype)
  __haxe_iterators_StringKeyValueIterator.super(self,s)
  return self
end
__haxe_iterators_StringKeyValueIterator.super = function(self,s) 
  self.offset = 0;
  self.s = s;
end
_hxClasses["haxe.iterators.StringKeyValueIterator"] = __haxe_iterators_StringKeyValueIterator
__haxe_iterators_StringKeyValueIterator.__name__ = "haxe.iterators.StringKeyValueIterator"
__haxe_iterators_StringKeyValueIterator.prototype = _hx_e();
__haxe_iterators_StringKeyValueIterator.prototype.offset= nil;
__haxe_iterators_StringKeyValueIterator.prototype.s= nil;
__haxe_iterators_StringKeyValueIterator.prototype.hasNext = function(self) 
  do return self.offset < __lua_lib_luautf8_Utf8.len(self.s) end
end
__haxe_iterators_StringKeyValueIterator.prototype.next = function(self) 
  local tmp = self.offset;
  local index = (function() 
  local _hx_obj = self;
  local _hx_fld = 'offset';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  do return _hx_o({__fields__={key=true,value=true},key=tmp,value=__lua_lib_luautf8_Utf8.byte(self.s, index + 1)}) end
end

__haxe_iterators_StringKeyValueIterator.prototype.__class__ =  __haxe_iterators_StringKeyValueIterator

__lua_HaxeIterator.new = function(f) 
  local self = _hx_new(__lua_HaxeIterator.prototype)
  __lua_HaxeIterator.super(self,f)
  return self
end
__lua_HaxeIterator.super = function(self,f) 
  self.f = _hx_funcToField(f);
  self.state = f();
end
_hxClasses["lua.HaxeIterator"] = __lua_HaxeIterator
__lua_HaxeIterator.__name__ = "lua.HaxeIterator"
__lua_HaxeIterator.prototype = _hx_e();
__lua_HaxeIterator.prototype.state= nil;
__lua_HaxeIterator.prototype.f= nil;
__lua_HaxeIterator.prototype.next = function(self) 
  local ret = self.state;
  self.state = self:f();
  do return ret end
end
__lua_HaxeIterator.prototype.hasNext = function(self) 
  do return self.state ~= nil end
end

__lua_HaxeIterator.prototype.__class__ =  __lua_HaxeIterator

__lua__Io_IoType_Impl_.new = {}
_hxClasses["lua._Io.IoType_Impl_"] = __lua__Io_IoType_Impl_
__lua__Io_IoType_Impl_.__name__ = "lua._Io.IoType_Impl_"
__lua__Io_IoType_Impl_.toString = function(this1) 
  do return this1 end;
end

__lua_Lib.new = {}
_hxClasses["lua.Lib"] = __lua_Lib
__lua_Lib.__name__ = "lua.Lib"
__lua_Lib.println = function(v) 
  _G.print(Std.string(v));
end
__lua_Lib.print = function(v) 
  _G.io.write(Std.string(v));
  _G.io.flush();
end
__lua_Lib.patternQuote = function(str) 
  do return _G.string.gsub(str, "[%(%)%.%%%+%-%*%?%[%]%^%$]", function(c) 
    do return Std.string("%") .. Std.string(c) end;
  end) end;
end
__lua_Lib.fillArray = function(itr) 
  local i = nil;
  local ret = _hx_tab_array({}, 0);
  while (true) do 
    i = itr();
    if (not (i ~= nil)) then 
      break;
    end;
    ret:push(i);
  end;
  do return ret end;
end
__lua_Lib.isShellAvailable = function() 
  local ret = _G.os.execute();
  if (_G.type(ret) == "bool") then 
    do return ret end;
  else
    do return ret ~= 0 end;
  end;
end

__lua__NativeIterator_NativeIterator_Impl_.new = {}
_hxClasses["lua._NativeIterator.NativeIterator_Impl_"] = __lua__NativeIterator_NativeIterator_Impl_
__lua__NativeIterator_NativeIterator_Impl_.__name__ = "lua._NativeIterator.NativeIterator_Impl_"
__lua__NativeIterator_NativeIterator_Impl_._new = function(f) 
  local this1 = f;
  do return this1 end;
end
__lua__NativeIterator_NativeIterator_Impl_.fromF = function(f) 
  do return __lua__NativeIterator_NativeIterator_Impl_._new(f) end;
end
__lua__NativeIterator_NativeIterator_Impl_.toIterator = function(this1) 
  do return __lua_HaxeIterator.new(this1) end;
end

__lua_PairTools.new = {}
_hxClasses["lua.PairTools"] = __lua_PairTools
__lua_PairTools.__name__ = "lua.PairTools"
__lua_PairTools.ipairsEach = function(table,func) 
  for i,v in _G.ipairs(table) do func(i,v) end;
end
__lua_PairTools.pairsEach = function(table,func) 
  for k,v in _G.pairs(table) do func(k,v) end;
end
__lua_PairTools.ipairsMap = function(table,func) 
  local ret = ({});
  for i,v in _G.ipairs(table) do ret[i] = func(i,v) end;
  do return ret end;
end
__lua_PairTools.pairsMap = function(table,func) 
  local ret = ({});
  for k,v in _G.pairs(table) do ret[k] = func(k,v) end;
  do return ret end;
end
__lua_PairTools.ipairsFold = function(table,func,seed) 
  for i,v in _G.ipairs(table) do seed = func(i,v,seed) end;
  do return seed end;
end
__lua_PairTools.pairsFold = function(table,func,seed) 
  for k,v in _G.pairs(table) do seed = func(k,v,seed) end;
  do return seed end;
end
__lua_PairTools.ipairsConcat = function(table1,table2) 
  local ret = ({});
  __lua_PairTools.ipairsFold(table1, function(a,b,c) 
    c[a] = b;
    do return c end;
  end, ret);
  local size = _hx_table.maxn(ret);
  __lua_PairTools.ipairsFold(table2, function(a,b,c) 
    c[a + size] = b;
    do return c end;
  end, ret);
  do return ret end;
end
__lua_PairTools.pairsMerge = function(table1,table2) 
  local ret = __lua_PairTools.copy(table1);
  __lua_PairTools.pairsEach(table2, function(a,b) 
    ret[a] = b;
  end);
  do return ret end;
end
__lua_PairTools.ipairsExist = function(table,func) 
  for k,v in _G.ipairs(table) do if func(k,v) then return true end end;
end
__lua_PairTools.pairsExist = function(table,func) 
  for k,v in _G.pairs(table) do if func(k,v) then return true end end;
end
__lua_PairTools.copy = function(table1) 
  local ret = ({});
  for k,v in _G.pairs(table1) do ret[k] = v end;
  do return ret end;
end
__lua_PairTools.pairsIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.pairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={index=true,value=true},index=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return _G.select(2, _G.next(table, i)) ~= nil end;
  end}) end;
end
__lua_PairTools.ipairsIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.ipairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={index=true,value=true},index=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return _G.select(2, next(table, i)) ~= nil end;
  end}) end;
end

__sys_FileSystem.new = {}
_hxClasses["sys.FileSystem"] = __sys_FileSystem
__sys_FileSystem.__name__ = "sys.FileSystem"
__sys_FileSystem.exists = function(path) 
  if (path == nil) then 
    do return false end;
  else
    local _hx_1_res_result, _hx_1_res_message = __lua_lib_luv_fs_FileSystem.fs_stat(path);
    do return _hx_1_res_result ~= nil end;
  end;
end
__sys_FileSystem.rename = function(path,newPath) 
  local _hx_1_ret_success, _hx_1_ret_message = _G.os.rename(path, newPath);
  if (not _hx_1_ret_success) then 
    _G.error(__haxe_Exception.thrown(_hx_1_ret_message),0);
  end;
end
__sys_FileSystem.stat = function(path) 
  local _hx_1_ls_result, _hx_1_ls_message = __lua_lib_luv_fs_FileSystem.fs_stat(path);
  if (_hx_1_ls_result == nil) then 
    _G.error(__haxe_Exception.thrown(_hx_1_ls_message),0);
  end;
  local l = _hx_1_ls_result;
  local l1 = l.gid;
  local l2 = l.uid;
  local l3 = l.rdev;
  local l4 = l.size;
  local l5 = l.nlink;
  local t = l.mtime.sec + (l.mtime.nsec / 1000000);
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  local l6 = l.mode;
  local l7 = l.ino;
  local l8 = l.dev;
  local t = l.ctime.sec + (l.ctime.nsec / 1000000);
  local d1 = _hx_e();
  _G.setmetatable(d1, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d1.t = t / 1000;
  d1.d = _G.os.date("*t", Std.int(d1.t));
  d1.dUTC = _G.os.date("!*t", Std.int(d1.t));
  local t = l.atime.sec + (l.atime.nsec / 1000000);
  local d2 = _hx_e();
  _G.setmetatable(d2, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d2.t = t / 1000;
  d2.d = _G.os.date("*t", Std.int(d2.t));
  d2.dUTC = _G.os.date("!*t", Std.int(d2.t));
  do return _hx_o({__fields__={gid=true,uid=true,rdev=true,size=true,nlink=true,mtime=true,mode=true,ino=true,dev=true,ctime=true,atime=true},gid=l1,uid=l2,rdev=l3,size=l4,nlink=l5,mtime=d,mode=l6,ino=l7,dev=l8,ctime=d1,atime=d2}) end;
end
__sys_FileSystem.fullPath = function(relPath) 
  local tmp;
  if (__haxe_io_Path.isAbsolute(relPath)) then 
    tmp = relPath;
  else
    local pwd = __lua_lib_luv_Misc.cwd();
    tmp = (function() 
      local _hx_1
      if (pwd == nil) then 
      _hx_1 = relPath; else 
      _hx_1 = __haxe_io_Path.join(_hx_tab_array({[0]=pwd, relPath}, 2)); end
      return _hx_1
    end )();
  end;
  do return __lua_lib_luv_fs_FileSystem.fs_realpath(__haxe_io_Path.normalize(tmp)) end;
end
__sys_FileSystem.absolutePath = function(relPath) 
  if (__haxe_io_Path.isAbsolute(relPath)) then 
    do return relPath end;
  end;
  local pwd = __lua_lib_luv_Misc.cwd();
  if (pwd == nil) then 
    do return relPath end;
  end;
  do return __haxe_io_Path.join(_hx_tab_array({[0]=pwd, relPath}, 2)) end;
end
__sys_FileSystem.deleteFile = function(path) 
  local _hx_1_ret_success, _hx_1_ret_message = _G.os.remove(path);
  if (not _hx_1_ret_success) then 
    _G.error(__haxe_Exception.thrown(_hx_1_ret_message),0);
  end;
end
__sys_FileSystem.readDirectory = function(path) 
  local scandir = __lua_lib_luv_fs_FileSystem.fs_scandir(path);
  local itr = function() 
    local next = __lua_lib_luv_fs_FileSystem.fs_scandir_next(scandir);
    do return next end;
  end;
  do return __lua_Lib.fillArray(itr) end;
end
__sys_FileSystem.isDirectory = function(path) 
  local result = __lua_lib_luv_fs_FileSystem.fs_stat(path);
  if (result == nil) then 
    do return false end;
  else
    do return result.type == "directory" end;
  end;
end
__sys_FileSystem.deleteDirectory = function(path) 
  local _hx_1_ret_result, _hx_1_ret_message = __lua_lib_luv_fs_FileSystem.fs_rmdir(path);
  if (_hx_1_ret_result == nil) then 
    _G.error(__haxe_Exception.thrown(_hx_1_ret_message),0);
  end;
end
__sys_FileSystem.createDirectory = function(path) 
  local path = __haxe_io_Path.addTrailingSlash(path);
  local _p = nil;
  local parts = _hx_tab_array({}, 0);
  while (true) do 
    _p = __haxe_io_Path.directory(path);
    if (not (path ~= _p)) then 
      break;
    end;
    parts:unshift(path);
    path = _p;
  end;
  local _g = 0;
  while (_g < parts.length) do 
    local part = parts[_g];
    _g = _g + 1;
    if (((__lua_lib_luautf8_Utf8.byte(part, (__lua_lib_luautf8_Utf8.len(part) - 1) + 1) ~= 58) and not __sys_FileSystem.exists(part)) and not __lua_lib_luv_fs_FileSystem.fs_mkdir(part, 511)) then 
      _G.error(__haxe_Exception.thrown(Std.string("Could not create directory:") .. Std.string(part)),0);
    end;
  end;
end

__sys_io_FileInput.new = function(f) 
  local self = _hx_new(__sys_io_FileInput.prototype)
  __sys_io_FileInput.super(self,f)
  return self
end
__sys_io_FileInput.super = function(self,f) 
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("Invalid filehandle : ") .. Std.string(Std.string(f))),0);
  end;
  self:set_bigEndian(__lua_Boot.platformBigEndian);
  self.f = f;
  self._eof = false;
end
_hxClasses["sys.io.FileInput"] = __sys_io_FileInput
__sys_io_FileInput.__name__ = "sys.io.FileInput"
__sys_io_FileInput.prototype = _hx_e();
__sys_io_FileInput.prototype.f= nil;
__sys_io_FileInput.prototype._eof= nil;
__sys_io_FileInput.prototype.seek = function(self,p,pos) 
  local arg;
  local arg1 = pos[1];
  if (arg1) == 0 then 
    arg = "set";
  elseif (arg1) == 1 then 
    arg = "cur";
  elseif (arg1) == 2 then 
    arg = "end"; end;
  self._eof = false;
  self.f:seek(arg, p);
end
__sys_io_FileInput.prototype.tell = function(self) 
  do return self.f:seek() end
end
__sys_io_FileInput.prototype.eof = function(self) 
  do return self._eof end
end
__sys_io_FileInput.prototype.readByte = function(self) 
  local byte = self.f:read(1);
  if (byte == nil) then 
    self._eof = true;
    _G.error(__haxe_Exception.thrown(__haxe_io_Eof.new()),0);
  end;
  do return _G.string.byte(byte) end
end
__sys_io_FileInput.prototype.readBytes = function(self,s,pos,len) 
  if (self._eof) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Eof.new()),0);
  end;
  do return __haxe_io_Input.prototype.readBytes(self,s,pos,len) end
end
__sys_io_FileInput.prototype.close = function(self) 
  self.f:close();
end
__sys_io_FileInput.prototype.readAll = function(self,bufsize) 
  if (bufsize == nil) then 
    bufsize = 16384;
  end;
  local buf = __haxe_io_Bytes.alloc(bufsize);
  local total = __haxe_io_BytesBuffer.new();
  local _hx_status, _hx_result = pcall(function() 
  
      while (true) do 
        local len = self:readBytes(buf, 0, bufsize);
        if (len == 0) then 
          break;
        end;
        if ((len < 0) or (len > buf.length)) then 
          _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
        end;
        local b1 = total.b;
        local b2 = buf.b;
        local _g = 0;
        local _g1 = len;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          total.b:push(b2[i]);
        end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), __haxe_io_Eof)) then 
      self._eof = true;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return total:getBytes() end
end

__sys_io_FileInput.prototype.__class__ =  __sys_io_FileInput
__sys_io_FileInput.__super__ = __haxe_io_Input
setmetatable(__sys_io_FileInput.prototype,{__index=__haxe_io_Input.prototype})
setmetatable(__sys_io_FileInput.prototype.__properties__,{__index=__haxe_io_Input.prototype.__properties__})

__sys_io_FileOutput.new = function(f) 
  local self = _hx_new(__sys_io_FileOutput.prototype)
  __sys_io_FileOutput.super(self,f)
  return self
end
__sys_io_FileOutput.super = function(self,f) 
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("Invalid filehandle : ") .. Std.string(Std.string(f))),0);
  end;
  self.f = f;
end
_hxClasses["sys.io.FileOutput"] = __sys_io_FileOutput
__sys_io_FileOutput.__name__ = "sys.io.FileOutput"
__sys_io_FileOutput.prototype = _hx_e();
__sys_io_FileOutput.prototype.f= nil;
__sys_io_FileOutput.prototype.seek = function(self,p,pos) 
  local arg;
  local arg1 = pos[1];
  if (arg1) == 0 then 
    arg = "set";
  elseif (arg1) == 1 then 
    arg = "cur";
  elseif (arg1) == 2 then 
    arg = "end"; end;
  self.f:seek(arg, p);
end
__sys_io_FileOutput.prototype.tell = function(self) 
  do return self.f:seek() end
end
__sys_io_FileOutput.prototype.writeByte = function(self,c) 
  self.f:write(__lua_lib_luautf8_Utf8.char(c));
end
__sys_io_FileOutput.prototype.writeBytes = function(self,s,pos,len) 
  self.f:write(s:getString(pos, len));
  do return s.length end
end
__sys_io_FileOutput.prototype.close = function(self) 
  self.f:close();
end

__sys_io_FileOutput.prototype.__class__ =  __sys_io_FileOutput
__sys_io_FileOutput.__super__ = __haxe_io_Output
setmetatable(__sys_io_FileOutput.prototype,{__index=__haxe_io_Output.prototype})
setmetatable(__sys_io_FileOutput.prototype.__properties__,{__index=__haxe_io_Output.prototype.__properties__})
_hxClasses["sys.io.FileSeek"] = __sys_io_FileSeek;
_hxClasses["sys.io.FileSeek"] = { __ename__ = "sys.io.FileSeek", __constructs__ = _hx_tab_array({[0]="SeekBegin","SeekCur","SeekEnd"},3)}
__sys_io_FileSeek = _hxClasses["sys.io.FileSeek"];
__sys_io_FileSeek.SeekBegin = _hx_tab_array({[0]="SeekBegin",0,__enum__ = __sys_io_FileSeek},2)

__sys_io_FileSeek.SeekCur = _hx_tab_array({[0]="SeekCur",1,__enum__ = __sys_io_FileSeek},2)

__sys_io_FileSeek.SeekEnd = _hx_tab_array({[0]="SeekEnd",2,__enum__ = __sys_io_FileSeek},2)

__sys_io_FileSeek.__empty_constructs__ = _hx_tab_array({[0] = __sys_io_FileSeek.SeekBegin,__sys_io_FileSeek.SeekCur,__sys_io_FileSeek.SeekEnd}, 3)

__sys_io_Process.new = function(cmd,args,detached) 
  local self = _hx_new(__sys_io_Process.prototype)
  __sys_io_Process.super(self,cmd,args,detached)
  return self
end
__sys_io_Process.super = function(self,cmd,args,detached) 
  local _gthis = self;
  if (detached) then 
    _G.error(__haxe_Exception.thrown("Detached process is not supported on this platform"),0);
  end;
  local _stdout = __lua_lib_luv_Pipe.new_pipe(false);
  local _stderr = __lua_lib_luv_Pipe.new_pipe(false);
  local _stdin = __lua_lib_luv_Pipe.new_pipe(false);
  self.stdout = __sys_io__Process_ProcessInput.new(_stdout);
  self.stderr = __sys_io__Process_ProcessInput.new(_stderr);
  self.stdin = __sys_io__Process_ProcessOutput.new(_stdin);
  local stdio = ({_stdin,_stdout,_stderr});
  local opt = _hx_o({__fields__={args=true,stdio=true},args=__sys_io_Process.setArgs(cmd, args),stdio=stdio});
  local _hx_1_p_handle, _hx_1_p_pid = __lua_lib_luv_Process.spawn(__sys_io_Process._shell, opt, function(code,signal) 
    _gthis._code = code;
    if (not _gthis._handle:is_closing()) then 
      _gthis._handle:close();
    end;
    _stdin:shutdown(function() 
      _stdin:close();
    end);
    _stderr:shutdown(function() 
      _stderr:close();
    end);
    _stdout:shutdown(function() 
      _stdout:close();
    end);
  end);
  self._handle = _hx_1_p_handle;
  if (_hx_1_p_handle == nil) then 
    _G.error(__haxe_Exception.thrown(_hx_1_p_pid),0);
  end;
  self._pid = _hx_1_p_pid;
end
_hxClasses["sys.io.Process"] = __sys_io_Process
__sys_io_Process.__name__ = "sys.io.Process"
__sys_io_Process.setArgs = function(cmd,args) 
  local pargs = ({});
  local idx = 1;
  if (__sys_FileSystem.exists(cmd)) then 
    cmd = Std.string(Std.string("\"") .. Std.string(cmd)) .. Std.string("\"");
  end;
  local all = _hx_tab_array({[0]=cmd}, 1);
  if (args ~= nil) then 
    local _g = 0;
    while (_g < args.length) do 
      local a = args[_g];
      _g = _g + 1;
      all:push(__sys_io_Process.argQuote(a));
    end;
  end;
  if (Sys.systemName() == "Windows") then 
    idx = idx + 1;
    pargs[idx - 1] = "/s";
    idx = idx + 1;
    pargs[idx - 1] = "/c";
    idx = idx + 1;
    pargs[idx - 1] = all:join(" ");
  else
    idx = idx + 1;
    pargs[idx - 1] = "-c";
    idx = idx + 1;
    pargs[idx - 1] = all:join(" ");
  end;
  do return pargs end;
end
__sys_io_Process.prototype = _hx_e();
__sys_io_Process.prototype._pid= nil;
__sys_io_Process.prototype._handle= nil;
__sys_io_Process.prototype._code= nil;
__sys_io_Process.prototype.closef= nil;
__sys_io_Process.prototype.stdout= nil;
__sys_io_Process.prototype.stderr= nil;
__sys_io_Process.prototype.stdin= nil;
__sys_io_Process.prototype.getPid = function(self) 
  do return self._pid end
end
__sys_io_Process.prototype.close = function(self) 
  if (not self._handle:is_closing()) then 
    self._handle:close();
  end;
end
__sys_io_Process.prototype.exitCode = function(self,block) 
  if (block == nil) then 
    block = true;
  end;
  if (not block) then 
    do return self._code end;
  end;
  while (self._handle:is_active()) do 
    __lua_lib_luv_Loop.run();
  end;
  do return self._code end
end
__sys_io_Process.prototype.kill = function(self) 
  self._handle:kill("sigterm");
end

__sys_io_Process.prototype.__class__ =  __sys_io_Process

__sys_io__Process_ProcessInput.new = function(pipe) 
  local self = _hx_new(__sys_io__Process_ProcessInput.prototype)
  __sys_io__Process_ProcessInput.super(self,pipe)
  return self
end
__sys_io__Process_ProcessInput.super = function(self,pipe) 
  self.b = pipe;
  self._eof = false;
end
_hxClasses["sys.io._Process.ProcessInput"] = __sys_io__Process_ProcessInput
__sys_io__Process_ProcessInput.__name__ = "sys.io._Process.ProcessInput"
__sys_io__Process_ProcessInput.prototype = _hx_e();
__sys_io__Process_ProcessInput.prototype.b= nil;
__sys_io__Process_ProcessInput.prototype.buf= nil;
__sys_io__Process_ProcessInput.prototype.idx= nil;
__sys_io__Process_ProcessInput.prototype._eof= nil;
__sys_io__Process_ProcessInput.prototype.eof = function(self) 
  do return self._eof end
end
__sys_io__Process_ProcessInput.prototype.readBytes = function(self,s,pos,len) 
  if (self._eof) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Eof.new()),0);
  end;
  do return __haxe_io_Input.prototype.readBytes(self,s,pos,len) end
end
__sys_io__Process_ProcessInput.prototype.readByte = function(self) 
  local _gthis = self;
  local err_str = nil;
  if ((self.buf == nil) or (self.idx >= _G.string.len(self.buf))) then 
    self.buf = nil;
    self.idx = 0;
    local pending = true;
    self.b:read_start(function(err,chunk) 
      if (chunk ~= nil) then 
        if (_gthis.buf ~= nil) then 
          _gthis.buf = Std.string(_gthis.buf) .. Std.string(chunk);
        else
          _gthis.buf = chunk;
        end;
      end;
      if (err ~= nil) then 
        err_str = err;
      end;
      pending = false;
    end);
    while (pending) do 
      __lua_lib_luv_Loop.run();
    end;
  end;
  if (self.buf == nil) then 
    self._eof = true;
    _G.error(__haxe_Exception.thrown(__haxe_io_Eof.new()),0);
  end;
  if (err_str ~= nil) then 
    _G.error(__haxe_Exception.thrown(err_str),0);
  end;
  local code = _G.string.byte(self.buf, (function() 
  local _hx_obj = self;
  local _hx_fld = 'idx';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)());
  do return code end
end
__sys_io__Process_ProcessInput.prototype.readAll = function(self,bufsize) 
  if (bufsize == nil) then 
    bufsize = 16384;
  end;
  local buf = __haxe_io_Bytes.alloc(bufsize);
  local total = __haxe_io_BytesBuffer.new();
  local _hx_status, _hx_result = pcall(function() 
  
      while (true) do 
        local len = self:readBytes(buf, 0, bufsize);
        if (len ~= 0) then 
          if ((len < 0) or (len > buf.length)) then 
            _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
          end;
          local b1 = total.b;
          local b2 = buf.b;
          local _g = 0;
          local _g1 = len;
          while (_g < _g1) do 
            _g = _g + 1;
            local i = _g - 1;
            total.b:push(b2[i]);
          end;
        end;
        if (len < bufsize) then 
          break;
        end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), __haxe_io_Eof)) then 
      self._eof = true;
    else
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return total:getBytes() end
end
__sys_io__Process_ProcessInput.prototype.close = function(self) 
  self.b:close();
end

__sys_io__Process_ProcessInput.prototype.__class__ =  __sys_io__Process_ProcessInput
__sys_io__Process_ProcessInput.__super__ = __haxe_io_Input
setmetatable(__sys_io__Process_ProcessInput.prototype,{__index=__haxe_io_Input.prototype})
setmetatable(__sys_io__Process_ProcessInput.prototype.__properties__,{__index=__haxe_io_Input.prototype.__properties__})

__sys_io__Process_ProcessOutput.new = function(pipe) 
  local self = _hx_new(__sys_io__Process_ProcessOutput.prototype)
  __sys_io__Process_ProcessOutput.super(self,pipe)
  return self
end
__sys_io__Process_ProcessOutput.super = function(self,pipe) 
  self.b = pipe;
  self:set_bigEndian(__lua_Boot.platformBigEndian);
end
_hxClasses["sys.io._Process.ProcessOutput"] = __sys_io__Process_ProcessOutput
__sys_io__Process_ProcessOutput.__name__ = "sys.io._Process.ProcessOutput"
__sys_io__Process_ProcessOutput.prototype = _hx_e();
__sys_io__Process_ProcessOutput.prototype.b= nil;
__sys_io__Process_ProcessOutput.prototype.writeByte = function(self,c) 
  self.b:write(_G.string.char(c));
end
__sys_io__Process_ProcessOutput.prototype.close = function(self) 
  self.b:close();
end

__sys_io__Process_ProcessOutput.prototype.__class__ =  __sys_io__Process_ProcessOutput
__sys_io__Process_ProcessOutput.__super__ = __haxe_io_Output
setmetatable(__sys_io__Process_ProcessOutput.prototype,{__index=__haxe_io_Output.prototype})
setmetatable(__sys_io__Process_ProcessOutput.prototype.__properties__,{__index=__haxe_io_Output.prototype.__properties__})

__theories_EightQueens.new = {}
_hxClasses["theories.EightQueens"] = __theories_EightQueens
__theories_EightQueens.__name__ = "theories.EightQueens"

__theories_Zebra.new = {}
_hxClasses["theories.Zebra"] = __theories_Zebra
__theories_Zebra.__name__ = "theories.Zebra"
-- require this for lua 5.1
pcall(require, 'bit')
if bit then
  _hx_bit_raw = bit
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
else
  _hx_bit_raw = _G.require('bit32')
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
-- see https://github.com/HaxeFoundation/haxe/issues/8849
_hx_bit.bor = function(...) return _hx_bit_clamp(_hx_bit_raw.bor(...)) end;
_hx_bit.band = function(...) return _hx_bit_clamp(_hx_bit_raw.band(...)) end;
_hx_bit.arshift = function(...) return _hx_bit_clamp(_hx_bit_raw.arshift(...)) end;

if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  
  if (__lua_lib_lrexlib_Rex == nil) then 
    _G.error(__haxe_Exception.thrown("Rex is missing.  Please install lrexlib-pcre."),0);
  end;
  String.__name__ = "String";
  _hxClasses.Array = Array;
  Array.__name__ = "Array";
  __haxe_Resource.content = _hx_tab_array({[0]={ name = "DefiniteClauseGrammar.prolog", data = "cHJlcHJvY2Vzc29yKCBwcmVwcm9jZXNzRENHICkuCgolPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiUgRGVmaW5pdGUgQ2xhdXNlIEdyYW1tYXJzCiU9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KcHJlcHJvY2Vzc0RDRyhfICxbXSxbXSkgOi0gIS4KcHJlcHJvY2Vzc0RDRyhEQiwoSGVhZC0tPlRhaWwpLE91dCkgOi0gZGNnKEhlYWQsVGFpbCxPdXQpLgoKZGNnKEgsVCxPdXQpIDotIGRjZyhULEEsQixUMiksIEg9Li5IMiwgYXBwZW5kKEgyLFtBLEJdLEgzKSwgSDQ9Li5IMywgT3V0PShINDotVDIpLgoKJS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KJSBSZXdyaXRlIGEgdGVybSBpbiB0aGUgYm9keQolIFQgLSB0ZXJtIGluLCBBIC0gaW5jb21pbmcgbGlzdCwgQiAtIG91dGdvaW5nIGxpc3QsIE91dCAtIHJld3JpdHRlbiB0ZXJtIAolLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKZGNnKChYLFkpICxBLEIsT3V0KSA6LSBkY2coWCxBLEEyLFgyKSwgZGNnKFksQTIsQixZMiksIE91dD0oWDIsWTIpLCAhLgpkY2coKFg7WSkgLEEsQixPdXQpIDotIGRjZyhYLEEsQixYMiksICBkY2coWSxBLEIsWTIpLCAgT3V0PShYMjtZMiksICEuCmRjZygoISkgICAsQSxBLCghKSkgOi0gIS4KZGNnKChcK1QpICxBLEIsT3V0KSA6LSBkY2coVCxBLEIsVDIpLCBPdXQ9KFwrVDIpLCAhLgpkY2coe091dH0gLEEsQSxPdXQpIDotICEuCmRjZyhUICAgICAsQSxCLE91dCkgOi0gaXNfbGlzdChUKSwgYXBwZW5kKFQsQixUMiksIE91dD0oQT1UMiksICEuCgpkY2coKFQ+PkMpLEEsQixPdXQpIDotIGRjZyhULEEsQixUMiksIE91dD0oVDIsbGlzdF9zbGljZShBLEIsQykpLCAhLgoKZGNnKChJLT5UKSxBLEIsT3V0KSA6LSBkY2coSSxBLEEyLEkyKSwgIGRjZyhULEEyLEIsVDIpLCAgT3V0PShJMi0+VDIpLCAhLgoKZGNnKCcjaWZfdGhlbl9lbHNlJyhJLFQsRSksQSxCLE91dCkgOi0gCiAgICBkY2coSSxBICxBMixJMiksCiAgICBkY2coVCxBMixCICxUMiksCiAgICBkY2coRSxBICxCICxFMiksCiAgICBPdXQ9JyNpZl90aGVuX2Vsc2UnKEkyLFQyLEUyKSwgIS4KCmRjZyhULEEsQixPdXQpIDotIFQ9Li5UMiwgYXBwZW5kKFQyLFtBLEJdLFQzKSwgT3V0PS4uVDMuCg"},{ name = "ConstraintHandlingRules.prolog", data = "cHJlcHJvY2Vzc29yKCBwcmVwcm9jZXNzQ0hSICkuCgolPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiUgQ29uc3RyYWludCBIYW5kbGluZyBSdWxlcyAoRXh0ZW5kZWQpCiU9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXByb2Nlc3NDSFIoREIsQSxbXSkgOi0gIAogICAgY29uc3RyYWludF9kZWNsKERCLEEpIDsKCXNpbXBsaWZpY2F0aW9uX3J1bGUoREIsQSkgOyAKCXByb3BhZ2F0aW9uX3J1bGUoREIsQSkuICAKCiUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiUgCiUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpwcm9wYWdhdGlvbl9ydWxlKERCLChIZWFkID09PiBUYWlsKSkgOi0gISwgCiAgICBSdWxlIDwtIERCLmdldENvbnN0cmFpbnRDb250ZXh0KHZvaWQpLm5ld1J1bGVCdWlsZGVyKCB0ZXJtKEhlYWQgPT0+IFRhaWwpICksCiAgICBSdWxlLnByb2Nlc3NSdWxlSGVhZCggdGVybSggSGVhZCApICksCglSdWxlLnByb2Nlc3NSdWxlQm9keSggdGVybSggVGFpbCApICksCiAgICB3cml0ZShwcm9wYWdhdGlvbl9ydWxlKERCLChIZWFkID09PiBUYWlsKSkpIC4KCgoKCgpzaW1wbGlmaWNhdGlvbl9ydWxlKERCLChIZWFkIDw9PiBUYWlsKSkgOi0gISwgd3JpdGUoc2ltcGxpZmljYXRpb25fcnVsZShEQiwoSGVhZCA8PT4gVGFpbCkpKSAuCgoKCgolLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQolIENvbnN0cmFpbnQgZGVjbGFyYXRpb24gZGlyZWN0aXZlCiUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpjb25zdHJhaW50X2RlY2woREIsKDotIGNocl9jb25zdHJhaW50KENDKSkpIDotICEsIGZpbmRhbGwoXyxkZWNsYXJlX2NvbnN0cmFpbnRzKCBEQiwgQ0MgKSwgXykuCgpkZWNsYXJlX2NvbnN0cmFpbnRzKCBEQiwgKENvbnMsTW9yZSkgKSA6LSAhLCAgCiAgICBkZWNsYXJlX2NvbnN0cmFpbnQoIERCLCBDb25zICksCglkZWNsYXJlX2NvbnN0cmFpbnRzKCBEQiwgTW9yZSApLgoJCmRlY2xhcmVfY29uc3RyYWludHMoIERCLCBDb25zICkgOi0gZGVjbGFyZV9jb25zdHJhaW50KCBEQiwgQ29ucyApLgoJCmRlY2xhcmVfY29uc3RyYWludCggREIsIE5hbWUvQXJpdHkgKSA6LSAhLAogICAgREIuZGVjbGFyZUNvbnN0cmFpbnRQcmVkaWNhdGUoICdibHViLnByb2xvZy5QcmVkaWNhdGVJbmRpY2F0b3InKHRlcm0oTmFtZSksQXJpdHkpICkuCgkKZGVjbGFyZV9jb25zdHJhaW50KCBEQiwgT3RoZXIgKSA6LSB0aHJvd191cCggaW52YWxpZF9jb25zdHJhaW50X2RlY2xhcmF0aW9uKE90aGVyKSApLg"}}, 2);EReg.FLAGS = __lua_lib_lrexlib_Rex.flags();
  
  EReg.escapeRegExpRe = EReg.new("[\\[\\]{}()*+?.\\\\\\^$|]", "g");
  
  __haxe_SysTools.winMetaCharacters = _hx_tab_array({[0]=32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13, 44, 59}, 15);
  
  StringTools.winMetaCharacters = __haxe_SysTools.winMetaCharacters;
  
  TimingTests.queens_theory = "queens([]).                                  % when place queen in empty list, solution found\n \nqueens([ Row/Col | Rest]) :-                 % otherwise, for each row\n            queens(Rest),                    % place a queen in each higher numbered row\n            member(Col, [1,2,3,4,5,6,7,8]),  % pick one of the possible column positions\n            safe( Row/Col, Rest).            % and see if that is a safe position\n                                             % if not, fail back and try another column, until\n                                             % the columns are all tried, when fail back to\n                                             % previous row\n \nsafe(_, []).                                 % the empty board is always safe\n \nsafe(Row/Col, [Row1/Col1 | Rest]) :-         % see if attack the queen in next row down\n            Col =\\= Col1,                   % same column?\n            Col1 - Col =\\= Row1 - Row,      % check diagonal\n            Col1 - Col =\\= Row - Row1,\n            safe(Row/Col, Rest).             % no attack on next row, try the rest of board\n  \nboard([1/_, 2/_, 3/_, 4/_, 5/_, 6/_, 7/_, 8/_]).  % prototype board\n\nrun_queens(B) :- board(B),queens(B).\n";
  
  TimingTests.zebra_theory = "zebra(Owner) :- solve(S),member([_, Owner, zebra, _, _], S).\n\nsolve(S) :-\n    S = [[C1,N1,P1,D1,S1],\n         [C2,N2,P2,D2,S2],\n         [C3,N3,P3,D3,S3],\n         [C4,N4,P4,D4,S4],\n         [C5,N5,P5,D5,S5]],\n    member([red, 'English man', _, _, _], S),\n    member([_, 'Swede', dog, _, _], S),\n    member([_, 'Dane', _, tea, _], S),\n    left_of([green |_], [white |_], S),\n    member([green, _, _, coffee, _], S),\n    member([_, _, birds, _, pall_mall], S),\n    member([yellow, _, _, _, dunhill], S),\n    D3 = milk,\n    N1 = 'Norwegian',\n    next_to([_, _, _, _, blend], [_, _, cats |_], S),\n    next_to([_, _, _, _, dunhill], [_, _, horse |_], S),\n    member([_, _, _, beer, blue_master], S),\n    member([_, 'German', _, _, prince], S),\n    next_to([_, 'Norwegian' |_], [blue |_], S),\n    next_to([_, _, _, water,_], [_, _, _, _, blend], S),\n    C1 \\== C2, C1 \\== C3, C1 \\== C4, C1 \\== C5,\n    C2 \\== C3, C2 \\== C4, C2 \\== C5,\n    C3 \\== C4, C3 \\== C5, C4 \\== C5,\n    N1 \\== N2, N1 \\== N3, N1 \\== N4, N1 \\== N5,\n    N2 \\== N3, N2 \\== N4, N2 \\== N5,\n    N3 \\== N4, N3 \\== N5, N4 \\== N5,\n    P1 \\== P2, P1 \\== P3, P1 \\== P4, P1 \\== P5,\n    P2 \\== P3, P2 \\== P4, P2 \\== P5,\n    P3 \\== P4, P3 \\== P5, P4 \\== P5,\n    D1 \\== D2, D1 \\== D3, D1 \\== D4, D1 \\== D5,\n    D2 \\== D3, D2 \\== D4, D2 \\== D5,\n    D3 \\== D4, D3 \\== D5, D4 \\== D5,\n    S1 \\== S2, S1 \\== S3, S1 \\== S4, S1 \\== S5,\n    S2 \\== S3, S2 \\== S4, S2 \\== S5,\n    S3 \\== S4, S3 \\== S5, S4 \\== S5.\n\nleft_of(L1, L2, [L1, L2 |_]).\nleft_of(L1, L2, [_| Rest ]) :- left_of(L1, L2, Rest).\n    \nnext_to(L1, L2, S) :- left_of(L1, L2, S).\nnext_to(L1, L2, S) :- left_of(L2, L1, S).\n\n";
  
  __blub_prolog_AtomContext.GLOBALS = __blub_prolog_AtomContext.new();
  
  __blub_prolog_Marshal.object_atom_id = 0;
  
  __blub_prolog_PredicateIndicator.SLASH = __blub_prolog_AtomContext.GLOBALS:getAtom("/");
  
  __blub_prolog_Preprocessor.THEORIES = _hx_tab_array({[0]="DefiniteClauseGrammar.prolog", "ConstraintHandlingRules.prolog"}, 2);
  
  __blub_prolog_RuntimeError.ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("error");
  
  __blub_prolog_RuntimeError.CONTEXT = __blub_prolog_AtomContext.GLOBALS:getAtom("context");
  
  __blub_prolog_RuntimeError.NONE = __blub_prolog_AtomContext.GLOBALS:getAtom("none");
  
  __blub_prolog_RuntimeError.INSTANTIATION_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("instantiation_error");
  
  __blub_prolog_RuntimeError.TYPE_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("type_error");
  
  __blub_prolog_RuntimeError.EXISTENCE_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("existence_error");
  
  __blub_prolog_RuntimeError.DOMAIN_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("domain_error");
  
  __blub_prolog_RuntimeError.PERMISSION_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("permission_error");
  
  __blub_prolog_RuntimeError.REPRESENTATION_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("representation_error");
  
  __blub_prolog_RuntimeError.EVALUATION_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("evaluation_error");
  
  __blub_prolog_RuntimeError.RESOURCE_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("resource_error");
  
  __blub_prolog_RuntimeError.SYNTAX_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("syntax_error");
  
  __blub_prolog_RuntimeError.SYSTEM_ERROR = __blub_prolog_AtomContext.GLOBALS:getAtom("system_error");
  
  __blub_prolog_RuntimeError.EXIST_PROCEDURE = __blub_prolog_AtomContext.GLOBALS:getAtom("procedure");
  
  __blub_prolog_RuntimeError.EXIST_SRC_SINK = __blub_prolog_AtomContext.GLOBALS:getAtom("source_sink");
  
  __blub_prolog_RuntimeError.EXIST_STREAM = __blub_prolog_AtomContext.GLOBALS:getAtom("stream");
  
  __blub_prolog_TypeError.VALID_TYPE_atom = __blub_prolog_AtomContext.GLOBALS:getAtom("atom");
  
  __blub_prolog_TypeError.VALID_TYPE_atomic = __blub_prolog_AtomContext.GLOBALS:getAtom("atomic");
  
  __blub_prolog_TypeError.VALID_TYPE_byte = __blub_prolog_AtomContext.GLOBALS:getAtom("byte");
  
  __blub_prolog_TypeError.VALID_TYPE_callable = __blub_prolog_AtomContext.GLOBALS:getAtom("callable");
  
  __blub_prolog_TypeError.VALID_TYPE_character = __blub_prolog_AtomContext.GLOBALS:getAtom("character");
  
  __blub_prolog_TypeError.VALID_TYPE_evaluable = __blub_prolog_AtomContext.GLOBALS:getAtom("evaluable");
  
  __blub_prolog_TypeError.VALID_TYPE_in_byte = __blub_prolog_AtomContext.GLOBALS:getAtom("in_byte");
  
  __blub_prolog_TypeError.VALID_TYPE_in_character = __blub_prolog_AtomContext.GLOBALS:getAtom("in_character");
  
  __blub_prolog_TypeError.VALID_TYPE_integer = __blub_prolog_AtomContext.GLOBALS:getAtom("integer");
  
  __blub_prolog_TypeError.VALID_TYPE_list = __blub_prolog_AtomContext.GLOBALS:getAtom("list");
  
  __blub_prolog_TypeError.VALID_TYPE_number = __blub_prolog_AtomContext.GLOBALS:getAtom("number");
  
  __blub_prolog_TypeError.VALID_TYPE_predicate_indicator = __blub_prolog_AtomContext.GLOBALS:getAtom("predicate_indicator");
  
  __blub_prolog_TypeError.VALID_TYPE_variable = __blub_prolog_AtomContext.GLOBALS:getAtom("variable");
  
  __blub_prolog_TypeError.VALID_TYPE_compound = __blub_prolog_AtomContext.GLOBALS:getAtom("compound");
  
  __blub_prolog_engine_parts_ChoicePoint.ID = 1;
  
  __blub_prolog_builtins_Call.INDICATOR = __blub_prolog_PredicateIndicator.fromString("call/1");
  
  __blub_prolog_builtins_Gensym.count = 1;
  
  __lua_Boot._fid = 0;
  
  __lua_Boot.Max_Int32 = 2147483647;
  
  __lua_Boot.Min_Int32 = -2147483648;
  
  __lua_Boot.MAXSTACKSIZE = 1000;
  
  __lua_Boot.platformBigEndian = _G.string.byte(_G.string.dump(function() 
  end), 7) > 0;
  
  __lua_Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
  __lua_Boot.os_patterns = (function() 
    local _hx_1
    
    local _g = __haxe_ds_StringMap.new();
    
    local value = _hx_tab_array({[0]="windows", "^mingw", "^cygwin"}, 3);
    if (value == nil) then 
      _g.h.Windows = __haxe_ds_StringMap.tnull;
    else
      _g.h.Windows = value;
    end;
    
    local value = _hx_tab_array({[0]="linux"}, 1);
    if (value == nil) then 
      _g.h.Linux = __haxe_ds_StringMap.tnull;
    else
      _g.h.Linux = value;
    end;
    
    local value = _hx_tab_array({[0]="mac", "darwin", "osx"}, 3);
    if (value == nil) then 
      _g.h.Mac = __haxe_ds_StringMap.tnull;
    else
      _g.h.Mac = value;
    end;
    
    local value = _hx_tab_array({[0]="bsd$"}, 1);
    if (value == nil) then 
      _g.h.BSD = __haxe_ds_StringMap.tnull;
    else
      _g.h.BSD = value;
    end;
    
    local value = _hx_tab_array({[0]="SunOS"}, 1);
    if (value == nil) then 
      _g.h.Solaris = __haxe_ds_StringMap.tnull;
    else
      _g.h.Solaris = value;
    end;
    
    _hx_1 = _g;
    return _hx_1
  end )();
  
  __blub_prolog_builtins_Builtins.builtins = _hx_tab_array({[0]=__blub_prolog_builtins_True.new(), __blub_prolog_builtins_Fail.new(), __blub_prolog_builtins_Repeat.new(), __blub_prolog_builtins_Is.new(), __blub_prolog_builtins_Unify.new(), __blub_prolog_builtins_Identical.new(), __blub_prolog_builtins_NotIdentical.new(), __blub_prolog_builtins_Cut.new(), __blub_prolog_builtins_Call.new(), __blub_prolog_builtins_Once.new(), __blub_prolog_builtins_NotUnifiable.new(), __blub_prolog_builtins_NotProvable.new(), __blub_prolog_builtins_IfThen.new(), __blub_prolog_builtins_IfThenElse.new(), __blub_prolog_builtins_AssertA.new(), __blub_prolog_builtins_AssertZ.new(), __blub_prolog_builtins_Retract.new(), __blub_prolog_builtins_Abolish.new(), __blub_prolog_builtins_Timestamp.new(), __blub_prolog_builtins_Gensym.new(), __blub_prolog_builtins_Univ.new(), __blub_prolog_builtins_Write.new(), __blub_prolog_builtins_Clear.new(), __blub_prolog_builtins_Stop.new(), __blub_prolog_builtins_Functor.new(), __blub_prolog_builtins_Arg.new(), __blub_prolog_builtins_AtomCodes.new(), __blub_prolog_builtins_ListSlice.new(), __blub_prolog_builtins_Stack.new(), __blub_prolog_builtins_Member.new(), __blub_prolog_builtins_Breakpoint.new(), __blub_prolog_builtins_Listing.new(), __blub_prolog_builtins_ThrowUp.new()}, 33):concat(__blub_prolog_builtins_BinaryArithmeticPred.get()):concat(__blub_prolog_builtins_TermTypes.get()):concat(__blub_prolog_builtins_Globals.get()):concat(__blub_prolog_builtins_RebindVar.get()):concat(__blub_prolog_builtins_objects_ObjectBuiltins.get()):concat(__blub_prolog_builtins_async_AsyncBuiltins.get()):concat(__blub_prolog_builtins_meta_MetaBuiltins.get());
  
  __blub_prolog_compiler_CompilerBase.ADD_LOGGING = true;
  
  __blub_prolog_terms_Reference.nameGen = 0;
  
  __blub_prolog_engine_ArithmeticEvaluator.arithmeticFuncs = (function() 
    local _hx_2
    
    local h = __haxe_ds_StringMap.new();
    
    h.h["+/2"] = true;
    
    h.h["-/2"] = true;
    
    h.h["*/2"] = true;
    
    h.h["//2"] = true;
    
    _hx_2 = h;
    return _hx_2
  end )();
  
  __blub_prolog_stopgap_parse_Char.OP_CHARS = "#$&*+-./:<=>?@^~\\";
  
  __blub_prolog_stopgap_parse_Char.WHITESPACE = " \n\r\t\012";
  
  __blub_prolog_terms_Atom.ID_GEN = 0;
  
  __blub_prolog_terms_Atom.A_CODE = __lua_lib_luautf8_Utf8.byte("A", 1);
  
  __blub_prolog_terms_Atom.Z_CODE = __lua_lib_luautf8_Utf8.byte("Z", 1);
  
  __blub_prolog_terms_Atom.a_CODE = __lua_lib_luautf8_Utf8.byte("a", 1);
  
  __blub_prolog_terms_Atom.z_CODE = __lua_lib_luautf8_Utf8.byte("z", 1);
  
  __blub_prolog_terms_Atom.zero_CODE = __lua_lib_luautf8_Utf8.byte("0", 1);
  
  __blub_prolog_terms_Atom.nine_CODE = __lua_lib_luautf8_Utf8.byte("9", 1);
  
  __blub_prolog_terms_Atom.under_CODE = __lua_lib_luautf8_Utf8.byte("_", 1);
  
  __blub_prolog_terms_Structure.CONS_LIST = __blub_prolog_AtomContext.GLOBALS:getAtom("CONS");
  
  __blub_prolog_terms_Structure.EMPTY_LIST = __blub_prolog_AtomContext.GLOBALS:getAtom("[]");
  
  __blub_prolog_terms_Variable.nameCount = 0;
  
  __blub_prolog_terms_VariableContext.EMPTY = __blub_prolog_terms_VariableContext.new(nil, __haxe_ds_StringMap.new(), _hx_tab_array({}, 0));
  
  __haxe_EntryPoint.sleepLock = __haxe__EntryPoint_Lock.new();
  
  __haxe_EntryPoint.mutex = __haxe__EntryPoint_Mutex.new();
  
  __haxe_EntryPoint.pending = Array.new();
  
  __haxe_EntryPoint.threadCount = 0;
  
  __haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  __haxe_crypto_Base64.BYTES = __haxe_io_Bytes.ofString(__haxe_crypto_Base64.CHARS);
  
  __haxe_crypto_Base64.URL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  
  __haxe_crypto_Base64.URL_BYTES = __haxe_io_Bytes.ofString(__haxe_crypto_Base64.URL_CHARS);
  
  __haxe_ds_IntMap.tnull = ({});
  
  __haxe_ds_ObjectMap.count = 0;
  
  __haxe_ds_StringMap.tnull = ({});
  
  __haxe_io_FPHelper.i64tmp = (function() 
    local _hx_3
    
    local this1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(0, 31), 0);
    
    _hx_3 = this1;
    return _hx_3
  end )();
  
  __haxe_io_FPHelper.LN2 = 0.6931471805599453;
  
  __lua__Io_IoType_Impl_.File = "file";
  
  __lua__Io_IoType_Impl_.ClosedFile = "closed file";
  
  __lua__Io_IoType_Impl_.NotAFile = nil;
  
  __sys_io_Process.argQuote = (function() 
    local _hx_4
    if (Sys.systemName() == "Windows") then 
    _hx_4 = function(x) 
      do return __haxe_SysTools.quoteWinArg(x, true) end;
    end; else 
    _hx_4 = __haxe_SysTools.quoteUnixArg; end
    return _hx_4
  end )();
  
  __sys_io_Process._shell = (function() 
    local _hx_5
    if (Sys.systemName() == "Windows") then 
    _hx_5 = "cmd.exe"; else 
    _hx_5 = "/bin/sh"; end
    return _hx_5
  end )();
  
  __theories_EightQueens.theory = "queens([]).                                  % when place queen in empty list, solution found\n \nqueens([ Row/Col | Rest]) :-                 % otherwise, for each row\n            queens(Rest),                    % place a queen in each higher numbered row\n            member(Col, [1,2,3,4,5,6,7,8]),  % pick one of the possible column positions\n            safe( Row/Col, Rest).            % and see if that is a safe position\n                                             % if not, fail back and try another column, until\n                                             % the columns are all tried, when fail back to\n                                             % previous row\n \nsafe(_, []).                                 % the empty board is always safe\n \nsafe(Row/Col, [Row1/Col1 | Rest]) :-         % see if attack the queen in next row down\n            Col =\\= Col1,                   % same column?\n            Col1 - Col =\\= Row1 - Row,      % check diagonal\n            Col1 - Col =\\= Row - Row1,\n            safe(Row/Col, Rest).             % no attack on next row, try the rest of board\n  \nboard([1/_, 2/_, 3/_, 4/_, 5/_, 6/_, 7/_, 8/_]).  % prototype board\n\nrun_queens(B) :- board(B),queens(B).\n";
  
  __theories_Zebra.theory = "zebra(Owner) :- solve(S),member([_, Owner, zebra, _, _], S).\n\nsolve(S) :-\n    S = [[C1,N1,P1,D1,S1],\n         [C2,N2,P2,D2,S2],\n         [C3,N3,P3,D3,S3],\n         [C4,N4,P4,D4,S4],\n         [C5,N5,P5,D5,S5]],\n    member([red, 'English man', _, _, _], S),\n    member([_, 'Swede', dog, _, _], S),\n    member([_, 'Dane', _, tea, _], S),\n    left_of([green |_], [white |_], S),\n    member([green, _, _, coffee, _], S),\n    member([_, _, birds, _, pall_mall], S),\n    member([yellow, _, _, _, dunhill], S),\n    D3 = milk,\n    N1 = 'Norwegian',\n    next_to([_, _, _, _, blend], [_, _, cats |_], S),\n    next_to([_, _, _, _, dunhill], [_, _, horse |_], S),\n    member([_, _, _, beer, blue_master], S),\n    member([_, 'German', _, _, prince], S),\n    next_to([_, 'Norwegian' |_], [blue |_], S),\n    next_to([_, _, _, water,_], [_, _, _, _, blend], S),\n    C1 \\== C2, C1 \\== C3, C1 \\== C4, C1 \\== C5,\n    C2 \\== C3, C2 \\== C4, C2 \\== C5,\n    C3 \\== C4, C3 \\== C5, C4 \\== C5,\n    N1 \\== N2, N1 \\== N3, N1 \\== N4, N1 \\== N5,\n    N2 \\== N3, N2 \\== N4, N2 \\== N5,\n    N3 \\== N4, N3 \\== N5, N4 \\== N5,\n    P1 \\== P2, P1 \\== P3, P1 \\== P4, P1 \\== P5,\n    P2 \\== P3, P2 \\== P4, P2 \\== P5,\n    P3 \\== P4, P3 \\== P5, P4 \\== P5,\n    D1 \\== D2, D1 \\== D3, D1 \\== D4, D1 \\== D5,\n    D2 \\== D3, D2 \\== D4, D2 \\== D5,\n    D3 \\== D4, D3 \\== D5, D4 \\== D5,\n    S1 \\== S2, S1 \\== S3, S1 \\== S4, S1 \\== S5,\n    S2 \\== S3, S2 \\== S4, S2 \\== S5,\n    S3 \\== S4, S3 \\== S5, S4 \\== S5.\n\nleft_of(L1, L2, [L1, L2 |_]).\nleft_of(L1, L2, [_| Rest ]) :- left_of(L1, L2, Rest).\n    \nnext_to(L1, L2, S) :- left_of(L1, L2, S).\nnext_to(L1, L2, S) :- left_of(L2, L1, S).\n\n";
  
  
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

_G.math.randomseed(_G.os.time());

_hx_print = print or (function() end)

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

_hx_static_init();
_G.xpcall(function() 
  TimingTests.main();
  __haxe_EntryPoint.run();
end, _hx_error)
return _hx_exports
